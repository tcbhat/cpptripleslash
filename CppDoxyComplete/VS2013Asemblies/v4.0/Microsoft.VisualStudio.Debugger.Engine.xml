<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Microsoft.VisualStudio.Debugger.Engine</name>
  </assembly>
  <members>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CodeChunkInfo"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CodeChunkInfo.length"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CodeChunkInfo.startAddr"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION.Flags"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION.ilOffset"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION.pAppDomain"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION.pFunction"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION.pModule"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_IL_TO_NATIVE_MAP"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_IL_TO_NATIVE_MAP.ilOffset"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_IL_TO_NATIVE_MAP.nativeEndOffset"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_IL_TO_NATIVE_MAP.nativeStartOffset"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_STEP_RANGE"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_STEP_RANGE.endOffset"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_STEP_RANGE.startOffset"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.COR_IL_MAP"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_IL_MAP.fAccurate"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_IL_MAP.newOffset"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_IL_MAP.oldOffset"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.COR_VERSION"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_VERSION.dwBuild"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_VERSION.dwMajor"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_VERSION.dwMinor"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.COR_VERSION.dwSubBuild"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_CLASS_INIT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_CONTEXT_POLICY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_CONTEXT_SWITCH">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_DEBUGGER_EVAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_ENTER_MANAGED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_ENTER_UNMANAGED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_EXCEPTION_FILTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_FUNC_EVAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_INTERCEPTION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_NONE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_PROCESS_START">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_SECURITY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason.CHAIN_THREAD_START">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugCreateProcessFlags"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugCreateProcessFlags.DEBUG_NO_SPECIAL_OPTIONS">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionCallbackType"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_CATCH_HANDLER_FOUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_FIRST_CHANCE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_UNHANDLED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionCallbackType.DEBUG_EXCEPTION_USER_FIRST_CHANCE">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionUnwindCallbackType"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionUnwindCallbackType.DEBUG_EXCEPTION_INTERCEPTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugExceptionUnwindCallbackType.DEBUG_EXCEPTION_UNWIND_BEGIN">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugHandleType"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugHandleType.HANDLE_STRONG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugHandleType.HANDLE_WEAK_TRACK_RESURRECTION">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_NONE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_ALL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_CLASS_INIT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_EXCEPTION_FILTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_SECURITY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_CONTEXT_POLICY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept.INTERCEPT_INTERCEPTION">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_NONE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_M2U">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_U2M">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_APPDOMAIN_TRANSITION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_LIGHTWEIGHT_FUNCTION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_FUNC_EVAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType.STUBFRAME_INTERNALCALL">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_APPROXIMATE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_EPILOG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_EXACT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_NO_INFO">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_PROLOG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult.MAPPING_UNMAPPED_ADDRESS">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R10">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R11">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R12">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R13">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R14">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R15">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R8">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_R9">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RAX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RBP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RBX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RCX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RDI">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RDX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RIP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RSI">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_RSP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM0">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM1">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM10">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM11">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM12">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM13">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM14">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM15">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM2">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM3">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM4">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM5">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM6">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM7">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM8">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_AMD64_XMM9">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_FRAME_POINTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_IA64_BSP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_IA64_F0">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_IA64_R0">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_INSTRUCTION_POINTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_STACK_POINTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EAX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EBP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EBX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_ECX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EDI">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EDX">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_EIP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_ESI">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_ESP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_0">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_1">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_2">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_3">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_4">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_5">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_6">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister.REGISTER_X86_FPSTACK_7">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_NORMAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_RETURN">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_CALL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_EXCEPTION_FILTER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_EXCEPTION_HANDLER">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_INTERCEPT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugStepReason.STEP_EXIT">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState.THREAD_RUN">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState.THREAD_SUSPEND">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_ALL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_NONE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_PROLOG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_EPILOG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_NO_MAPPING_INFO">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_OTHER_UNMAPPED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop.STOP_UNMANAGED">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState"></member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_STOP_REQUESTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_SUSPEND_REQUESTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_BACKGROUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_UNSTARTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_STOPPED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_WAIT_SLEEP_JOIN">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_SUSPENDED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState.USER_UNSAFE_POINT">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.Attach"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.CanCommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.CommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.Continue(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.Detach"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.EnumerateAssemblies(Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.EnumerateBreakpoints(Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.EnumerateSteppers(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.EnumerateThreads(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.GetID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.GetModuleFromMetaDataInterface(System.Object,Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.GetName(System.UInt32,System.UInt32@,System.Text.StringBuilder)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.GetObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.GetProcess(System.IntPtr@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.HasQueuedCallbacks(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread,System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.IsAttached(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.IsRunning(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.SetAllThreadsDebugState(Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.Stop(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain.Terminate(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain2.GetArrayOrPointerType(System.Int32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain2.GetFunctionPointerType(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[],Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.CreateRelocBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetBaseIndicies(System.UInt32,System.UInt32[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetDimensions(System.UInt32,System.UInt32[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetElement(System.UInt32,System.Int32[],Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetElementAtPosition(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetElementType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetRank(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.HasBaseIndicies(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugArrayValue.IsValid(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly.EnumerateModules(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly.GetAppDomain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly.GetCodeBase(System.UInt32,System.UInt32@,System.Char[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly.GetName(System.UInt32,System.UInt32@,System.Char[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly.GetProcess(Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly2.IsFullyTrusted(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssemblyEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.CreateRelocBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.GetObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBoxValue.IsValid(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpoint"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpoint.Activate(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpoint.IsActive(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpoint[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugBreakpointEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.EnumerateFrames(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetActiveFrame(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetCallee(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetCaller(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetContext(Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetNext(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetPrevious(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetReason(Microsoft.VisualStudio.CorDebugInterop.CorDebugChainReason@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetRegisterSet(System.IntPtr@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetStackRange(System.UInt64@,System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.GetThread(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain.IsManaged(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass.GetModule(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass.GetStaticFieldValue(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass.GetToken(System.UInt32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass2.GetParameterizedType(System.Int32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[],Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass2.SetJMCStatus(System.Int32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.CreateBreakpoint(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetCode(System.UInt32,System.UInt32,System.UInt32,System.Byte[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetEnCRemapSequencePoints(System.UInt32,System.UInt32@,System.UInt32[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetILToNativeMapping(System.UInt32,System.UInt32@,Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_IL_TO_NATIVE_MAP[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.GetVersionNumber(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode.IsIL(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode2.GetCodeChunks(System.UInt32,System.UInt32@,Microsoft.VisualStudio.CorDebugInterop.CodeChunkInfo[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode2.GetCompilerFlags(System.UInt32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetClass(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetContext(Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetFieldValue(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetManagedCopy(System.Object@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.GetVirtualMethod(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.IsValueClass(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext.SetFromManagedCopy(System.Object)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.CanCommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.CommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.Continue(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.Detach"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.EnumerateThreads(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.HasQueuedCallbacks(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread,System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.IsRunning(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.SetAllThreadsDebugState(Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.Stop(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugController.Terminate(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.CopyMetaData(System.Runtime.InteropServices.ComTypes.IStream,System.Guid@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.GetMvid(System.Guid@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.GetRoDataRVA(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.GetRwDataRVA(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.SetILMap(System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.COR_IL_MAP@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.SetPEBytes(System.Runtime.InteropServices.ComTypes.IStream)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot.SetPESymbolBytes(System.Runtime.InteropServices.ComTypes.IStream)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum.Next(System.UInt32,System.IntPtr,System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.Abort"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.CallFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.CreateValue(System.Int32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.GetResult(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.GetThread(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.IsActive(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.NewArray(System.Int32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass,System.UInt32,System.UInt32@,System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.NewObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.NewObjectNoConstructor(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval.NewString(System.String)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.CallParameterizedFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[],System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.CreateValueForType(Microsoft.VisualStudio.CorDebugInterop.ICorDebugType,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.NewParameterizedArray(Microsoft.VisualStudio.CorDebugInterop.ICorDebugType,System.UInt32,System.UInt32[],System.UInt32[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.NewParameterizedObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[],System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.NewParameterizedObjectNoConstructor(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.NewStringWithLength(System.Char[],System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval2.RudeAbort"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.CreateStepper(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetCallee(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetCaller(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetChain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetFunctionToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame.GetStackRange(System.UInt64@,System.UInt64@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrameEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetClass(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetCurrentVersionNumber(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetILCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetLocalVarSigToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetModule(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetNativeCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction.GetToken(System.UInt32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction2.EnumerateNativeCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCodeEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction2.GetJMCStatus(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction2.GetVersionNumber(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction2.SetJMCStatus(System.Int32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint.Activate(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint.GetOffset(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunctionBreakpoint.IsActive(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.GetValue(System.IntPtr)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugGenericValue.SetValue(System.IntPtr)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.Dereference(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.DereferenceStrong(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.Dispose">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.GetHandleType(Microsoft.VisualStudio.CorDebugInterop.CorDebugHandleType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.GetValue(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.IsNull(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue.SetValue(System.UInt64)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.CreateRelocBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue.IsValid(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugHeapValue2.CreateHandle(Microsoft.VisualStudio.CorDebugInterop.CorDebugHandleType,Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.CanSetIP(System.UInt32)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.CreateStepper(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.EnumerateArguments(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.EnumerateLocalVariables(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetArgument(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetCallee(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetCaller(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetChain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetFunctionToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetIP(System.UInt32@,Microsoft.VisualStudio.CorDebugInterop.CorDebugMappingResult@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetLocalVariable(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetStackDepth(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetStackRange(System.UInt64@,System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.GetStackValue(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame.SetIP(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame2.EnumerateTypeParameters(Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugILFrame2.RemapFunction(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.CreateStepper(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetCallee(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetCaller(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetChain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetFrameType(Microsoft.VisualStudio.CorDebugInterop.CorDebugInternalFrameType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetFunctionToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugInternalFrame.GetStackRange(System.UInt64@,System.UInt64@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.EnableClassLoadCallbacks(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.EnableJITDebugging(System.Int32,System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetAssembly(Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetBaseAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetClassFromToken(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetEditAndContinueSnapshot(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetFunctionFromRVA(System.UInt64,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetFunctionFromToken(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetGlobalVariableValue(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetMetaDataInterface(System.Guid@,System.IntPtr@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetName(System.UInt32,System.UInt32[],System.Char[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetProcess(Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.GetToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.IsDynamic(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule.IsInMemory(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2.ApplyChanges(System.UInt32,System.Byte[],System.UInt32,System.Byte[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2.GetJITCompilerFlags(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2.ResolveAssembly(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugAssembly@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2.SetJITCompilerFlags(System.UInt32)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule2.SetJMCStatus(System.Int32,System.UInt32,System.UInt32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleBreakpoint"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleBreakpoint.Activate(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleBreakpoint.GetModule(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleBreakpoint.IsActive(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule[],System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModuleEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.CanSetIP(System.UInt32)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.CreateStepper(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetCallee(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetCaller(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetChain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetCode(Microsoft.VisualStudio.CorDebugInterop.ICorDebugCode@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetFunction(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetFunctionToken(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetIP(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetLocalDoubleRegisterValue(Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister,Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister,System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetLocalMemoryRegisterValue(System.UInt64,Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister,System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetLocalMemoryValue(System.UInt64,System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetLocalRegisterMemoryValue(Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister,System.UInt64,System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetLocalRegisterValue(Microsoft.VisualStudio.CorDebugInterop.CorDebugRegister,System.UInt32,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetRegisterSet(System.IntPtr@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.GetStackRange(System.UInt64@,System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugNativeFrame.SetIP(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum.Next(System.UInt32,System.UInt64[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetClass(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetContext(Microsoft.VisualStudio.CorDebugInterop.ICorDebugContext@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetFieldValue(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass,System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetManagedCopy(System.Object@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.GetVirtualMethod(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.IsValueClass(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue.SetFromManagedCopy(System.Object)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectValue2.GetVirtualMethodAndType(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.CanCommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.ClearCurrentException(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.CommitChanges(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEditAndContinueSnapshot@,Microsoft.VisualStudio.CorDebugInterop.ICorDebugErrorInfoEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.Continue(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.Detach"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.EnableLogMessages(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.EnumerateAppDomains(Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomainEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.EnumerateObjects(Microsoft.VisualStudio.CorDebugInterop.ICorDebugObjectEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.EnumerateThreads(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetHandle(System.IntPtr@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetHelperThreadID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetThread(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.GetThreadContext(System.UInt32,System.UInt32,System.IntPtr)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.HasQueuedCallbacks(Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread,System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.IsOSSuspended(System.UInt32,System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.IsRunning(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.IsTransitionStub(System.UInt64,System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.ModifyLogSwitch(System.String,System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.ReadMemory(System.UInt64,System.UInt32,System.Byte[],System.IntPtr@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.SetAllThreadsDebugState(Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.SetThreadContext(System.UInt32,System.UInt32,System.IntPtr)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.Stop(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.Terminate(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.ThreadForFiberCookie(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess.WriteMemory(System.UInt64,System.UInt32,System.Byte[],System.IntPtr@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.ClearUnmanagedBreakpoint(System.UInt64)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.GetDesiredNGENCompilerFlags(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.GetReferenceValueFromGCHandle(System.IntPtr,Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.GetThreadForTaskID(System.UInt64,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.GetVersion(Microsoft.VisualStudio.CorDebugInterop.COR_VERSION@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.SetDesiredNGENCompilerFlags(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess2.SetUnmanagedBreakpoint(System.UInt64,System.UInt32,System.Byte[],System.UInt32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcessEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.Dereference(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.DereferenceStrong(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.GetValue(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.IsNull(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugReferenceValue.SetValue(System.UInt64)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.Deactivate"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.IsActive(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.SetInterceptMask(Microsoft.VisualStudio.CorDebugInterop.CorDebugIntercept)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.SetRangeIL(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.SetUnmappedStopMask(Microsoft.VisualStudio.CorDebugInterop.CorDebugUnmappedStop)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.Step(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.StepOut"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper.StepRange(System.Int32,Microsoft.VisualStudio.CorDebugInterop.COR_DEBUG_STEP_RANGE[],System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper2.SetJMC(System.Int32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepperEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.CreateRelocBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.GetLength(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.GetString(System.UInt32,System.UInt32@,System.Char[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.GetType(System.Int32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugStringValue.IsValid(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.ClearCurrentException"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.CreateEval(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.CreateStepper(Microsoft.VisualStudio.CorDebugInterop.ICorDebugStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.EnumerateChains(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChainEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetActiveChain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugChain@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetActiveFrame(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetAppDomain(Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetCurrentException(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetDebugState(Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetHandle(System.IntPtr@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetObject(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetProcess(Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetRegisterSet(System.IntPtr@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.GetUserState(Microsoft.VisualStudio.CorDebugInterop.CorDebugUserState@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread.SetDebugState(Microsoft.VisualStudio.CorDebugInterop.CorDebugThreadState)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2.GetActiveFunctions(System.UInt32,System.UInt32@,Microsoft.VisualStudio.CorDebugInterop.COR_ACTIVE_FUNCTION[])"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2.GetConnectionID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2.GetTaskID(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2.GetVolatileOSThreadID(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread2.InterceptCurrentException(Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThreadEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.EnumerateTypeParameters(Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetBase(Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetClass(Microsoft.VisualStudio.CorDebugInterop.ICorDebugClass@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetFirstTypeParameter(Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetRank(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetStaticFieldValue(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugFrame,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugType.GetType(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugType[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugTypeEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue.CreateBreakpoint(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue.GetAddress(System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue.GetSize(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue.GetType(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue2"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue2.GetExactType(Microsoft.VisualStudio.CorDebugInterop.ICorDebugType@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint.Activate(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint.GetValue(Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueBreakpoint.IsActive(System.Int32@)"></member>
    <member name="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum.Clone(Microsoft.VisualStudio.CorDebugInterop.ICorDebugEnum@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum.GetCount(System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum.Next(System.UInt32,Microsoft.VisualStudio.CorDebugInterop.ICorDebugValue[],System.UInt32@)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum.Reset"></member>
    <member name="M:Microsoft.VisualStudio.CorDebugInterop.ICorDebugValueEnum.Skip(System.UInt32)"></member>
    <member name="T:Microsoft.VisualStudio.Debugger.CorElementType">
      <summary>TODO: this should eventually come from some kind of metadata interop assembly</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CorElementType.ValueZero">
      <summary>TODO: remove me</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmApiVersion">
      <summary>Enumeration code of the various versions of this API.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmApiVersion.VS11RTM">
      <summary>Visual Studio 11 Release to Manufacturing (RTM) version</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus">
      <summary>Indicates the type of async break that occurred.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus.ActiveBreak">
      <summary>An active thread was found inside the target process and the debugger used it to break.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus.FrozenBreak">
      <summary>The target process appears to be deadlocked and was frozen to emulate break mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus.ImmediateBreak">
      <summary>The caller of AsyncBreak requested an immediate break. The target process is frozen to emulate break mode.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId">
      <summary>DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is used for processes debugged by the Win32 debugging API and DkmBaseDebugMonitorId.DumpFile is used for minidumps.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId.ActiveScript">
      <summary>DkmProcess is backed by a live Microsoft Windows ActiveScript process.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId.ClrVirtualMachine">
      <summary>DkmProcess is debugged using ONLY the ICorDebug API (the process is not being debugging through the Win32 debugging API). This value is used when you debug with the ICorDebug v2 pipeline. Scenarios include debugging a Win32 process that is running the v2 CLR and debugging a managed process that is running on a Windows CE device.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId.DumpFile">
      <summary>DkmProcess is back by a minidump or crashdump file.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId.GpuVirtualMachine">
      <summary>DkmProcess is backed by a live Microsoft Windows D3D process that runs GPU code on GPU hardware or reference rasterizer.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmBaseDebugMonitorId.WindowsProcess">
      <summary>DkmProcess is backed by a live Microsoft Windows process.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmCompletionRoutine`1">
      <summary>Function that is called when an asynchronous request has finished running.</summary>
      <typeparam name="TResult">Type of the result parameter.</typeparam>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmComponentManager">
      <summary>Provides services from the dispatcher for initializing threads.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.AllowComponentReentrancy"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmComponentManager.CurrentComponentId">
      <summary>Obtains the component ID that is running on this thread.</summary>
      <returns>GUID for the active component. This GUID value is defined in the component's configuration file. If no component is running, the return value will be Guid.Empty.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.DisableComponentReentrancy"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmComponentManager.IdeComponentId">
      <summary>Component id that can be used by IDE components that want to call into the debugger engine API from their own worker threads. This value can be used to pass to DkmComponentManager.InitializeThread().</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.InitializeThread(System.Guid)">
      <summary>Initializes a thread with the component manager. This is necessary when a component creates one or more worker threads. InitializeThread should only be called one time and must have a matching call to UninitializeThread.</summary>
      <param name="componentId">GUID for the component initializing the thread. This GUID value is defined in the component's configuration file.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">Exception with code E_XAPI_ALREADY_INITIALIZED is thrown if the thread has already been initialized by a different component.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.InitializeThread(System.Guid,System.Boolean@)">
      <summary>Initializes a thread with the component manager. This is necessary when a component creates one or more worker threads. InitializeThread should only be called one time and must have a matching call to UninitializeThread.</summary>
      <param name="componentId">GUID for the component initializing the thread. This GUID value is defined in the component's configuration file.</param>
      <param name="alreadyInitialized">Returns true if the thread was previously initialized by this component. Callers can use this as a hint that UninitializeThread should not be called.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">Exception with code E_XAPI_ALREADY_INITIALIZED is thrown if the thread has already been initialized by a different component.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.IsApiVersionSupported(Microsoft.VisualStudio.Debugger.DkmApiVersion)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmComponentManager.UninitializeThread(System.Guid)">
      <summary>Cleans up a thread that was previously initialized with a call to DkmComponentManager.InitializeThread.</summary>
      <param name="componentId">GUID for the component that is initializing the thread. This GUID value is defined in the component's configuration file.</param>
      <exception cref="T:System.ArgumentException">Thread is not initialized, is still processing other operations, or was initialized by a different component.</exception>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmCustomMessage">
      <summary>Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,System.Int32,System.Object,System.Object)">
      <summary>Create a new DkmCustomMessage object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="Process">[In,Optional] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="MessageCode">[In] Identifies the type of custom event being sent. Partners are free to define any set of values.</param>
      <param name="Parameter1">[In,Optional] Specifies additional message-specific information. Note that if this message has to travel over remoting boundaries, make sure that you restrict the type of this parameter to something which can be marshaled: strings, primitives (ex: int), and arrays of primitives (ex: byte array).</param>
      <param name="Parameter2">[In,Optional] Specifies additional message-specific information. Note that if this message has to travel over remoting boundaries, make sure that you restrict the type of this parameter to something which can be marshaled: strings, primitives (ex: int), and arrays of primitives (ex: byte array).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.MessageCode">
      <summary>Identifies the type of custom event being sent. Partners are free to define any set of values.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.OnCustomStop(Microsoft.VisualStudio.Debugger.DkmThread,System.Guid)">
      <summary>Raises a CustomStop event to a VS service which is expecting it. Note that there are restrictions on the type for parameters to this custom message. See DkmCustomMessage.SendToVsService for more information.</summary>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="VsService">[In] Visual Studio service that this event should be sent to. A VS package must register this service id (ex: Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package must implement the IVsCustomDebuggerStoppingEventHandler110 interface.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.Parameter1">
      <summary>[Optional] Specifies additional message-specific information. Note that if this message has to travel over remoting boundaries, make sure that you restrict the type of this parameter to something which can be marshaled: strings, primitives (ex: int), and arrays of primitives (ex: byte array).</summary>
      <returns>Returns <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.Parameter2">
      <summary>[Optional] Specifies additional message-specific information. Note that if this message has to travel over remoting boundaries, make sure that you restrict the type of this parameter to something which can be marshaled: strings, primitives (ex: int), and arrays of primitives (ex: byte array).</summary>
      <returns>Returns <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.Process">
      <summary>[Optional] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.SendHigher">
      <summary>Sends a message to a listening component which is higher in the hierarchy.</summary>
      <returns>[Out,Optional] Message sent back from the implementation.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.SendLower">
      <summary>Sends a message to a listening component which is lower in the hierarchy.</summary>
      <returns>[Out,Optional] Message sent back from the implementation.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.SendLower(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult})">
      <summary>Sends a message to a listening component which is lower in the hierarchy. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmCustomMessage.SendToVsService(System.Guid,System.Boolean)">
      <summary>Sends a custom message to a Visual Studio package. This can be used, for example, to drive a custom UI or make a custom UI visible by enabling a command context (IVsMonitorSelection.SetCmdUIContext). For local 32-bit debugging, the custom message parameters (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown, string, etc), however, values are transferred between threads without . Therefore if this will not work, the sender is responsible for converting the parameter into a form which can be used from the VS service (ex: calling ole32!CoMarshalInterThreadInterfaceInStream). For remote debugging, and 64-bit debugging, the custom message parameters are marshalled across computers, and so the restrictions describe in the DkmCustomMessage.Parameter1 documentation applies.</summary>
      <param name="VsService">[In] Visual Studio service that this event should be sent to. A VS package must register this service id. The service class must implement the IVsCustomDebuggerEventHandler110 interface. Services can be registered in the registry ($RootKey$\Services\{VsService}), or through the VS shell IProfferService interface. Registry keys may be set through through .pkgdef files. If the service should be called even if it is not already loaded, then the registry approach should be used. If the service should only be called if it has already been started, then IProfferService should be used.</param>
      <param name="IsBlocking">[In] True if SendToPackage should block waiting for the package to finish processing this message. When true, DkmCustomMessage.Process must be non-null.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmCustomMessage.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmDataContainer"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataContainer.GetDataItem``1">
      <summary>Gets the instance of 'T' that has been added to this container instance. If this container does not contain a 'T', this function will return null.</summary>
      <returns>[Optional] 'T' object associated with this container instance.</returns>
      <typeparam name="T">Type of a data item class. This class must derive from DkmDataItem. See the DkmDataContainer definition for more information.</typeparam>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmDataContainer.IsUnloaded">
      <summary>Returns true if an 'unloaded' event has been raised for this object (example: DkmThread::Unload is called) or if the object has been closed. Note that care must be used when you check this status as, without synchronization, the returned status might no longer be accurate the instruction after it is read.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataContainer.RemoveDataItem``1">
      <summary>Removes the instance of 'T' from this container. It is usually unnecessary to call this method as a data container will automatically be emptied when the object is closed.</summary>
      <returns>False if this container did not have an instance of 'T'.</returns>
      <typeparam name="T">Type of a data item class. This class must derive from DkmDataItem. See the DkmDataContainer definition for more information.</typeparam>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataContainer.SetDataItem``1(Microsoft.VisualStudio.Debugger.DkmDataCreationDisposition,``0)">
      <summary>Places a new item in the data container.</summary>
      <param name="CreationDisposition">Action to be taken if there is already an item of type T.</param>
      <param name="item">Item to add in this container.</param>
      <typeparam name="T">Type of a data item class. This class must derive from DkmDataItem. See the DkmDataContainer definition for more information.</typeparam>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmDataCreationDisposition">
      <summary>Action to be taken if the data item is already in the container.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDataCreationDisposition.CreateNew">
      <summary>Add the data item only if there is no other data item with the same id.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDataCreationDisposition.CreateAlways">
      <summary>Always add the data item. If the data item is already present then overwrite it with the new value.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmDataItem">
      <summary>The base class for all data item classes. See 'DkmDataContainer' for more information.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataItem.#ctor"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataItem.OnClose">
      <summary>Invoked on all data items when a data container is closed. Derived classes may override this method if they must perform any operation when the container class is closed (ex: free resources).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmDataItem.OnContainerCreated(Microsoft.VisualStudio.Debugger.DkmDataContainer)">
      <summary>Called when this data item has been passed as the DataItem argument to a Create method. This allows the data item to obtain the newly created dispatcher object before this dispatcher object has been passed to any other component.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags">
      <summary>Internal flags indicating the current state of a dispatcher object.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.None">
      <summary>No flags are currently set</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.ObjectAlive">
      <summary>Object has been fully initialized and has not been closed</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.ObjectUnloaded">
      <summary>Object has been unloaded</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.LockInitialized">
      <summary>Critical Section has been initialized</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.RestrictVisibilityAboveCreationLevel">
      <summary>Object is hidden from components which are above the creation level.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.RestrictVisibilityBelowCreationLevel">
      <summary>Object is hidden from components which are below the creation level.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDispatcherObjectFlags.RemoteMarshalled">
      <summary>Reference object has been marshalled into its associated connection</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmDumpType">
      <summary>Type of dump to save.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDumpType.Minidump">
      <summary>Save a basic minidump. Global memory, heap memory, and modules are not included.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmDumpType.MinidumpWithFullMemory">
      <summary>Save a full minidump. Global memory, heap memory, and modules are included.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEngineFlags">
      <summary>Flags that indicate immutable traits of this engine settings.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEngineFlags.None">
      <summary>No process debug flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEngineFlags.NativeCodeSupported">
      <summary>Engine can do debugging native code. This will be 'false' when you debug .NET CLR v2 code, or .NET code on the device. Note that even when true, native debugging may not be currently enabled (see DkmProcessSettings.IsNativeDebuggingEnabled).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEngineFlags.JustMyCodeSupported">
      <summary>Engine will use Just My Code when it is enabled from the IDE.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEngineId">
      <summary>These are the 'standard' engine GUID values. It is expected that this list will grow over time. Therefore, where it is possible, we recommend that you query for a setting instead of comparing the EngineId.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.COMPlusNativeEng">
      <summary>Debug engine for debugging all code in a Win32 process.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.COMPlusOnlyEng2">
      <summary>Debug engine for debugging CLR code in the desktop CLR 2.0. For example, a Visual Basic application. When debugging in this mode, native debugging is not possible.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.COMPlusOnlyEng4">
      <summary>Debug engine for debugging CLR code within CLR 4. When debugging in this mode, native code is at first hidden, although it can be enabled after the fact.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.COMPlusSQLLocalEng">
      <summary>Debug engine for debugging only user CLR code inside the SQL Server process.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.CoreSystemClr">
      <summary>Debug engine used for Core CLR debugging in Silverlight and XNA apps on Windows Phone.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.EmbeddedClrEngV1">
      <summary>Debug engine used for .NET Compact Framework 1.0 debugging.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.EmbeddedClrEngV2">
      <summary>Debug engine used for .NET Compact Framework 2.0 debugging.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.MacSilverlightEng">
      <summary>Debug engine used for debugging Silverlight applications on Mac computers.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.NativeEng">
      <summary>Native-only debugging engine GUID.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.Script">
      <summary>Debug engine used for Active Script debugging (ex: script in Internet Explorer).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineId.SilverlightEng">
      <summary>Debug engine used for Silverlight debugging.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEngineSettings">
      <summary>Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.BaseDebugMonitorId">
      <summary>Base debug monitor used by this engine. This value may be Guid.Empty (GUID_NULL) if the engine may use various base debug monitors depending on the process being debugged.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.ClrDebuggingServicesId">
      <summary>Indicates which version of the CLR debugging services (mscordbi.dll or other implementation of the ICorDebug API) should be used when you debug this process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.EnableAsyncDebugging">
      <summary>Enables stepping over 'await' statements and stepping out of async methods. This is on by default.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.EnableFuncEvalQuickAbort">
      <summary>Specifies whether FEQA is enabled for this engine for this debug session.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.EngineId">
      <summary>These are the 'standard' engine GUID values. It is expected that this list will grow over time. Therefore, where it is possible, we recommend that you query for a setting instead of comparing the EngineId.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.FindProcess(System.Guid)">
      <summary>Find a DkmProcess element within this DkmEngineSettings. If no element that has the given input key is present, FindProcess will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="UniqueId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.FindSettings(System.Guid)">
      <summary>Find a DkmEngineSettings object. If no object that has the given input key is present, FindSettings will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="EngineId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.Flags">
      <summary>Flags that indicate immutable traits of this engine settings.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmEngineFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.FuncEvalQuickAbortExcludeList">
      <summary>List of executables for whom FEQA is not enabled even if FEQA DLLs are loaded.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.GetCodeViewCompilers">
      <summary>Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may then be used by a symbol provider to map the information in a code view record to the DkmCompilerId structure.</summary>
      <returns>[Out] DkmCodeViewCompilerId[] is used to translate information that is in the S_COMPILE* code view records into a DkmCompilerId. This allows the debugger to load an appropriate expression evaluator for a stack frame. Symbol providers may obtain this collection through DkmEngineSettings. Expression evaluators may add more entries to this collection by having their setup add sub key(s) to the '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.GetLanguage(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Returns the DkmLanguage object which matches the given compiler id. If the language is unknown (not registered with the engine), then this method will return the default language object.</summary>
      <returns>[Out] Describes a programming language.</returns>
      <param name="CompilerId">[In] LanguageId/VendorId search key. Both values may be Guid.Empty to obtain the default language. Otherwise the vendor id must be non-zero or the default language object will be returned.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.GetProcesses">
      <summary>GetProcesses enumerates the DkmProcess elements of this DkmEngineSettings object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.GetSettings">
      <summary>GetSettings enumerates all the created DkmEngineSettings objects.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEngineSettings.GetUserDocumentPath">
      <summary>Get the user document Visual Studio folder path.</summary>
      <returns>[Out] Returns the user document Visual Studio path.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.ImageDebugDirectoryFormats">
      <summary>List of supported values for IMAGE_DEBUG_DIRECTORY.Type.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.IsGpuRaceHazardsAllowSameSettingEnabled">
      <summary>When true, the debugger will ignore GPU race hazards that did not change the previous data.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.IsJustMyCodeEnabled">
      <summary>When true, the debugger will enable JustMyCode features (stepping, call stack, and exception filtering).</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.IsNativeExportsEnabled">
      <summary>When true, the debugger will attempt to use the export tables from Win32 PE files to resolve addresses.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.IsStepOverPropertiesAndOperatorsEnabled">
      <summary>When true, the debugger will step over properties and operators when a step in is performed.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.IsSuppressOptimizationsEnabled">
      <summary>When true, the debugger will suppress Just-In-Time compiler optimizations for newly-loaded modules.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.Languages">
      <summary>Collection of all programming languages supported when you debug this process.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.RemoteClrPdbNamePatterns">
      <summary>List of PDB name patterns used to determine whether PDB will be loaded on remote side.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.RequireFullTrustForSourceServer">
      <summary>When true, the debugger will require assemblies to be fully trusted before executing source server commands from an assembly. The concept of fully trusted only applies to CLR assemblies.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmEngineSettings.SymbolPaths">
      <summary>A collection of DkmStrings representing the symbol search paths and cache path.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEventCode">
      <summary>Enumeration of all events which are currently defined in this API.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.AsyncBreakComplete">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.BoundBreakpointHit">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ComputeKernelExit">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.CustomStop">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.DebugMonitorException">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.EmbeddedBreakpointHit">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.EntryPoint">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ExceptionContinued">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ExceptionTriggerHit">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.FuncEvalCompleted">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.FuncEvalStarting">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.GPUSingleStepComplete">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.InterceptExceptionCompleted">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.LoadComplete">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ModuleCreate">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ModuleInstanceLoad">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ModuleInstanceUnload">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ModuleSymbolsLoaded">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ModuleSymbolsUpdated">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ProcessCreate">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ProcessExit">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ReturnValues">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.RuntimeBreakpoint">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.RuntimeInstanceLoad">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.RuntimeInstanceUnload">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ScriptDocumentContentInsert">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ScriptDocumentContentRemove">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ScriptDocumentTreeNodeCreate">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ScriptDocumentTreeNodeUnload">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ScriptSymbolsUpdated">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.SingleStepComplete">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.StepComplete">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.TaskProviderCreate">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ThreadCreate">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmEventCode.ThreadExit">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEventDescriptor">
      <summary>Describes the event being processed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEventDescriptor.Code">
      <summary>TODO</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmEventCode" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEventDescriptor.Id">
      <summary>TODO</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmEventDescriptorS">
      <summary>Describes the event being processed and provides the ability for a component to suppress this event.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmEventDescriptorS.Suppress">
      <summary>Used to suppress event processing for this event. When called, the event will not be seen by components with a greater component level than the suppressing component.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmException">
      <summary>Base exception class for all exceptions within this API.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmException.#ctor(Microsoft.VisualStudio.Debugger.DkmExceptionCode)">
      <summary>Creates a new exception instance. To enable native interop scenarios, this exception system is error-code based. Therefore, there is no exception string.</summary>
      <param name="code">The HRESULT code for this exception. Using HRESULT values that are defined outside the range of this enumerator is acceptable but not encouraged.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmException.Code">
      <summary>Provides the DkmExcepionCode for this exception.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmExceptionCode" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmExceptionCode">
      <summary>Defines the HRESULT codes used by this API.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FAIL">
      <summary>Unspecified error.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.COR_E_OPERATIONCANCELED">
      <summary>The operation was canceled.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_DEBUGGER_ALREADY_ATTACHED">
      <summary>A debugger is already attached.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_DEBUGGEE_PROCESS_SECURITY_VIOLATION">
      <summary>The process does not have sufficient privileges to be debugged.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_CANNOT_ATTACH_TO_DESKTOP">
      <summary>The desktop cannot be debugged.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_NO_INTEROP">
      <summary>Unmanaged debugging is not available.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_DEBUGGING_NOT_POSSIBLE">
      <summary>Debugging isn't possible due to an incompatability within the CLR implementation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_KERNEL_DEBUGGER_ENABLED">
      <summary>Visual Studio cannot debug managed applications because a kernel debugger is enabled on the system. Please see Help for further information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_KERNEL_DEBUGGER_PRESENT">
      <summary>Visual Studio cannot debug managed applications because a kernel debugger is present on the system. Please see Help for further information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTEROP_NOT_SUPPORTED">
      <summary>The debugger does not support debugging managed and native code at the same time on the platform of the target computer/device. Configure the debugger to debug only native code, or only managed code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TOO_MANY_PROCESSES">
      <summary>The maximum number of processes is already being debugged.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_MSHTML_SCRIPT_DEBUGGING_DISABLED">
      <summary>Script debugging of your application is disabled in Internet Explorer. To enable script debugging in Internet Explorer, choose Internet Options from the Tools menu and navigate to the Advanced tab. Under the Browsing category, clear the 'Disable Script Debugging (Internet Explorer)' checkbox, then restart Internet Explorer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SCRIPT_PDM_NOT_REGISTERED">
      <summary>The correct version of pdm.dll is not registered. Repair your Visual Studio installation, or run 'regsvr32.exe "%CommonProgramFiles%\Microsoft Shared\VS7Debug\pdm.dll"'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DE_CLR_DBG_SERVICES_NOT_INSTALLED">
      <summary>The .NET debugger has not been installed properly. The most probable cause is that mscordbi.dll is not properly registered. Click Help for more information on how to repair the .NET debugger.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_NO_CLR_PROGRAMS">
      <summary>There is no managed code running in the process. In order to attach to a process with the .NET debugger, managed code must be running in the process before attaching.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_CLOSED">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor has been closed on the remote machine.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CLR_NOT_SUPPORTED">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor on the remote computer does not support debugging code running in the Common Language Runtime.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_64BIT_CLR_NOT_SUPPORTED">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor on the remote computer does not support debugging code running in the Common Language Runtime on a 64-bit computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_MIX_MINDUMP_DEBUGGING">
      <summary>Cannot debug minidumps and processes at the same time.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEBUG_ENGINE_NOT_REGISTERED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_SXS_ERROR">
      <summary>This application has failed to start because the application configuration is incorrect. Review the manifest file for possible errors. Reinstalling the application may fix this problem. For more details, please see the application event log.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FAILED_TO_INITIALIZE_SCRIPT_PROXY">
      <summary>Failed to initialize msdbg2.dll for script debugging. If this problem persists, use 'Add or Remove Programs' in Control Panel to repair your Visual Studio installation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_DOES_NOT_EXIST">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor (MSVSMON.EXE) does not appear to be running on the remote computer. This may be because a firewall is preventing communication to the remote computer. Please see Help for assistance on configuring remote debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_ACCESS_DENIED">
      <summary>Access is denied. Can not connect to Microsoft Visual Studio Remote Debugging Monitor on the remote computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_MACHINE_DOES_NOT_EXIST">
      <summary>The debugger cannot connect to the remote computer. The debugger was unable to resolve the specified computer name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEBUGGER_NOT_REGISTERED_PROPERLY">
      <summary>The debugger is not properly installed. Run setup to install or repair the debugger.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FORCE_GUEST_MODE_ENABLED">
      <summary>Access is denied. This seems to be because the 'Network access: Sharing and security model for local accounts' security policy does not allow users to authenticate as themselves. Please use the 'Local Security Settings' administration tool on the local computer to configure this option.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GET_IWAM_USER_FAILURE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_INVALID_NAME">
      <summary>The specified remote server name is not valid.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTO_LAUNCH_EXEC_FAILURE">
      <summary>Microsoft Visual Studio Debugging Monitor (MSVSMON.EXE) failed to start. If this problem persists, please repair your Visual Studio installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_COMPONENTS_NOT_REGISTERED">
      <summary>Microsoft Visual Studio Remote Debugging Monitor (MSVSMON.EXE) is not running under your user account and MSVSMON could not be automatically started. MSVSMON must be manually started, or the Visual Studio remote debugging components must be installed on the remote computer. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DCOM_ACCESS_DENIED">
      <summary>An unexpected DCOM error occurred trying to contact the remote computer. Access is denied.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SHARE_LEVEL_ACCESS_CONTROL_ENABLED">
      <summary>Debugging using the Default transport is not possible because the remote machine has 'Share-level access control' enabled. To enable debugging on the remote machine, go to Control Panel -&gt; Network -&gt; Access control, and set Access control to be 'User-level access control'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WORKGROUP_REMOTE_LOGON_FAILURE">
      <summary>Logon failure: unknown user name or bad password. See help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WINAUTH_CONNECT_NOT_SUPPORTED">
      <summary>Windows authentication is disabled in the Microsoft Visual Studio Remote Debugging Monitor (MSVSMON). To connect, choose one of the following options. 1. Enable Windows authentication in MSVSMON 2. Reconfigure your project to disable Windows authentication 3. Use the 'Remote (native with no authentication)' transport in the 'Attach to Process' dialog</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_EVALUATE_BUSY_WITH_EVALUATION">
      <summary>A previous expression evaluation is still in progress.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_EVALUATE_TIMEOUT">
      <summary>The expression evaluation took too long.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTEROP_CLR_TOO_OLD">
      <summary>Mixed-mode debugging does not support Microsoft.NET Framework versions earlier than 2.0.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CLR_INCOMPATIBLE_PROTOCOL">
      <summary>Check for one of the following. 1. The application you are trying to debug uses a version of the Microsoft .NET Framework that is not supported by the debugger. 2. The debugger has made an incorrect assumption about the Microsoft .NET Framework version your application is going to use. 3. The Microsoft .NET Framework version specified by you for debugging is incorrect. Please see the Visual Studio .NET debugger documentation for correctly specifying the Microsoft .NET Framework version your application is going to use for debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CLR_CANNOT_DEBUG_FIBER_PROCESS">
      <summary>Unable to attach because process is running in fiber mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_OBJECT_ACCESS_DENIED">
      <summary>Visual Studio has insufficient privileges to debug this process. To debug this process, Visual Studio must be run as an administrator.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_TOKEN_ACCESS_DENIED">
      <summary>Visual Studio has insufficient privileges to inspect the process's identity.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_TOKEN_ACCESS_DENIED_NO_TS">
      <summary>Visual Studio was unable to inspect the process's identity. This is most likely due to service configuration on the computer running the process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_OPERATION_REQUIRES_ELEVATION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_REQUIRES_ELEVATION">
      <summary>Visual Studio has insufficient privileges to debug this process. To debug this process, Visual Studio must be run as an administrator.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_MEMORY_NOTSUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DISASM_NOTSUPPORTED">
      <summary>The type of code you are currently debugging does not support disassembly.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DISASM_BADADDRESS">
      <summary>The specified address does not exist in disassembly.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DISASM_NOTAVAILABLE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_DELETED">
      <summary>The breakpoint has been deleted.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_DESTROYED">
      <summary>The process has been terminated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_DEBUGGER_IS_DEBUGGEE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TERMINATE_FORBIDDEN">
      <summary>Terminating this process is not allowed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_THREAD_DESTROYED">
      <summary>The thread has terminated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PORTSUPPLIER_NO_PORT">
      <summary>Cannot find port. Check the remote machine name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PORT_NO_REQUEST">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_COMPARE_CANNOT_COMPARE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_JIT_INVALID_PID">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_JIT_VSJITDEBUGGER_NOT_REGISTERED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_JIT_APPID_NOT_REGISTERED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_JIT_RUNTIME_VERSION_UNSUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SESSION_TERMINATE_DETACH_FAILED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SESSION_TERMINATE_FAILED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DETACH_NO_PROXY">
      <summary>Detach is not supported on Microsoft Windows 2000 for native code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DETACH_TS_UNSUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DETACH_IMPERSONATE_FAILURE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_ON_NONLEAF_FRAME">
      <summary>This thread has called into a function that cannot be displayed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TARGET_FILE_MISMATCH">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_IMAGE_NOT_LOADED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FIBER_NOT_SUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SETIP_TO_DIFFERENT_FUNCTION">
      <summary>The next statement cannot be set to another function.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_ON_EXCEPTION">
      <summary>In order to Set Next Statement, right-click on the active frame in the Call Stack window and select "Unwind To This Frame".</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ENC_SETIP_REQUIRES_CONTINUE">
      <summary>The next statement cannot be changed until the current statement has completed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_INTO_FINALLY">
      <summary>The next statement cannot be set from outside a finally block to within it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_OUT_OF_FINALLY">
      <summary>The next statement cannot be set from within a finally block to a statement outside of it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_INTO_CATCH">
      <summary>The next statement cannot be set from outside a catch block to within it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_GENERAL">
      <summary>The next statement cannot be changed at this time.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_SET_NEXT_STATEMENT_INTO_OR_OUT_OF_FILTER">
      <summary>The next statement cannot be set into or out of a catch filter.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ASYNCBREAK_NO_PROGRAMS">
      <summary>This process is not currently executing the type of code that you selected to debug.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ASYNCBREAK_DEBUGGEE_NOT_INITIALIZED">
      <summary>The debugger is still attaching to the process or the process is not currently executing the type of code selected for debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ASYNCBREAK_UNABLE_TO_PROCESS">
      <summary>The debugger is handling debug events or performing evaluations that do not allow nested break state. Try again.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WEBDBG_DEBUG_VERB_BLOCKED">
      <summary>The web server has been locked down and is blocking the DEBUG verb, which is required to enable debugging. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ASP_USER_ACCESS_DENIED">
      <summary>ASP debugging is disabled because the ASP process is running as a user that does not have debug permissions. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTO_ATTACH_NOT_REGISTERED">
      <summary>The remote debugging components are not registered or running on the web server. Ensure the proper version of msvsmon is running on the remote computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTO_ATTACH_DCOM_ERROR">
      <summary>An unexpected DCOM error occurred while trying to automatically attach to the remote web server. Try manually attaching to the remote web server using the 'Attach To Process' dialog.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTO_ATTACH_COCREATE_FAILURE">
      <summary>Expected failure from web server CoCreating debug verb CLSID</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTO_ATTACH_CLASSNOTREG">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_CONTINUE_DURING_PENDING_EXPR_EVAL">
      <summary>The current thread cannot continue while an expression is being evaluated on another thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_REDIRECTION_UNSUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_WORKING_DIRECTORY">
      <summary>The specified working directory does not exist or is not a full path.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_FAILED_WITH_ELEVATION">
      <summary>The application manifest has the uiAccess attribute set to 'true'. Running an Accessibility application requires following the steps described in Help.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_ELEVATION_REQUIRED">
      <summary>This program requires additional permissions to start. To debug this program, restart Visual Studio as an administrator.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_FIND_INTERNET_EXPLORER">
      <summary>Cannot locate Microsoft Internet Explorer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_PROCESS_OBJECT_ACCESS_DENIED">
      <summary>The Visual Studio Remote Debugger (MSVSMON.EXE) has insufficient privileges to debug this process. To debug this process, the remote debugger must be run as an administrator.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_ATTACH_REQUIRES_ELEVATION">
      <summary>The Visual Studio Remote Debugger (MSVSMON.EXE) has insufficient privileges to debug this process. To debug this process, launch the remote debugger using 'Run as administrator'. If the remote debugger has been configured to run as a service, ensure that it is running under an account that is a member of the Administrators group.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_LAUNCH_ELEVATION_REQUIRED">
      <summary>This program requires additional permissions to start. To debug this program, launch the Visual Studio Remote Debugger (MSVSMON.EXE) using 'Run as administrator'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_EXCEPTION_CANNOT_BE_INTERCEPTED">
      <summary>The attempt to unwind the callstack failed. Unwinding is not possible in the following scenarios: 1. Debugging was started via Just-In-Time debugging. 2. An unwind is in progress. 3. A System.StackOverflowException or System.Threading.ThreadAbortException exception has been thrown.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_EXCEPTION_CANNOT_UNWIND_ABOVE_CALLBACK">
      <summary>You can only unwind to the function that caused the exception.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTERCEPT_CURRENT_EXCEPTION_NOT_SUPPORTED">
      <summary>Unwinding from the current exception is not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTERCEPT_CANNOT_UNWIND_LASTCHANCE_INTEROP">
      <summary>You cannot unwind from an unhandled exception while doing managed and native code debugging at the same time.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_JMC_CANNOT_SET_STATUS">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DESTROYED">
      <summary>The process has been terminated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_NOMSVCMON">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor is either not running on the remote machine or is running in Windows authentication mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_BADIPADDRESS">
      <summary>The IP address for the remote machine is not valid.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_MACHINEDOWN">
      <summary>The remote machine is not responding.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_MACHINEUNSPECIFIED">
      <summary>The remote machine name is not specified.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CRASHDUMP_ACTIVE">
      <summary>Other programs cannot be debugged while debugging a dump file.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ALL_THREADS_SUSPENDED">
      <summary>All of the threads are frozen. Use the Threads window to unfreeze at least one thread before attempting to step or continue the process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_TL">
      <summary>The debugger transport DLL cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_SH">
      <summary>mspdb110.dll cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_EM">
      <summary>MSDIS170.dll cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_EE">
      <summary>NatDbgEE.dll cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_DM">
      <summary>NatDbgDM.dll cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_MD">
      <summary>Old version of DBGHELP.DLL found, does not support minidumps.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_IOREDIR_BADFILE">
      <summary>Input or output cannot be redirected because the specified file is invalid.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_IOREDIR_BADSYNTAX">
      <summary>Input or output cannot be redirected because the syntax is incorrect.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_BADVERSION">
      <summary>The remote debugger is not an acceptable version.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CRASHDUMP_UNSUPPORTED">
      <summary>This operation is not supported when debugging dump files.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_BAD_CLR_VERSION">
      <summary>The remote computer does not have a CLR version which is compatible with the remote debugging components. To install a compatible CLR version, see the instructions in the 'Remote Components Setup' page on the Visual Studio CD.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNSUPPORTED_BINARY">
      <summary>The specified file is an unrecognized or unsupported binary format.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEBUGGEE_BLOCKED">
      <summary>The process has been soft broken.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_NOUSERMSVCMON">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor on the remote computer is running as a different user.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_STEP_WIN9xSYSCODE">
      <summary>Stepping to or from system code on a machine running Windows 95/Windows 98/Windows ME is not allowed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTEROP_ORPC_INIT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_DEBUG_WIN32">
      <summary>The 64-bit version of the Visual Studio Remote Debugging Monitor (MSVSMON.EXE) cannot be used to debug 32-bit processes or 32-bit dumps. Please use the 32-bit version instead.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_DEBUG_WIN64">
      <summary>The 32-bit version of the Visual Studio Remote Debugging Monitor (MSVSMON.EXE) cannot be used to debug 64-bit processes or 64-bit dumps. Please use the 64-bit version instead.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_MINIDUMP_READ_WIN9X">
      <summary>Mini-Dumps cannot be read on this system. Please use a Windows NT based system</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CROSS_TSSESSION_ATTACH">
      <summary>Attaching to a process in a different terminal server session is not supported on this computer. Try remote debugging to the machine and running the Microsoft Visual Studio Remote Debugging Monitor in the process's session.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_STEP_BP_SET_FAILED">
      <summary>A stepping breakpoint could not be set</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_TL_INCORRECT_VERSION">
      <summary>The debugger transport DLL being loaded has an incorrect version.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_DM_INCORRECT_VERSION">
      <summary>NatDbgDM.dll being loaded has an incorrect version.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_NOMSVCMON_PIPE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_DLL_DIA">
      <summary>msdia110.dll cannot be loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DUMP_CORRUPTED">
      <summary>The dump file you opened is corrupted.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTEROP_X64">
      <summary>Mixed-mode debugging of x64 processes is not supported when using Microsoft.NET Framework versions earlier than 4.0.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CRASHDUMP_DEPRECATED">
      <summary>Debugging older format crashdumps is not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_MANAGEDONLYMINIDUMP_UNSUPPORTED">
      <summary>Debugging managed-only minidumps is not supported. Specify 'Mixed' for the 'Debugger Type' in project properties.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LAUNCH_64BIT_MANAGEDMINIDUMP_UNSUPPORTED">
      <summary>Debugging managed or mixed-mode minidumps is not supported on IA64 platforms. Specify 'Native' for the 'Debugger Type' in project properties.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEVICEBITS_NOT_SIGNED">
      <summary>The remote tools are not signed correctly.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_NOT_ENABLED">
      <summary>Attach is not enabled for this process with this debug type.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_DISCONNECT">
      <summary>The connection has been broken.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BREAK_ALL_FAILED">
      <summary>The threads in the process cannot be suspended at this time. This may be a temporary condition.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEVICE_ACCESS_DENIED_SELECT_YES">
      <summary>Access denied. Try again, then check your device for a prompt.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEVICE_ACCESS_DENIED">
      <summary>Unable to complete the operation. This could be because the device's security settings are too restrictive. Please use the Device Security Manager to change the settings and try again.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEVICE_CONNRESET">
      <summary>The remote connection to the device has been lost. Verify the device connection and restart debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BAD_NETCF_VERSION">
      <summary>Unable to load the CLR. The target device does not have a compatible version of the CLR installed for the application you are attempting to debug. Verify that your device supports the appropriate CLR version and has that CLR installed. Some devices do not support automatic CLR upgrade.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REFERENCE_NOT_VALID">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROPERTY_NOT_VALID">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SETVALUE_VALUE_CANNOT_BE_SET">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SETVALUE_VALUE_IS_READONLY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SETVALUEASREFERENCE_NOTSUPPORTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_GET_UNMANAGED_MEMORY_CONTEXT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GETREFERENCE_NO_REFERENCE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CODE_CONTEXT_OUT_OF_SCOPE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_SESSIONID">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SERVER_UNAVAILABLE_ON_CALLBACK">
      <summary>The Visual Studio Remote Debugger on the target computer cannot connect back to this computer. A firewall may be preventing communication via DCOM to the local computer. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ACCESS_DENIED_ON_CALLBACK">
      <summary>The Visual Studio Remote Debugger on the target computer cannot connect back to this computer. Authentication failed. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNKNOWN_AUTHN_SERVICE_ON_CALLBACK">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor on the remote computer could not connect to this computer because there was no available authentication service.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_NO_SESSION_AVAILABLE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CLIENT_NOT_LOGGED_ON">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_OTHER_USERS_SESSION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_USER_LEVEL_ACCESS_CONTROL_REQUIRED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SCRIPT_CLR_EE_DISABLED">
      <summary>Can not evaluate script expressions while thread is stopped in the CLR.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_SERVERERROR">
      <summary>Server side-error occurred on sending debug HTTP request.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_UNAUTHORIZED">
      <summary>An authentication error occurred while communicating with the web server. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_SENDREQUEST_FAILED">
      <summary>Could not start ASP.NET debugging. More information may be available by starting the project without debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_FORBIDDEN">
      <summary>The web server is not configured correctly. See help for common configuration errors. Running the web page outside of the debugger may provide further information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_NOT_SUPPORTED">
      <summary>The server does not support debugging of ASP.NET or ATL Server applications. Click Help for more information on how to enable debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_NO_CONTENT">
      <summary>Could not start ASP.NET or ATL Server debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_NOT_FOUND">
      <summary>The web server could not find the requested resource.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_BAD_REQUEST">
      <summary>The debug request could not be processed by the server due to invalid syntax.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_ACCESS_DENIED">
      <summary>You do not have permissions to debug the web server process. You need to either be running as the same user account as the web server, or have administrator privilege.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_CONNECT_FAILED">
      <summary>Unable to connect to the web server. Verify that the web server is running and that incoming HTTP requests are not blocked by a firewall.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_EXCEPTION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_TIMEOUT">
      <summary>The web server did not respond in a timely manner. This may be because another debugger is already attached to the web server.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_SITE_NOT_FOUND">
      <summary>IIS does not list a web site that matches the launched URL.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_APP_NOT_FOUND">
      <summary>IIS does not list an application that matches the launched URL.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_MANAGEMENT_API_MISSING">
      <summary>Debugging requires the IIS Management Console. To install, go to Control Panel-&gt;Programs-&gt;Turn Windows features on or off. Check Internet Information Services-&gt;Web Management Tools-&gt;IIS Management Console.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_NO_PROCESS">
      <summary>The IIS worker process for the launched URL is not currently running.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_64BIT_COMPONENTS_NOT_INSTALLED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNMARSHAL_SERVER_FAILED">
      <summary>The Visual Studio debugger cannot connect to the remote computer. Unable to initiate DCOM communication. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNMARSHAL_CALLBACK_FAILED">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor on the remote computer cannot connect to the local computer. Unable to initiate DCOM communication. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_RPC_REQUIRES_AUTHENTICATION">
      <summary>The Visual Studio debugger cannot connect to the remote computer. An RPC policy is enabled on the local computer which prevents remote debugging. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOGON_FAILURE_ON_CALLBACK">
      <summary>The Microsoft Visual Studio Remote Debugging Monitor cannot logon to the local computer: unknown user name or bad password. Click help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_SERVER_UNAVAILABLE">
      <summary>The Visual Studio debugger cannot establish a DCOM connection to the remote computer. A firewall may be preventing communication via DCOM to the remote computer. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_CONNECT_USER_CANCELED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_CREDENTIALS_PROHIBITED">
      <summary>Windows file sharing has been configured so that you will connect to the remote computer using a different user name. This is incompatible with remote debugging. Please see Help for assistance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FIREWALL_NO_EXCEPTIONS">
      <summary>Windows Firewall does not currently allow exceptions. Use Control Panel to change the Windows Firewall settings so that exceptions are allowed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FIREWALL_CANNOT_OPEN_APPLICATION">
      <summary>Cannot add an application to the Windows Firewall exception list. Use the Control Panel to manually configure the Windows Firewall.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FIREWALL_CANNOT_OPEN_PORT">
      <summary>Cannot add a port to the Windows Firewall exception list. Use the Control Panel to manually configure the Windows Firewall.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FIREWALL_CANNOT_OPEN_FILE_SHARING">
      <summary>Cannot add 'File and Printer Sharing' to the Windows Firewall exception list. Use the Control Panel to manually configure the Windows Firewall.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_DEBUGGING_UNSUPPORTED">
      <summary>Remote debugging is not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_BAD_MSDBG2">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_USER_CANCELED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_PACKET_TOO_BIG">
      <summary>Maximum packet length exceeded. If the problem continues, reduce the number of network host names or network addresses that are assigned to the computer running Visual Studio computer or to the target computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNSUPPORTED_FUTURE_CLR_VERSION">
      <summary>The target process is running a version of the Microsoft .NET Framework newer than this version of Visual Studio. Visual Studio cannot debug this process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNSUPPORTED_CLR_V1">
      <summary>This version of Visual Studio does not support debugging code that uses Microsoft .NET Framework v1.0. Use Visual Studio 2008 or earlier to debug this process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INTEROP_IA64">
      <summary>Mixed-mode debugging of IA64 processes is not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_HTTP_GENERAL">
      <summary>See help for common configuration errors. Running the web page outside of the debugger may provide further information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_NO_CONNECTION">
      <summary>IDebugCoreServer* implementation does not have a connection to the remote computer. This can occur in T-SQL debugging when there is no remote debugging monitor.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_INVALID_PROXY_SERVER_NAME">
      <summary>The specified remote debugging proxy server name is invalid.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_WEAK_CONNECTION">
      <summary>Operation is not permitted on IDebugCoreServer* implementation which has a weak connection to the remote msvsmon instance. Weak connections are used when no process is being debugged.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_PROGRAM_PROVIDERS_UNSUPPORTED">
      <summary>Remote program providers are no longer supported before debugging begins (ex: process enumeration).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_REJECTED_NO_AUTH_REQUEST">
      <summary>Connection request was rejected by the remote debugger. Ensure that the remote debugger is running in 'No Authentication' mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_REJECTED_WIN_AUTH_REQUEST">
      <summary>Connection request was rejected by the remote debugger. Ensure that the remote debugger is running in 'Windows Authentication' mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PSEUDOREMOTE_NO_LOCALHOST_TCPIP_CONNECTION">
      <summary>The debugger was unable to create a localhost TCP/IP connection, which is required for 64-bit debugging.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_WWS_NOT_INSTALLED">
      <summary>This operation requires the Windows Web Services API to be installed, and it is not currently installed on this computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_WWS_INSTALL_REQUIRES_ADMIN">
      <summary>This operation requires the Windows Web Services API to be installed, and it is not currently installed on this computer. To install Windows Web Services, please restart Visual Studio as an administrator on this computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_FUNCTION_NOT_JITTED">
      <summary>The expression has not yet been translated to native machine code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_NO_CODE_CONTEXT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BAD_CLR_DIASYMREADER">
      <summary>A Microsoft .NET Framework component, diasymreader.dll, is not correctly installed. Please repair your Microsoft .NET Framework installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CLR_SHIM_ERROR">
      <summary>Unable to load the CLR. If a CLR version was specified for debugging, check that it was valid and installed on the machine. If the problem persists, please repair your Microsoft .NET Framework installation via 'Programs and Features' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_AUTOATTACH_WEBSERVER_NOT_FOUND">
      <summary>Unable to map the debug start page URL to a machine name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DBGEXTENSION_NOT_FOUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DBGEXTENSION_FUNCTION_NOT_FOUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DBGEXTENSION_FAULTED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DBGEXTENSION_RESULT_INVALID">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROGRAM_IN_RUNMODE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_NO_SERVER_RESPONSE">
      <summary>The remote procedure could not be debugged. This usually indicates that debugging has not been enabled on the server. See help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_REMOTE_NOT_REGISTERED">
      <summary>Please install the Visual Studio Remote Debugger on the server to enable this functionality.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_BREAKPOINT_NOT_HIT">
      <summary>The debugger failed to stop in the server process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_BREAKPOINT_BIND_ERROR">
      <summary>Unable to determine a stopping location. Verify symbols are loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_PROJECT_DISABLED">
      <summary>Debugging this project is disabled. Debugging can be re-enabled from 'Start Options' under project properties.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_NO_ATTACH_WHILE_DDD">
      <summary>Unable to attach the debugger to TSQL code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQLLE_ACCESSDENIED">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_SP_ENABLE_PERMISSION_DENIED">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_DEBUGGING_NOT_ENABLED_ON_SERVER">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_CANT_FIND_SSDEBUGPS_ON_CLIENT">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_EXECUTED_BUT_NOT_DEBUGGED">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_VDT_INIT_RETURNED_SQL_ERROR">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_ATTACH_FAILED_ABORT_SILENTLY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SQL_REGISTER_FAILED">
      <summary>Click Help for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DE_NOT_SUPPORTED_PRE_8_0">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROGRAM_DESTROY_PENDING">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_MANAGED_FEATURE_NOTSUPPORTED">
      <summary>The operation isn't supported for the Common Language Runtime version used by the process being debugged.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_OS_PERSONAL">
      <summary>The Visual Studio Remote Debugger does not support this edition of Windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SOURCE_SERVER_DISABLE_PARTIAL_TRUST">
      <summary>Source server support is disabled because the assembly is partially trusted.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_UNSUPPORTED_OPERATION_ON_PLATFORM">
      <summary>Operation is not supported on the platform of the target computer/device.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_VSDEBUGENG_FAILED">
      <summary>Unable to load Visual Studio debugger component (vsdebugeng.dll). If this problem persists, repair your installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_VSDEBUGENG_IMPORTS_FAILED">
      <summary>Unable to initialize Visual Studio debugger component (vsdebugeng.dll). If this problem persists, repair your installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_VSDEBUGENG_CONFIG_ERROR">
      <summary>Unable to initialize Visual Studio debugger due to a configuration error. If this problem persists, repair your installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CORRUPT_MINIDUMP">
      <summary>Failed to launch minidump. The minidump file is corrupt.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_SCRIPT_AGENT_LOCAL_FAILURE">
      <summary>Unable to load a Visual Studio component (VSDebugScriptAgent.dll). If the problem persists, repair your installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_LOAD_SCRIPT_AGENT_REMOTE_FAILURE">
      <summary>Remote script debugging requires that the remote debugger is registered on the target computer. Run the Visual Studio Remote Debugger setup (rdbgsetup_&lt;processor&gt;.exe) on the target computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_APPX_REGISTRATION_NOT_FOUND">
      <summary>The debugger was unable to find the registration for the target application. If the problem persists, try uninstalling and then reinstalling this application.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_VSDEBUGLAUNCHNOTIFY_NOT_INSTALLED">
      <summary>Unable to find a Visual Studio component (VsDebugLaunchNotify.exe). For remote debugging, this file must be present on the target computer. If the problem persists, repair your installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WIN8_TOO_OLD">
      <summary>Windows 8 build# 8017 or higher is required to debug Windows apps.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_THREAD_NOT_FOUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_AUTOATTACH_TO_SQLSERVER">
      <summary>Cannot autoattach to the SQL Server, possibly because the firewall is configured incorrectly or autoattach is forbidden by the operating system.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_OBJECT_OUT_OF_SYNC">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_PROCESS_ALREADY_CONTINUED">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_DEBUG_MULTI_GPU_PROCS">
      <summary>Debugging multiple GPU processes is not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_ADAPTOR_NOT_FOUND">
      <summary>No available devices supported by the selected debug engine. Please select a different engine.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WINDOWS_GRAPHICAL_SHELL_UNINSTALLED_ERROR">
      <summary>A Microsoft Window component is not correctly registered. Please ensure that the Desktop Experience is enabled in Server Manager -&gt; Manage -&gt; Add Server Roles and Features.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_DEBUG_NOT_SUPPORTED_PRE_DX_11_1">
      <summary>Windows 8 or higher was required for GPU debugging on the software emulator. For the most up-to-date information, please visit the link below. http://go.microsoft.com/fwlink/?LinkId=236077</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_DEBUG_CONFIG_ISSUE">
      <summary>There is a configuration issue with the selected Debugging Accelerator Type. For information on specific Accelerator providers, visit http://go.microsoft.com/fwlink/?LinkId=242731</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_LOCAL_DEBUGGING_ERROR">
      <summary>Local debugging is not supported for the selected Debugging Accelerator Type. Use Remote Windows Debugger instead or change the Debugging Accelerator Type</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_LOAD_VSD3D_FAILURE">
      <summary>The debug driver for the selected Debugging Accelerator Type is not installed on the target machine. For more information, visit http://go.microsoft.com/fwlink/?LinkId=242731</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_TDR_ENABLED_FAILURE">
      <summary>Timeout Detection and Recovery (TDR) must be disabled at the remote site. For more information search for 'TdrLevel' in MSDN or visit the link below. http://go.microsoft.com/fwlink/?LinkId=242731</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_REMOTE_DEBUG_MIXED">
      <summary>Remote debugger does not support mixed (managed and native) debugger type.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BG_TASK_ACTIVATION_FAILED">
      <summary>Background Task activation failed Please see Help for further information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SYMBOLS_NOT_LOADED">
      <summary>Symbols are not loaded for the target dll.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SYMBOLS_STRIPPED">
      <summary>Symbols for the target dll do not contain source information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_INVALID_ADDRESS">
      <summary>Breakpoint could not be written at the specified instruction address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_IN_OPTIMIZED_CODE">
      <summary>Breakpoints cannot be set in optimized code when the debugger option 'Just My Code' is enabled.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_CLR_ERROR">
      <summary>The Common Language Runtime was unable to set the breakpoint.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_CLR_EXTERN_FUNCTION">
      <summary>Cannot set breakpoints in .NET Framework methods which are implemented in native code (ex: 'extern' function).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_BP_MODULE_UNLOADED">
      <summary>Cannot set breakpoint, target module is currently unloaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_STOPPING_EVENT_REJECTED">
      <summary>Stopping events cannot be sent. See stopping event processing documentation for more information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TARGET_ALREADY_STOPPED">
      <summary>This operation is not permitted because the target process is already stopped.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TARGET_NOT_STOPPED">
      <summary>This operation is not permitted because the target process is not stopped.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WRONG_THREAD">
      <summary>This operation is not allowed on this thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WRONG_TIME">
      <summary>This operation is not allowed at this time.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WRONG_COMPONENT">
      <summary>The caller is not allowed to request this operation. This operation must be requested by a different component.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WRONG_METHOD_VERSION">
      <summary>Operation is only permitted on the latest version of an editted method.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_MEMORY_ADDRESS">
      <summary>A memory read or write operation failed because the specified memory address is not currently valid.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INSTRUCTION_NO_SOURCE">
      <summary>No source information is available for this instruction.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_VSDEBUGENG_RESOURCE_LOAD_FAILURE">
      <summary>Failed to load localizable resource from vsdebugeng.impl.resources.dll. If this problem persists, please repair your Visual Studio installation via 'Add or Remove Programs' in Control Panel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNMARSHALLABLE_VARIANT">
      <summary>DkmVariant is of a form that marshalling is not supported. Marshalling is supported for primitives types, strings, and safe arrays of primitives.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_VSDEBUGENG_DEPLOYMENT_ERROR">
      <summary>An incorrect version of vsdebugeng.dll was loaded into Visual Studio. Please repair your Visual Studio installation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WEBSERVICES_LOAD_FAILURE">
      <summary>The remote debugger was unable to initialize Microsoft Windows Web Services (webservices.dll). If the problem continues, try reinstalling the Windows Web Services redistributable. This redistributable can be found under the 'Remote Debugger\Common Resources\Windows Updates' folder.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GLOBAL_INTERFACE_POINTER_FAILURE">
      <summary>Visual Studio encountered an error while loading a Windows component (Global Interface Table). If the problem persists, this may be an indication of operating system corruption, and Windows may need to be reinstalled.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REMOTE_AUTHENTICATION_ERROR">
      <summary>Windows authentication was unable to establish a secure connection to the remote computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_FIND_REMOTE_RESOURCES">
      <summary>The Remote Debugger was unable to locate a resource dll (vsdebugeng.impl.resources.dll). Please ensure that the complete remote debugger folder was copied or installed on the target computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_DATABP_SIZE">
      <summary>The hardware does not support monitoring the requested number of bytes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_DATABP_ALLREGSUSED">
      <summary>The maximum number of data breakpoints have already been set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DUMPS_DO_NOT_SUPPORT_BREAKPOINTS">
      <summary>Breakpoints cannot be set while debugging a minidump.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DUMP_ARM_ARCHITECTURE">
      <summary>The minidump is from an ARM-based computer and can only be debugged on an ARM computer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DUMP_UNKNOWN_ARCHITECTURE">
      <summary>The minidump is from an unknown processor, and cannot be debugged with this version of Visual Studio.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_NO_CHECKSUM">
      <summary>The shell failed to find a checksum for this file.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CONTEXT_CONTROL_REQUIRED">
      <summary>On x64, context control must be included in a SetThreadContext</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_REGISTER_SIZE">
      <summary>The size of the buffer does not match the size of the register.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REGISTER_NOT_FOUND">
      <summary>The requested register was not found in the stack frame's unwound register collection.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REGISTER_READONLY">
      <summary>Cannot set a read-only register.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_REG_NOT_TOP_STACK">
      <summary>Cannot set a register in a frame that is not the top of the stack.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_STRING_TOO_LONG">
      <summary>String could not be read within the specified maximum number of characters.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_MEMORY_PROTECT">
      <summary>The memory region does not meet the requested protection flags.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_UNKNOWN_CPU_INSTRUCTION">
      <summary>Instruction is invalid or unknown to the disassembler.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_RUNTIME">
      <summary>An invliad runtime was specified for this operation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_VARIABLE_OPTIMIZED_AWAY">
      <summary>Variable is optimized away.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_TEXT_SPAN_NOT_LOADED">
      <summary>The text span is not currently loaded in the specified script document.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SCRIPT_SPAN_MAPPING_FAILED">
      <summary>This location could not be mapped to client side script.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEPLOY_FILE_TOO_LARGE">
      <summary>The file requested must be less than 100 megabytes in size</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEPLOY_FILE_PATH_INVALID">
      <summary>The file path requested could not be written to as it is invalid. Ensure the path does not contain a file where a directory is expected.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SCRIPT_DEBUGGING_DISABLED_WWAHOST_ATTACH_FAILED">
      <summary>Script debugging is not enabled for WWAHost.exe.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEPLOY_FILE_NOT_EXIST">
      <summary>The file path requested for deletion does not exist.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_EXECUTE_COMMAND_IN_PROGRESS">
      <summary>A command is already executing, only one may execute at a time. Please wait for the executable to exit, or abort the command.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_INVALID_FULL_PATH">
      <summary>The specified file path is a relative or unknown path format. File paths must be fully qualified.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_DEBUG_APP_PACKAGE_IN_RDBSERVICE">
      <summary>Windows apps debugging is not possible when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugging Monitor application.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CANNOT_LAUNCH_IN_RDBSERVICE">
      <summary>Applications cannot be launched under the debugger when the remote debugger is running as a service. Run the Remote Debugger Configuration Wizard on the target computer, and uncheck the option to start the remote debugger service. Then start the Visual Studio Remote Debugging Monitor application.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_CAUSALITY_BRIDGE_ALREADY_INITIALIZED">
      <summary>The AD7 AL Causality bridge has already been initialized.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_DEPLOY_APPX_SHUTDOWN_WRONG_TIME">
      <summary>AppX packages may only be shutdown as part of a Visual Studio build operation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_WINDOWS_REG_ERROR">
      <summary>A Microsoft Window component is not correctly registered. If the problem persists, try repairing your Windows installation, or reinstalling Windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_APP_PACKAGE_NEVER_SUSPENDED">
      <summary>The application never reached a suspended state.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_SCRIPT_FILE_DIFFERENT_CONTENT">
      <summary>A different version of this script file has been loaded by the debugged process. The script file may need to be reloaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_NO_FRAME">
      <summary>No stack frame was found.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_GPU_BARRIER_BREAKPOINT_NOT_SUPPORTED">
      <summary>The selected accelerator does not support the run current tile to cursor operation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_COMPONENT_LOAD_FAILURE">
      <summary>A component dll failed to load. Try to restart this application. If failures continue, try disabling any installed add-ins or repair your installation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_NOT_INITIALIZED">
      <summary>Xapi has not been initialized on this thread. Call ComponentManager.InitializeThread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_ALREADY_INITIALIZED">
      <summary>Xapi has already been initialized on this thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_THREAD_ABORTED">
      <summary>Xapi event thread aborted unexpectedly.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_BAD_QUERY_INTERFACE">
      <summary>Component failed a call to QueryInterface. QueryInterface implementation or component configuration is incorrect.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_UNAVAILABLE_OBJECT">
      <summary>Object requested which is not available at the caller's component level.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_BAD_CONFIG">
      <summary>Failed to process configuration file. Try to restart this application. If failures continue, try to repair your installation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_MANAGED_DISPATCHER_CONNECT_FAILURE">
      <summary>Failed to initialize managed/native marshalling system. Try to restart this application. If failures continue, try to repair your installation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_DURING_CREATE_EVENT_REQUIRED">
      <summary>This operation may only be preformed while processing the object's 'Create' event.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_CREATOR_REQUIRED">
      <summary>This operation may only be preformed by the component which created the object.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_WORK_LIST_COMPLETE">
      <summary>The work item cannot be appended to the work list because it is already complete.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_WORKLIST_ALREADY_STARTED">
      <summary>'Execute' may not be called on a work list which has already started.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_COMPLETION_ROUTINE_RELEASED">
      <summary>The interface implementation released the completion routine without calling it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_WRONG_THREAD">
      <summary>Operation is not supported on this thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_COMPONENTID_NOT_FOUND">
      <summary>No component with the given component id could be found in the configuration store.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_WRONG_CONNECTION_OBJECT">
      <summary>Call was attempted to a remote connection from a server-side component (component level &gt; 100000). This is not allowed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_METHOD_NOT_REMOTED">
      <summary>Destination of this call is on a remote connection and this method doesn't support remoting.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_REMOTE_DISCONNECTED">
      <summary>The network connection to the Visual Studio Remote Debugger was lost.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_REMOTE_CLOSED">
      <summary>The network connection to the Visual Studio Remote Debugger has been closed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_INCOMPATIBLE_PROTOCOL">
      <summary>A protocol compatibility error occurred between Visual Studio and the Remote Debugger. Please ensure that the Visual Studio and Remote debugger versions match.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_MAX_PACKET_EXCEEDED">
      <summary>Maximum allocation size exceeded while processing a remoting message.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_OBJECT_ALREADY_EXISTS">
      <summary>An object already exists with the same key value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_OBJECT_NOT_FOUND">
      <summary>An object cannot be found with the given key value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_DATA_ITEM_ALREADY_EXISTS">
      <summary>A data item already exists with the same key value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_DATA_ITEM_NOT_FOUND">
      <summary>A data item cannot be for this component found with the given data item ID.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_NULL_OUT_PARAM">
      <summary>Interface implementation failed to provide a required out param.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_MANAGED_DISPATCHER_SIGNATURE_ERROR">
      <summary>Strong name signature validation error while trying to load the managed dispatcher</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_CLIENT_ONLY_METHOD">
      <summary>Method may only be called by components which load in the IDE process (copmonent level &gt; 100000).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_SERVER_ONLY_METHOD">
      <summary>Method may only be called by components which load in the remote debugger process (copmonent level &lt; 100000).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmExceptionCode.E_XAPI_COMPONENT_DLL_NOT_FOUND">
      <summary>A component dll could not be found. If failures continue, try disabling any installed add-ins or repairing your installation.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmFuncEvalMode">
      <summary>Indicates whether there is a function evaluation occurring in the target process and whether stopping events are allowed for this evaluation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmFuncEvalMode.NotEvaluating">
      <summary>No function evaluation is currently in progress.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmFuncEvalMode.EvaluatingWithoutStoppingEvents">
      <summary>A function evaluation is currently in progress. No stopping events are permitted on the queried thread. Therefore, stopping events will be suppressed after the 'received' phase of stopping event processing. This value is used when (1) the function evaluation was started without the DkmFuncEvalFlags.AllowStoppingEvents flag or (2) the queried thread is not the evaluating thread and DkmFuncEvalFlags.RunAllThreads was not used.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmFuncEvalMode.EvaluatingWithStoppingEvents">
      <summary>A function evaluation is currently in progress. Stopping events are permitted on the queried thread. Therefore, if the queried thread hits a breakpoint, the debugger might enter nested break state.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult">
      <summary>Result of an asynchronous DkmInstructionAddress.GetCurrentCPUAddress call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult.#ctor(System.UInt64[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionAddress.GetCurrentCPUAddress.</summary>
      <param name="InstructionPointers">[In] An array of the current CPU Instruction Addresses that map to this DkmInstructionAddress.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionAddress.GetCurrentCPUAddress.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult" />.</returns>
      <param name="exception">[In] Exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult.InstructionPointers">
      <summary>An array of the current CPU Instruction Addresses that map to this DkmInstructionAddress.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult">
      <summary>Result of an asynchronous DkmProcess.GetInstructionAddress call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmProcess.GetInstructionAddress.</summary>
      <param name="AddressObject">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="FirstAddress">[In] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult.AddressObject">
      <summary>Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmProcess.GetInstructionAddress.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult.FirstAddress">
      <summary>True if this address is the first address in the line's range. False otherwise.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmGlobalSettings">
      <summary>Static class that contains settings which are global to the debugger process</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGlobalSettings.Culture">
      <summary>Culture used by Visual Studio. This can be used to load resource dlls, format strings, and so on</summary>
      <returns>Returns <see cref="T:System.Globalization.CultureInfo" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmGlobalSettings.RegistryRoot">
      <summary>[Optional] Visual Studio registry root (ex: Software\Microsoft\VisualStudio\10.0). Registry root is null in remote debugging scenarios. It will be non-null in pseudo-remote, and local debugging scenarios.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress">
      <summary>Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance. Derived classes: DkmClrInstructionAddress, DkmCustomInstructionAddress, DkmNativeInstructionAddress, DkmScriptInstructionAddress, DkmUnknownInstructionAddress</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CompareTo(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Compares two instruction addresses and returns a value indicating whether one is less than, equal to, or greater than the other. The addresses must be from the same module.</summary>
      <returns>[Out] A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Less than zero: This instance is less than 'other'. Zero: This instance is equal to 'other'. Greater than zero: This instance is greater than 'other'.</returns>
      <param name="Other">[In] An address to compare with this address.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstructionPart">
      <summary>[Optional] CPUInstructionPart provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.GetCurrentCPUAddress">
      <summary>Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse mapping of ResolveCPUInstructionAddress. This API is currently only supported by CLR DkmRuntimeInstance objects.</summary>
      <returns>[Out] An array of the current CPU Instruction Addresses that map to this DkmInstructionAddress.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.GetCurrentCPUAddress(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DkmGetCurrentCPUAddressAsyncResult})">
      <summary>Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse mapping of ResolveCPUInstructionAddress. This API is currently only supported by CLR DkmRuntimeInstance objects. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.GetSymbol">
      <summary>Convert a DkmInstructionAddress into a DkmInstructionSymbol. If the DkmInstructionAddress is not in a DkmModule then GetSymbol will return null (S_FALSE in native code).</summary>
      <returns>[Out,Optional] DkmInstructionSymbol represents a method in the target process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.IsInSameFunction(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Compares two instruction addresses and determines whether they are in the same function. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] True if the two addresses are from the same function.</returns>
      <param name="Other">[In] An address to compare with this address.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.ModuleInstance">
      <summary>[Optional] The module that contains this address. Addresses without a module cannot have symbols (even for custom addresses). CLR addresses will always have a module. Native addresses will not have a module if either the CPU jumped to an invalid address (ex: NULL), or if the CPU is executing dynamically-emitted code.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.TagValue">
      <summary>DkmInstructionAddress is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction">
      <summary>CPUInstruction provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction.#ctor(System.UInt64)">
      <summary>Initializes a new CPUInstruction value.</summary>
      <param name="InstructionPointer">[In] The address of where the CPU instruction is located in the target process.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction.InstructionPointer">
      <summary>The address of where the CPU instruction is located in the target process.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag">
      <summary>DkmInstructionAddress is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag.NativeAddress">
      <summary>Object is an instance of 'DkmNativeInstructionAddress'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag.ClrAddress">
      <summary>Object is an instance of 'DkmClrInstructionAddress'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag.ScriptAddress">
      <summary>Object is an instance of 'DkmScriptInstructionAddress'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag.CustomAddress">
      <summary>Object is an instance of 'DkmCustomInstructionAddress'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmInstructionAddress.Tag.UnknownAddress">
      <summary>Object is an instance of 'DkmUnknownInstructionAddress'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting">
      <summary>Pairing between the name of a setting and its value.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting.Create(System.String,System.Object)">
      <summary>Creates a new DkmLanguageRegistrySetting object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] The name of the setting.</param>
      <param name="Value">[In] The value of the setting. This can be either a DWORD or a string.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting.Name">
      <summary>The name of the setting.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting.Value">
      <summary>The value of the setting. This can be either a DWORD or a string.</summary>
      <returns>Returns <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleFlags">
      <summary>Flags which indicate traits of a DkmModuleInstance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.None">
      <summary>No module flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.FileBacked">
      <summary>Module is backed by a file. Note that this is set even when the module could not be resolved (dll is missing, binary could not be found when examining a minidump, etc).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.FileResolved">
      <summary>Module is backed by a file and the debug monitor was able to open this file.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.MissingBinary">
      <summary>Neither the module's file or memory content could be found. Debugging will be affected.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.Relocated">
      <summary>Module was relocated because it could not load at its preferred base address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.Optimized">
      <summary>Optimization status for the module could be detected and the module was determined to be optimized.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleFlags.Unoptimized">
      <summary>Optimization status for the module could be detected and the module was determined to be unoptimized.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance">
      <summary>The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address. Derived classes: DkmClrModuleInstance, DkmCustomModuleInstance, DkmNativeModuleInstance</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.BaseAddress">
      <summary>[Optional] The starting memory address of where the module loaded. This value will be zero if the module did not load in a contiguous block of memory.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.ClearTransitionModuleFlag"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Connection">
      <summary>Represents a connection between the monitor and the IDE. It can be a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.FlagAsTransitionModule"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Flags">
      <summary>Flags that indicate traits of a DkmModuleInstance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.FullName">
      <summary>Fully qualified module name. For file-based modules, this is the full path of the module (ex: c:\windows\system32\kernel32.dll).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.GetGPUDisassembly(System.UInt64,System.UInt32,System.Boolean,System.Boolean@)">
      <summary>Obtains the disassembly of the address range in the debuggee module instance.</summary>
      <returns>[Out] The results of disassembly read from the debuggee byte code.</returns>
      <param name="Address">[In] The address where disassembly should start.</param>
      <param name="Count">[In] The number of instructions to disassemble.</param>
      <param name="IsForward">[In] True if this is forward disassembling. Otherwise, this is reverse disassembling.</param>
      <param name="IsEnd">[Out] True if the disassembly has reached the end of byte code; false otherwise.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.GetGPUDisassemblySize">
      <summary>Returns the disassembly size in the debuggee module instance.</summary>
      <returns>[Out] The disassembly size.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.GetNextGPUInstructionAddress(System.UInt64)">
      <summary>Returns the address of the next instruction relative to a starting address.</summary>
      <returns>[Out] The address of the next instruction from StartAddress.</returns>
      <param name="StartAddress">[In] The address of the current instruction.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.GetSymbolLoadInformation">
      <summary>Returns a string that describes the various locations in which symbols were searched for, and the result of checking that location. This information is used to populate the 'Symbol Load Information' in the Modules window. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] String that contains information about the symbol search. The typical format is 'location1:result1\r\nlocation2:result2...'.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.GetSymbolStatusMessage(System.Boolean)">
      <summary>Obtains a localized a string description of the current symbol status. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Localized status string (ex: 'Symbols Loaded', 'No symbols loaded', etc.).</returns>
      <param name="ExcludeCommonErrors">[In] This value will be true for creating the initial load output message, and false for obtaining the output window text.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.IsDisabled">
      <summary>Indicates whether this module instance has been disabled. Disabled modules are largely ignored by the debugger. For native modules, the address range of the disabled module is treated as if it were unmapped. For CLR modules, any frames from these modules are hidden from the call stack.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.IsTransitionModule">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.LoadContext">
      <summary>String description of the context under which this module has been loaded (ex: 'Win32' or 'CLR v2.0.50727: Default Domain').</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.LoadOrder">
      <summary>The integer count of the number of module instances that have loaded, up to and including this module. Each runtime instance keeps track of its own load order count.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MemoryLayout">
      <summary>Enumeration that indicates how a module is laid out in memory.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfoPart">
      <summary>[Optional] 'MinidumpInfoPart' is used to convey additional information about modules in a DkmProcess for a minidump.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Module">
      <summary>[Optional] The symbol handler's representation of a module (DkmModule) that is associated with this module instance. This value is at first null, and is assigned if symbols are associated with this module instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Name">
      <summary>Short representation of the module name. For file-based modules, this is the file name and extension (ex: kernel32.dll).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.OnSymbolsLoaded(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Boolean)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.OnSymbolsUpdated(Microsoft.VisualStudio.Debugger.Symbols.DkmModule)">
      <summary>Raises a ModuleSymbolsUpdated event. Components that implement the event sync interface will receive the event notification. Control will return as soon as all components have been notified.</summary>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers all of these to be identical, there will be only one module object.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.ReadSymbols">
      <summary>This method is invoked by symbol handlers to read symbols for DkmModuleInstances whose symbols reside in the debuggee's memory.</summary>
      <returns>[Out,Optional] The symbol buffer that is read from the debuggee's memory at runtime.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.SetDisabled(System.Boolean)">
      <summary>Updates the disabled status on a module. This method may only be called from a ModuleInstanceLoad event. When disabling a module, it is common to also suppress the module load event.</summary>
      <param name="IsDisabled">[In] Indicates whether this module instance has been disabled. Disabled modules are largely ignored by the debugger. For native modules, the address range of the disabled module is treated as if it were unmapped. For CLR modules, any frames from these modules are hidden from the call stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.SetModule(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Boolean)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Size">
      <summary>[Optional] The number of bytes in the module's memory region. This value will be zero if the module did not load in a contiguous block of memory.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.SymbolFileId">
      <summary>[Optional] Contains information that is required to locate symbols for this module. On Win32, this information is contained in the IMAGE_DEBUG_DIRECTORY.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.TagValue">
      <summary>DkmModuleInstance is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.TimeDateStamp">
      <summary>Date/time of when the loaded module was built. This value is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a FILETIME value, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.TryLoadBinary">
      <summary>Attempts to load a binary that previously did not load using updated symbol paths. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.TryLoadSymbols">
      <summary>Called to initiate loading of symbols for DkmModuleInstances whose symbols were not found when the module loaded. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.UniqueId">
      <summary>Uniquely identifies the DkmModuleInstance object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Unload">
      <summary>Marks the Unload object as unloaded and notifies components that implement the event sync interface. Control will return as soon as all components have been notified. This method may only be called by the component that created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Version">
      <summary>[Optional] File version information.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleVersion" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo">
      <summary>'MinidumpInfo' is used to convey additional information about modules in a DkmProcess for a minidump.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo.#ctor(System.String)">
      <summary>Initialize a new MinidumpInfo value.</summary>
      <param name="OriginalPath">[In] Path where the module was loaded on the computer where the dump was taken.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo.OriginalPath">
      <summary>Path where the module was loaded on the computer where the dump was taken.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Tag">
      <summary>DkmModuleInstance is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Tag.NativeModuleInstance">
      <summary>Object is an instance of 'DkmNativeModuleInstance'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Tag.ClrModuleInstance">
      <summary>Object is an instance of 'DkmClrModuleInstance'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleInstance.Tag.CustomModuleInstance">
      <summary>Object is an instance of 'DkmCustomModuleInstance'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout">
      <summary>Enumeration that indicates how a module is laid out in memory.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout.Unknown">
      <summary>The memory layout of this module is unknown or not defined. This is used for CLR dynamic modules.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout.MemoryPE">
      <summary>Dll is loaded using the 'in memory' layout for a PE. This is the result from LoadLibrary or CreateFileMapping(..SEC_IMAGE...).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout.DiskPE">
      <summary>Dll is loaded using the disk layout for a PE. This is the result of a PE file being directly blitted into a memory buffer using ReadFile.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmModuleVersion">
      <summary>File version information.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.CompanyName">
      <summary>[Optional] 'CompanyName' field from the variable-sized version data (ex: 'Microsoft Corporation').</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmModuleVersion.Create(System.String,System.String,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Creates a new DkmModuleVersion object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FileVersionString">[In,Optional] 'FileVersion' field from the variable-sized version data (ex: '6.0.6000.16386 (vista_rtm.061101-2205)').</param>
      <param name="CompanyName">[In,Optional] 'CompanyName' field from the variable-sized version data (ex: 'Microsoft Corporation').</param>
      <param name="FileVersionMS">[In] Most significant 32-bits of the file version (e.g., 0x00030010 = 3.10).</param>
      <param name="FileVersionLS">[In] Least significant 32 bits of the file's binary version number.</param>
      <param name="ProductVersionMS">[In] Most significant 32 bits of the binary version number of the product with which this file was distributed (e.g., 0x00030010 = 3.10).</param>
      <param name="ProductVersionLS">[In] Least significant 32 bits of the binary version number of the product with which this file was distributed (e.g., 0x00000031 = 0.31).</param>
      <param name="VersionFlags">[In] VS_FF_* flags from winver.h of the Platform SDK.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.FileVersionLS">
      <summary>Least significant 32 bits of the file's binary version number (e.g., 0x00000031 = 0.31).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.FileVersionMS">
      <summary>Most significant 32 bits of the file version (e.g., 0x00030010 = 3.10).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.FileVersionString">
      <summary>[Optional] 'FileVersion' field from the variable-sized version data (ex: '6.0.6000.16386 (vista_rtm.061101-2205)').</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.ProductVersionLS">
      <summary>Least significant 32 bits of the binary version number of the product with which this file was distributed (e.g., 0x00000031 = 0.31).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.ProductVersionMS">
      <summary>Most significant 32 bits of the binary version number of the product with which this file was distributed (e.g., 0x00030010 = 3.10).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmModuleVersion.VersionFlags">
      <summary>VS_FF_* flags from winver.h of the Platform SDK.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmProcess">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.AbortingFuncEvalExecution(Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags)">
      <summary>AbortingFuncEvalExecution is called by the runtime debug monitor when aborting a function evaluation. AbortingFuncEvalExecution will update the internal state of the DkmProcess object so the stopping event manager will allow for two stopping events through: a function evaluation complete breakpoint or an async break.</summary>
      <param name="Flags">[In] Flags affecting how function evaluation requests are performed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.AddExceptionTrigger(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Guid,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Exceptions.DkmAddExceptionTriggerAsyncResult})">
      <summary>Adds an exception trigger so that ExceptionTriggerHit events will be sent when the exception trigger has been met. If there is already an exception triggered defined for this {SourceId, DkmExceptionTrigger} tuple then the existing trigger will be modified with the new settings. For example, if a component defines a trigger to stop when an access violation exception is thrown and later sets a trigger to fire when any Win32 exception goes unhandled, then the access violation trigger will be removed. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="Trigger">[In] Describes an exception or collection of exceptions which a component wants to break on. When a higher level component wants to be notified about certain exceptions, it should create one or more exception triggers, and then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, a ExceptionTriggerHit exception will be fired whenever this trigger is met.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.AddExceptionTrigger(System.Guid,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger)">
      <summary>Adds an exception trigger so that ExceptionTriggerHit events will be sent when the exception trigger has been met. If there is already an exception triggered defined for this {SourceId, DkmExceptionTrigger} tuple then the existing trigger will be modified with the new settings. For example, if a component defines a trigger to stop when an access violation exception is thrown and later sets a trigger to fire when any Win32 exception goes unhandled, then the access violation trigger will be removed.</summary>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="Trigger">[In] Describes an exception or collection of exceptions which a component wants to break on. When a higher level component wants to be notified about certain exceptions, it should create one or more exception triggers, and then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, an ExceptionTriggerHit exception will be fired whenever this trigger is met.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.AllocateVirtualMemory(System.UInt64,System.Int32,System.Int32,System.Int32)">
      <summary>Reserves and commits a region of memory in the virtual address space of the target process. The function initializes the memory it allocates to zero, unless MEM_RESET is used. For additional information, see the VirtualAlloc Win32 API in MSDN.</summary>
      <returns>[Out] Base address of the allocated region of pages.</returns>
      <param name="Address">[In] Address in the target process where the memory should be committed or reserved. This value is typically zero, in which case the system chooses an address.</param>
      <param name="Size">[In] The size of the region of memory to allocate, in bytes. The system will automatically round up to the next page boundary.</param>
      <param name="AllocationType">[In] Indicates the type of allocation to perform. This is typically MEM_COMMIT | MEM_RESERVE (0x3000) which reserves and commits an allocation in one step.</param>
      <param name="PageProtection">[In] The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants (ex: PAGE_READWRITE, PAGE_EXECUTE).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.AsyncBreak(System.Boolean)">
      <summary>This method will tell the debug monitors to asynchronously break execution of the debuggee process. An AsyncBreakComplete event is sent after the operation is completed.</summary>
      <param name="StopImmediately">[In] If this is set to true, implementers should immediately enter break instead of trying to find a thread inside the process that is executing code.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.BaseDebugMonitorId">
      <summary>DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is used for processes debugged by the Win32 debugging API and DkmBaseDebugMonitorId.DumpFile is used for minidumps.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.ClearAllGPUMemoryAccessWarnings">
      <summary>Disables all active GPU memory access warnings.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.ClearExceptionTriggers(System.Guid)">
      <summary>Removes all the exception triggers which have been set with a particular SourceId. After this method returns, the exception triggers will no longer raise ExceptionTriggerHit events. Exception triggers are automatically cleared when the DkmProcess object is closed.</summary>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String,System.Guid,Microsoft.VisualStudio.Debugger.Start.DkmStartMethod,Microsoft.VisualStudio.Debugger.DkmEngineSettings,Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings,Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation,System.Guid,System.Boolean,Microsoft.VisualStudio.Debugger.DkmProcess.Live,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new process object. This method is called from the base debug monitor on the event thread as part of the processing of IDkmStartDebuggingOperations.AttachToProcess or IDkmStartDebuggingOperations.ResumeDebuggedProcess. This method will send a ProcessCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="Path">[In] Full path of the starting executable of the process.</param>
      <param name="UniqueId">[In] Guid which uniquely identifies this process object. This Guid value is the same as the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at the automation layer.</param>
      <param name="StartMethod">[In] StartMethod describes how the debug engine started debugging this process.</param>
      <param name="EngineSettings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
      <param name="DebugLaunchSettings">[In] Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</param>
      <param name="SystemInformation">[In] Contains information about the computer system that this process is running under. If this process is running under WOW (32-bit emulation on a 64-bit OS) this information will be for the 32-bit subsystem instead of the 64-bit subsystem.</param>
      <param name="BaseDebugMonitorId">[In] DkmBaseDebugMonitorId identifies the base debug monitor used to inspect and control the debugged process. For example, DkmBaseDebugMonitorId.WindowsProcess is used for processes debugged by the Win32 debugging API and DkmBaseDebugMonitorId.DumpFile is used for minidumps.</param>
      <param name="IsNativeDebuggingEnabled">[In] When true, the debugger will attempt to debug native code - it will stop on native exceptions, load symbols, display native frames on the call stack, bind and hit breakpoints, and leave native threads stopped when in break state.</param>
      <param name="Live">[In,Optional] Information relevant to a running process. For example, this Part will NOT be present for minidumps.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmProcess instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.CreateNativeInstructionAddress(System.UInt64)">
      <summary>Resolves a CPU instruction to a native module, and returns a DkmNativeInstructionAddress to represent this CPU instruction. If the instruction pointer is not in a module, a DkmUnknownInstructionAddress object is returned instead.</summary>
      <returns>[Out] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</returns>
      <param name="InstructionPointer">[In] Memory address where the native instruction is located.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.DebugLaunchSettings">
      <summary>Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Detach">
      <summary>This method is called to tell the monitor to detach from the target process. This will trigger a ProcessExit event to be sent on the event thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Disassemble(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.UInt32)">
      <summary>Disassemble an address range in the debuggee process. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The results of disassembling the address range.</returns>
      <param name="Address">[In] The address where disassembly should start.</param>
      <param name="Count">[In] The number of instructions to disassemble.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.EngineSettings">
      <summary>Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmEngineSettings" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FindNativeModule(System.UInt64)">
      <summary>Resolves a virtual address to a native module. If the virtual address is not in a module, null is returned (S_FALSE return code in native). Disabled modules will not be returned.</summary>
      <returns>[Out,Optional] 'DkmNativeModuleInstance' is used for modules which contain CPU code and are loaded by the Win32 loader.</returns>
      <param name="Address">[In] Memory address to use as a search key.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FindNativeModule(System.UInt64,System.Boolean)">
      <summary>Resolves a virtual address to a native module. If the virtual address is not in a module, null is returned (S_FALSE return code in native).</summary>
      <returns>[Out,Optional] 'DkmNativeModuleInstance' is used for modules which contain CPU code and are loaded by the Win32 loader.</returns>
      <param name="Address">[In] Memory address to use as a search key.</param>
      <param name="IncludeDisabledModules">[In] When true, the search will include module instances that have 'IsDisabled' set to 'true'.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FindProcess(System.Guid)">
      <summary>Find a DkmProcess object. If no object that has the given input key is present, FindProcess will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="UniqueId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FindRuntimeInstance(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Find a DkmRuntimeInstance element within this DkmProcess. If no element that has the given input key is present, FindRuntimeInstance will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Id">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FindSystemThread(System.Int32)">
      <summary>Find a DkmThread element within this DkmProcess. If no element that has the given input key is present, FindSystemThread will fail. If an object is found, it will always contain the 'System' Part.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Id">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.FreeVirtualMemory(System.UInt64,System.Int32,System.Int32)">
      <summary>Releases and decommits a region of memory in the virtual address space of the target process. For additional information, see the VirtualFree Win32 API in MSDN.</summary>
      <param name="Address">[In] Address in the target process where the memory should be freed.</param>
      <param name="Size">[In] Number of bytes to decommit. To release a region of memory, this value must be zero.</param>
      <param name="FreeType">[In] Indicates the type of free operation to perform. This is typically MEM_RELEASE (0x8000), which releases the specified region of pages. After the operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be used instead to decommit the pages without releasing them.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetComputeKernels">
      <summary>GetComputeKernels enumerates the DkmGPUComputeKernel elements of this DkmProcess object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetGPUBreakpointBehavior">
      <summary>Get the breakpoint behavior of the process.</summary>
      <returns>[Out] The breakpoint behavior of the process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetHandleCount">
      <summary>Obtains the number of active handles in the process.</summary>
      <returns>[Out] The number of handles in the debuggee process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetInstructionAddress(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Int32)">
      <summary>Returns the address of the kth instruction relative to a starting address. For constant length instruction sets, this is simple arithmetic. For variable length instruction sets, reverse-disassembly is required to obtain this address. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The address of the instruction InstructionOffset instructions from StartAddress.</returns>
      <param name="StartAddress">[In] The address of the current instruction where the offset should begin.</param>
      <param name="InstructionOffset">[In] The number of instructions relative to StartAddress to find the desired address. This value can be negative.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetInstructionAddress(Microsoft.VisualStudio.Debugger.DkmWorkList,System.UInt64,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult})">
      <summary>Resolves a CPU InstructionAddress to a DkmInstructionAddress. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="InstructionPointer">[In] Memory address where the native instruction is located.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetNativeRuntimeInstance">
      <summary>Provides access to the DkmRuntimeInstance which is for the naive code in a process. There is exactly one DkmRuntimeInstance for a process.</summary>
      <returns>[Out] Represents the native code executing in a target process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetPendingBreakpoints">
      <summary>GetPendingBreakpoints enumerates the DkmPendingBreakpoint elements of this DkmProcess object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetProcesses">
      <summary>GetProcesses enumerates all the created DkmProcess objects.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetRunningTime">
      <summary>Obtains the number of clock cycles that the debuggee has been running since ResetRunningTime() was last called.</summary>
      <returns>[Out] The time the debuggee has been running.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetRuntimeFunctionResolutionRequests">
      <summary>GetRuntimeFunctionResolutionRequests enumerates the DkmRuntimeFunctionResolutionRequest elements of this DkmProcess object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetRuntimeInstances">
      <summary>GetRuntimeInstances enumerates the DkmRuntimeInstance elements of this DkmProcess object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetSystemThreads">
      <summary>Provides the list of active system threads in the process. Threads which are not system threads (DkmThread::System is null) or have been unloaded, will not be present in this collection.</summary>
      <returns>[Out] Returned array of system threads.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.GetThreads">
      <summary>GetThreads enumerates the DkmThread elements of this DkmProcess object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.InvisibleWriteMemory(System.UInt64,System.Byte[])">
      <summary>Write memory to the target process, but hide the write from calls to ReadMemory. This API may be used to patch instructions or data in the target process to implement debugger features. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size can be accessed for write access, and if it cannot be accessed, the function raises an E_INVALID_MEMORY_ADDRESS error.</summary>
      <param name="Address">[In] The base address from which to write the target process's memory.</param>
      <param name="Data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.IsNativeDebuggingEnabled">
      <summary>When true, the debugger will attempt to debug native code - it will stop on native exceptions, load symbols, display native frames on the call stack, bind and hit breakpoints, and leave native threads stopped when in break state.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.IsStopped">
      <summary>This method allows a component to determined if the process is considered stopped by the Dispatcher. This method does not have to be called from an interface method which requires the target process to be stopped, but it may be helpful during operations which may be called from run mode.</summary>
      <returns>[Out] Returns true if the process is considered stopped. This will return true on request threads after the debugger has sent a stopping event (ex: breakpoint hit) to the IDE and before the process has been resumed. It will return true on event threads if a pausing event (ex: module load) or stopping event (ex: breakpoint hit) is being processed.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.LivePart">
      <summary>[Optional] Information relevant to a running process. For example, this Part will NOT be present for minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess.Live" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.LocateBinary(System.String,System.String,System.String,System.UInt32,System.UInt32)">
      <summary>This method will search the local disk and any configured symbol servers for a binary that matches the parameters. The path of this file on the local disk is returned. If the file was on a symbol server, it is downloaded to a cache and the local path is returned.</summary>
      <returns>[Out,Optional] The path on the local disk of the local (or downloaded) binary.</returns>
      <param name="ApplicationPath">[In] The original path of the exe stored in the minidump.</param>
      <param name="DumpPath">[In] The path of the dump file.</param>
      <param name="OriginalPath">[In] The original path of the binary stored in the minidump.</param>
      <param name="TimeDateStamp">[In] The time date stamp of the binary in the time_t format.</param>
      <param name="ImageSize">[In] The size of the image.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.OnAsyncBreakComplete(Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Raise a AsyncBreakComplete event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="Status">[In] Indicates the type of async-break that occurred.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.OnEntryPoint(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Raise a EntryPoint event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.OnInstructionPatchInserted(System.UInt64,System.Byte[])"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.OnInstructionPatchRemoved(System.UInt64,System.Byte[])"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.OnLoadComplete">
      <summary>Raise a LoadComplete event. Components which implement the event sync interface will receive the event notification. Control will return as soon as all components have been notified. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.Path">
      <summary>Full path of the starting executable of the process.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.ReadMemory(System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Byte[])">
      <summary>Read the memory of the target process.</summary>
      <returns>[Out] Indicates the number of bytes read from the target process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be greater than zero.</returns>
      <param name="Address">[In] The base address from which to read the target process's memory.</param>
      <param name="Flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="Buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.ReadMemory(System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Void*,System.Int32)">
      <summary>Read the memory of the target process.</summary>
      <returns>[Out] Indicates the number of bytes read from the target process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be greater than zero.</returns>
      <param name="Address">[In] The base address from which to read the target process's memory.</param>
      <param name="Flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="Buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <param name="Size">[In] The number of bytes to be read from the process.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.ReadMemoryString(System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.UInt16,System.Int32)">
      <summary>Reads a null-terminated string from the target process process's memory. This can be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.</summary>
      <returns>[Out] The value of the string which was read from the target process. If DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always include the null termination character. If DkmReadMemoryFlags.AllowPartialRead is specified, this buffer will not contain the null termination character if the read was truncated.</returns>
      <param name="Address">[In] The base address from which to read the target process's memory.</param>
      <param name="Flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="CharacterSize">[In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).</param>
      <param name="MaxCharacters">[In] The maximum number of characters to read from the target process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null terminator is not found within this range. This value should be reasonable. The Microsoft implementation will fail any request for more than 128MBs of string memory.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.-or-E_STRING_TOO_LONG indicates that the string could not be read in the specified maximum number of characters.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.SearchRuntimeFunctionTable(System.UInt64,System.UInt64@)">
      <summary>The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an address if it is possible. For searching static entries, callers should call the equivalent method on DkmNativeModuleInstance.</summary>
      <returns>[Out,Optional] The runtime function table entry for this address if found.</returns>
      <param name="Address">[In] The virtual address for which to find a function table entry for.</param>
      <param name="BaseAddress">[Out] The base address for the runtime function table entry.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.SetGPUMemoryAccessWarning(System.Int32,System.Boolean)">
      <summary>Enables / disables a particular GPU memory access warning.</summary>
      <param name="WarningCode">[In] Warning code to set.</param>
      <param name="Enable">[In] True to set the warning, false to clear it.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.SetRunningTime(System.UInt64)">
      <summary>Sets the running time counter to the specified value.</summary>
      <param name="RunningTime">[In] The value to set the clock to.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.StartMethod">
      <summary>StartMethod describes how the debug engine started debugging this process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.StoppingEventProcessingBegin(System.Boolean)">
      <summary>StoppingEventProcessingBegin is called by the base debug monitor on the event thread. It notifies the Dispatcher that the target process is stopped and may have reached a stopping event. For example, the Win32 base debug monitor calls this whenever it receives an EXCEPTION_DEBUG_EVENT from the operating system. This method updates the internal state of the DkmProcess object so that stopping events can be sent.</summary>
      <param name="ForceQueue">[In] Normally, the dispatcher will reject (return E_TARGET_ALREADY_STOPPED) attempts to send additional stopping events after the target process has received its initial batch of stopping events (StoppingEventProcessingContinue has been called). By passing 'true' for this argument, the base debug monitor causes these events to be queued instead of rejected. This is used by the Win32 debug monitor when it fully drains the Win32 debugging event queue before the start of a function evaluation.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.StoppingEventProcessingContinue">
      <summary>StoppingEventProcessingContinue is called by the base debug monitor on the event thread. This method is called after all stopping events in the current batch have been issued (ex: called DkmRuntimeBreakpoint.OnHit). This method will notify components which have implemented a stopping event notification interface and will call into the execution manager to slip the process to a safe point. The base debug monitor must call StoppingEventProcessingContinue after any successful call to StoppingEventProcessingBegin. the base debug monitor after it has issued all stopping events. A base debug monitor should expect to be reentrantly called when it is in this method.</summary>
      <returns>[Out] Status code returned to the base debug monitor to indicate the next action to take in stopping event processing.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.SystemInformation">
      <summary>Contains information about the computer system that this process is running under. If this process is running under WOW (32-bit emulation on a 64-bit OS) this information will be for the 32-bit subsystem instead of the 64-bit subsystem.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Terminate(System.Int32)">
      <summary>This method is called to tell the monitor to end the target process. This will trigger a ProcessExit event to be sent on the event thread.</summary>
      <param name="ExitCode">[In] The exit code that will be used by the process and threads terminated because of this call. Use the GetExitCodeProcess function to retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a thread's exit value.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmProcess.UniqueId">
      <summary>Guid which uniquely identifies this process object. This Guid value is the same as the Guid exposed at the SDM layer (IDebugProcess2::GetProcessId) and at the automation layer.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Unload(System.Int32)">
      <summary>ProcessExit is sent by the dispatcher when DkmProcess::Unload is invoked by the monitor. This method may only be called by the component which created the object.</summary>
      <param name="ExitCode">[In] 32-bit value which the processed returned on exit. This is the same value that would be reported from the kernel32!GetExitCodeProcess.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.VolatileReadMemory(System.UInt64,System.Byte[])">
      <summary>Read memory from the target process. This method differs from 'ReadMemory' in that this method can be called at any time (not just when the target is stopped) and the debugger will not try to cache the result of this operation.</summary>
      <param name="Address">[In] The base address from which to read the target process's memory.</param>
      <param name="Buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request could not be read.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.VolatileReadMemory(System.UInt64,System.Void*,System.Int32)">
      <summary>Read memory from the target process. This method differs from 'ReadMemory' in that this method can be called at any time (not just when the target is stopped) and the debugger will not try to cache the result of this operation.</summary>
      <param name="Address">[In] The base address from which to read the target process's memory.</param>
      <param name="Buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <param name="Size">[In] The number of bytes to be read from the process.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request could not be read.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.VolatileWriteMemory(System.UInt64,System.Byte[])">
      <summary>Write to the memory of the target process. This method differs from 'WriteMemory' in that this method can be called at any time (not just when the target is stopped) and the debugger will not try to cache the result of this operation. If any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be raised. Because the memory write may occur from run mode, this failure may occur after the copy operation has already begun, and therefore could lead to memory corruption in the target process. For this reason, this function must be used with care, and failures may be fatal.</summary>
      <param name="Address">[In] The base address from which to write the target process's memory.</param>
      <param name="Data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.WriteDump(Microsoft.VisualStudio.Debugger.DkmDumpType,System.String,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>This method will write out a memory dump of the process to the path specified.</summary>
      <param name="DumpType">[In] The type of dump to write. Either minidump or full-memory minidump.</param>
      <param name="Path">[In] The full path of where the minidump should be saved. In remote scenarios, this path is relative to the remote computer.</param>
      <param name="TargetThread">[In,Optional] The thread to use for the minidump if there is no current exception.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.WriteMemory(System.UInt64,System.Byte[])">
      <summary>Writes memory to the target process. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size can be accessed for write access, and if it cannot be accessed, the function raises an E_INVALID_MEMORY_ADDRESS error.</summary>
      <param name="Address">[In] The base address from which to write the target process's memory.</param>
      <param name="Data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmProcess.Live">
      <summary>Information relevant to a running process. For example, this Part will not be present for minidumps.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmProcess.Live.#ctor(System.Int32,System.Int64)">
      <summary>Initializes a new Live value.</summary>
      <param name="Id">[In] Process ID (PID) assigned by the operating system. As the same process ID can be used by multiple computers, and as process IDs can be recycled, we recommend that you use 'UniqueId' for identity purposes.</param>
      <param name="StartTime">[In] 64-bit date time value indicating when the process was started. The start time together with the ID and the computer where the process was started can uniquely identify a process.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmProcess.Live.Id">
      <summary>Process ID (PID) assigned by the operating system. As the same process ID can be used by multiple computers, and as process IDs can be recycled, we recommend that you use 'UniqueId' for identity purposes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmProcess.Live.StartTime">
      <summary>64-bit date time value indicating when the process was started. The start time together with the ID and the computer where the process was started can uniquely identify a process.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture.PROCESSOR_ARCHITECTURE_INTEL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture.PROCESSOR_ARCHITECTURE_AMD64">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags">
      <summary>Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags.None">
      <summary>Indicates that the caller wants the default behavior for ReadMemory.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags.AllowPartialRead">
      <summary>Indicates that the caller wants the read operation to succeed if only part of the memory read succeeded. If this is set, an E_INVALID_MEMORY_ADDRESS error will only be raised if 'Address' is invalid. If this flag is clear, an E_INVALID_MEMORY_ADDRESS error will be raised if any part of the requested memory was unreadable.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags.ExecutableOnly">
      <summary>Indicates that the read should only succeed if the memory pages in question have one of the execute flags set (PAGE_EXECUTE, PAGE_EXECUTE_READONLY, etc.). If combined with AllowPartialRead, this will return all memory between the starting address and the end of the executable region. If no executable code is found, the read fails with E_INVALID_MEMORY_PROTECT.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags.ReadGPUPointer">
      <summary>Indicates that the read is a GPU C++ AMP pointer and that the high bits should be read from the tag memory.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstance.ResolveCPUInstructionAddress call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeInstance.ResolveCPUInstructionAddress.</summary>
      <param name="AddressObject">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="FirstAddress">[In] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult.AddressObject">
      <summary>Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstance.ResolveCPUInstructionAddress.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult.FirstAddress">
      <summary>True if this address is the first address in the line's range. False otherwise.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmRuntimeId">
      <summary>The Runtime Id identifies the execution environment for a particular block of code. Runtime Ids are used by the dispatcher to decide which monitor to dispatch to. Note that the ordering of the runtime ID Guids is somewhat significant as this dictates which runtime receives the first shot during arbitration. Thus, if one wants to declare a new runtime instance which is built on the CLR, the runtime id should be less than DkmRuntimeId.Clr.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeId.ActiveScript">
      <summary>Identifies code running under Microsoft ActiveScript based runtimes.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeId.Clr">
      <summary>Identifies code running under the CLR runtime.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeId.Gpu">
      <summary>Identifies code running under the GPU D3D runtime.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeId.Native">
      <summary>Identifies native code. Since all code executed by the CPU is native, this is the default runtime and any code address unclaimed by other runtimes will be treated as native.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance">
      <summary>Represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged. Derived classes: DkmClrRuntimeInstance, DkmCustomRuntimeInstance, DkmNativeRuntimeInstance, DkmScriptRuntimeInstance</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.AfterSteppingArbitration(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.BeforeEnableNewStepper(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Connection">
      <summary>Represents a connection between the monitor and the IDE. It can be a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.FindModulesByName(System.String)">
      <summary>Returns all modules that match the specified name.</summary>
      <returns>[Out] Returns any modules that match the specified search key. Only currently loaded .dlls will be returned. Modules are returned in load order.</returns>
      <param name="SearchKey">[In] Name of the module to search for. This string can contain the file name extension (ex: 'kernel32' or 'kernel32.dll').</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetModuleInstances">
      <summary>Enumerates the DkmModuleInstance elements of the DkmRuntimeInstance object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetScriptDocumentTreeNodes">
      <summary>Enumerates the DkmScriptDocumentTreeNode elements of the DkmRuntimeInstance object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetTaskProviders">
      <summary>Enumerates the DkmTaskProvider elements of the DkmRuntimeInstance object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetThreadDisplayProperties(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult})">
      <summary>Gets the display properties of the thread, including the display name and thread category. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Thread">[In] The thread.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetThreadName(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Computes the name of a thread.</summary>
      <returns>[Out,Optional] The thread name.</returns>
      <param name="Thread">[In] The thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.GetThreadName(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult})">
      <summary>Computes the name of a thread. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Thread">[In] The thread.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Id">
      <summary>Identifies a DkmRuntimeInstance object in a process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.NotifyStepComplete(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.OnNewControllingRuntimeInstance(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.OwnsCurrentExecutionLocation(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason)">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.ResolveCPUInstructionAddress(Microsoft.VisualStudio.Debugger.DkmWorkList,System.UInt64,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DkmResolveCPUInstructionAddressAsyncResult})">
      <summary>Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress object. This API is currently only supported by CLR DkmRuntimeInstance objects, and the CLR runtime instance can currently only find instruction addresses that are in a method that is currently on the call stack of one of the threads in the target process. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="InstructionPointer">[In] Memory address where the native instruction is located.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.ResolveCPUInstructionAddress(System.UInt64,System.Boolean@)">
      <summary>Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress object. This API is currently only supported by CLR DkmRuntimeInstance objects, and the CLR runtime instance can currently only find instruction addresses that are in a method that is currently on the call stack of one of the threads in the target process.</summary>
      <returns>[Out] Abstract representation of an executable code location (ex: EIP value). If resolved, an instruction address will be in a particular module instance. An instruction address is always in a particular runtime instance.</returns>
      <param name="InstructionPointer">[In] Memory address where the native instruction is located.</param>
      <param name="FirstAddress">[Out] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.SetRegisterValue(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Sets the value of the register in the thread's context. Sub registers that consist of larger registers are supported.</summary>
      <param name="StackWalkFrame">[In] The stack frame the register is being set in. For most runtime instances, this is used to verify that the stack frame is the top of the stack and stop the write if it is not.</param>
      <param name="RegisterIndex">[In] The CV constant of the register to set.</param>
      <param name="Value">[In] The value to set the register to. The size of the byte array must match the width of the register being set.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Step(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.StepControlRequested(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.StopStep(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.TagValue">
      <summary>DkmRuntimeInstance is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.TakeStepControl(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,System.Boolean,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Unload">
      <summary>RuntimeInstanceUnload is sent by the dispatcher when DkmRuntimeInstance::Unload is invoked by the monitor. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag">
      <summary>DkmRuntimeInstance is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag.NativeRuntimeInstance">
      <summary>Object is an instance of 'DkmNativeRuntimeInstance'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag.ClrRuntimeInstance">
      <summary>Object is an instance of 'DkmClrRuntimeInstance'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag.ScriptRuntimeInstance">
      <summary>Object is an instance of 'DkmScriptRuntimeInstance'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance.Tag.CustomRuntimeInstance">
      <summary>Object is an instance of 'DkmCustomRuntimeInstance'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId">
      <summary>Identifies a DkmRuntimeInstance object in a process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.#ctor(System.Guid,System.UInt64)">
      <summary>Initializes a new DkmRuntimeInstanceId value.</summary>
      <param name="RuntimeType">[In] Indicates which type of runtime instance this is (ex: native code, CLR, etc.).</param>
      <param name="InstanceId">[In] Used together with the 'RuntimeType' to uniquely identify a particular runtime instance in a given DkmProcess. If the 'RuntimeType' only supports a single runtime instance per process (ex: DkmRuntimeId.Native), this value is typically zero. For DkmRuntimeId.Clr, this value is the base address of the CLR .dll.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.CompareTo(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.Equals(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>True if the two elements are equal.</returns>
      <param name="other">Value to compare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.InstanceId">
      <summary>Used together with the 'RuntimeType' to uniquely identify a particular runtime instance in a given DkmProcess. If the 'RuntimeType' only supports a single runtime instance per process (ex: DkmRuntimeId.Native), this value is typically zero. For DkmRuntimeId.Clr, this value is the base address of the CLR .dll.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_Equality(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_GreaterThan(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_Inequality(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_LessThan(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId)">
      <summary>Compares two elements of the DkmRuntimeInstanceId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId.RuntimeType">
      <summary>Indicates which type of runtime instance this is (ex: native code, CLR, etc.).</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult">
      <summary>Result of an asynchronous DkmCustomMessage.SendLower call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.DkmCustomMessage)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmCustomMessage.SendLower.</summary>
      <param name="ReplyMessage">[In,Optional] Message sent back from the implementation.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmCustomMessage.SendLower.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSendLowerAsyncResult.ReplyMessage">
      <summary>[Optional] Message sent back from the implementation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmCustomMessage" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmSourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.AD7BreakpointId">
      <summary>Object was created in response to a breakpoint request from the IDE.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.AD7DeploymentId">
      <summary>Object was created at the AD7 layer to execute a command.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.AD7ExceptionBoundary">
      <summary>DkmExceptionTrigger was created in response to the 'Break when exceptions cross AppDomain or managed/native boundaries (Managed only)' debugger option.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.AD7ExceptionSetting">
      <summary>DkmExceptionTrigger was created in response to exception settings from the IDE.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.AD7Stepper">
      <summary>DkmStepper created in response to a step request from the IDE.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.BaseDMServicesId">
      <summary>Object was created at the AD7 layer to execute a command.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.ClientCppEE">
      <summary>Object created for local CPP EE.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.GpuDebugMonitorRequest">
      <summary>Filtered events sent to the GPU Debug Monitor filter on this Source ID.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.ManagedDmStepper">
      <summary>DkmStepper created by Managed DM.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.ManagedDmSymbolsUpdateId">
      <summary>SymbolsUpdate event generated by Managed DM.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.MSBreakpointManagerId">
      <summary>Object was created for a source-level breakpoint by the Microsoft breakpoint manager.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.NativeBaseDmRequest">
      <summary>Filtered events sent to the Native DM filter on this Source ID.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.ServerCppEE">
      <summary>Object created for server CPP EE.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmSourceId.SteppingManagerStepper">
      <summary>DkmStepper created by the Stepping Manager.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction">
      <summary>Status code returned to the base debug monitor to indicate the next action to take in stopping event processing.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction.ResumeTarget">
      <summary>The base debug monitor should resume execution of the target processes ordinarily. If an exception event was raised, standard exception processing (ex: handler search, stack unwinding) should continue in the target process unless DkmExceptionInformation.SquashProcessing() was successfully called. This status value is returned when the base debug monitor did not issue any stopping events, or when all stopping events were suppressed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction.SlipTarget">
      <summary>The base debug monitor should resume execution of non-suspended threads in the target process. Standard exception processing on suspended thread should be held up so that the decision as to whether it should be able to continue ordinarily or be squashed may be made in the future. This status value is used when one or more threads are not at a safe point. Therefore, the target process must be slipped. The target process is expected to hit one or more stopping events (breakpoint or exception) in order to indicate that a safe point has been reached. The base debug monitor may also eventually time out and continue without reaching a safe point. The time-out value is specified in DkmEngineSettings.SlipTimeout.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction.ResumeUnclaimedThreads">
      <summary>The base debug monitor should resume execution of non-suspended threads in the target process. Standard exception processing on suspended thread should be held up so that the decision as to whether it should be able to continue ordinarily or be squashed may be made in the future. After resuming execution, the base debug monitor should immediately call StoppingEventProcessingContinue again. This status value is used when all threads are in the target process are at a safe point but one or more threads in the target process should run free when in break mode. This is used when managed-only debugging certain host applications.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction.EnterStoppedState">
      <summary>Stopping event processing has completed and a stopping event has been sent to the IDE. Execution of the target process should stay stopped until the IDE resumes execution.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmStoppingEventProcessingNextAction.ForceQueueModeComplete">
      <summary>This value is returned if StoppingEventProcessingBegin was called by using ForceQueueMode set to true.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmThread">
      <summary>DkmThread represents a thread running in the target process. Derived classes: DkmGPUComputeThread</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.BeginFuncEvalExecution(Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags)">
      <summary>This method is used to resume the target process so that a function evaluation may occur. This function is called by a runtime debug monitor after it has set up a function evaluation in order to make the target process run. The runtime monitor will first update the thread context, update any necessary memory in the target process, and setup any detection that the function evaluation is completed. Callers of this method MUST always call EndFuncEvalExecution before they return from the operation that triggered the function evaluation. The behavior is undefined if a caller does not do so. This method is implemented in the base debug monitor by first updating the target process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution), then suspending and resuming threads as specified by the function evaluation flags and finally continuing the target process. This method may be called from any thread. However, OnBeginFuncEvalExecution must be called from the stopping event thread, so the base debug monitor may have to perform as thread switch as part of the implementation of this method. The base debug monitor should not return from BeginFuncEvalExecution until after the target has been resumed.</summary>
      <param name="Flags">[In] Flags affecting how function evaluation requests are performed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.UInt64,System.Boolean,Microsoft.VisualStudio.Debugger.DkmThread.System,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>DkmThread is called by a debug monitor to create a new DkmThread instance. DkmThread objects for system threads are created by the base debug monitor. This method must be called on the event thread. This method will send a ThreadCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="NativeStartAddress">[In] If available, this is the Win32 start address of this thread (value passed to the CreateThread API). The value will not always be available, for example, it is generally not available in scenarios where the thread was started after the debugger attached, or in minidumps.</param>
      <param name="TebAddress">[In] Address in the target process, where the Win32 thread environment block is stored. See documentation on the TEB structure in MSDN for more information.</param>
      <param name="IsMainThread">[In] True if this is the main thread of this process. The main thread is the first thread to start.</param>
      <param name="System">[In,Optional] Describes traits of the thread which are relevant to a full Win32 thread. Currently, this value is required, and all threads will have a 'System' block. In the future, this value may be NULL if the DkmThread represents something other than a full Win32 thread.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmThread instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.CreateFrameRegisters(Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister[],System.UInt32)">
      <summary>Convert an array of DkmUnwoundRegisters into an instance of DkmFrameRegisters that contain a sorted DkmReadOnlyCollection of DkmUnwoundRegisters.</summary>
      <returns>[Out] DkmFrameRegisters represents the registers of a stack frame.</returns>
      <param name="UnwoundRegisters">[In] The unwound register collection to use as the source of the collection.</param>
      <param name="VFrame">[In] The vframe for this register set. This is only used on x86.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.CreateRegistersObject(System.Byte[],Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister[],Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister[])">
      <summary>Creates a DkmFrameRegisters object from the supplied byte array that contains a Win32 CONTEXT structure.</summary>
      <returns>[Out] DkmFrameRegisters represents the registers of a stack frame.</returns>
      <param name="ThreadContext">[In] Win32 CONTEXT to obtain the registers for.</param>
      <param name="PseudoRegisters">[In] An array of cvconst/value pairs to add to the collection of register values coming from the context. This is generally used to add the vframe pseudo-register on x86.</param>
      <param name="ExtendedRegisters">[In] An array of extended registers.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.EndFuncEvalExecution(Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags)">
      <summary>EndFuncEvalExecution is called by the runtime debug monitor on the event thread to exit function evaluation mode. EndFuncEvalExecution will update the internal state of the DkmProcess object to indicate that the function evaluation has ended. This will also send a FuncEvalEnded event and it will mark the process as stopped. This method may be called (1) when processing a 'received' stopping event notification -or- (2) when processing a non-stopping event such as thread exit, -or- (3) when the target is still stopped, for example if the function evaluation setup failed.</summary>
      <param name="Flags">[In] Flags affecting how function evaluation requests are performed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetContext(System.Int32,System.Byte[])">
      <summary>Obtain the current context (register values) of a thread.</summary>
      <param name="ContextFlags">[In] Win32 flags indicating which part of the CONTEXT object to obtain (ex: CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).</param>
      <param name="Context">[In,Out] A Win32 CONTEXT structure that contains the context of the specified thread. The value of the ContextFlags member of this structure specifies which parts of a thread's context to obtained.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetContext(System.Int32,System.Void*,System.Int32)">
      <summary>Obtain the current context (register values) of a thread.</summary>
      <param name="ContextFlags">[In] Win32 flags indicating which part of the CONTEXT object to obtain (ex: CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).</param>
      <param name="Context">[In,Out] A Win32 CONTEXT structure that contains the context of the specified thread. The value of the ContextFlags member of this structure specifies which parts of a thread's context to obtained.</param>
      <param name="ContextSize">[In] Size of the context structure to read in bytes. This must exactly match the size required to read the context.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetCurrentFrameInfo(System.UInt64@,System.UInt64@,System.UInt64@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetCurrentFuncEvalMode">
      <summary>GetCurrentFuncEvalMode may be called by components as part of event processing to determine whether function evaluation is enabled. This function may only be called as part of event processing.</summary>
      <returns>[Out] Indicates if there is a function evaluation occurring in the target process and if stopping events are allowed for this evaluation.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetCurrentLocation(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult})">
      <summary>Provides the location of a thread, as visible in the threads window, or threads drop down in the debug location toolbar. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetCurrentRegisters(Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister[])">
      <summary>Returns a DkmFrameRegisters object that contains the thread's current register values.</summary>
      <returns>[Out] DkmFrameRegisters represents the registers of a stack frame.</returns>
      <param name="PseudoRegisters">[In] An array of cvconst/value pairs to add to the collection of register values coming from the context. This is generally used to add the vframe pseudo-register on x86.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetDebuggerSuspensionCount">
      <summary>Return the total number of suspensions caused by the debugger (that is calls to DkmThread::Suspend without a call to DkmThread::Resume). This excludes any suspensions external to the debugger.</summary>
      <returns>[Out] The total number of suspensions caused by the debugger (that is calls to DkmThread::Suspend without a call to DkmThread::Resume). This excludes any suspensions external to the debugger.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetExtendedRegisters">
      <summary>Gets the extended registers from the thread context.</summary>
      <returns>[Out] An array of extended registers.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetManagedThreadProperties(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult})">
      <summary>Get a managed thread's properties. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetManagedThreadProperties(System.Int32@)">
      <summary>Get a managed thread's properties.</summary>
      <param name="ManagedThreadId">[Out] The managed thread id of the thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetStackAddressRange">
      <summary>Retrieves the stack limit/stack base of the given thread. Note that its possible for this value to change over time, for example, with fibers.</summary>
      <returns>[Out] The limit/base address for the memory that contains a thread's stack.</returns>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address that contains the TEB structure could not be read from the target process. This may be returned for minidumps without heap.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetSteppers">
      <summary>GetSteppers enumerates the DkmStepper elements of this DkmThread object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetSuspensionCount(System.Boolean)">
      <summary>Return the current suspension count of this thread.</summary>
      <returns>[Out] The suspension count of thread. The internal thread suspension count is subtracted from this value if ShowInternal is false.</returns>
      <param name="ShowInternal">[In] Pass true to return the true suspension count for the thread. Return false to only see the suspensions that occurred in the debuggee process or the one's that passed true for InternalSuspension to Suspend.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetTlsValue(System.Int32)">
      <summary>Retrieves the value in the debuggee thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
      <returns>[Out] The pointer-sized value which was stored in the thread's TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be zero.</returns>
      <param name="TlsIndex">[In] The TLS index that was allocated when the target process called the TlsAlloc function.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetTopStackFrame">
      <summary>Returns the top call stack frame for a thread. This value is typically cached after the first stack walk and cleared on continue. This is only callable above the stack provider in the client process. To obtain the top frame in the server process, call GetTopStackWalkFrame. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetTopStackWalkFrame(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetVolatileFlags">
      <summary>Get volatile flags about a thread. For instance, return if a thread is a user-mode scheduled thread.</summary>
      <returns>[Out] Volatile flags that apply to a thread. These values are expected to change over time and should not be cached by callers.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetVolatileFlags(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult})">
      <summary>Get volatile flags about a thread. For instance, return if a thread is a user-mode scheduled thread. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetVolatileProperties(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult})">
      <summary>Get a thread's dynamic properties. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.GetVolatileProperties(System.Int32@,System.UInt64@)">
      <summary>Get a thread's dynamic properties.</summary>
      <param name="Priority">[Out] The priority of the thread. The values returned correspond to the values defined for kernel32!GetThreadPriority.</param>
      <param name="AffinityMask">[Out] The affinity mask of the thread. The values returned correspond to the values defined for kernel32!SetThreadAffinityMask.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.IsMainThread">
      <summary>True if this is the main thread of this process. The main thread is the first thread to start.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.IsStoppingEventQueued(System.Boolean)">
      <summary>Indicates if the given thread has a stopping event in the queue. This information is used by the execution manager to decide whether a thread may be slipped.</summary>
      <returns>[Out] True if the thread has a queued stopping event.</returns>
      <param name="IgnoreAsyncBreakEvents">[In] If true, the dispatcher will ignore async break events when it searches for stopping events.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.NativeStartAddress">
      <summary>If available, this is the Win32 start address of this thread (value passed to the CreateThread API). The value will not always be available, for example, it is generally not available in scenarios where the thread was started after the debugger attached, or in minidumps.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.OnBeginFuncEvalExecution(Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags)">
      <summary>OnBeginFuncEvalExecution is called by the base debug monitor on the event thread. This method is called as part of the implementation of IDkmBaseFuncEvalService.BeginFuncEvalExecution, which is called to resume the process for a function evaluation. OnBeginFuncEvalExecution will update the internal state of the DkmProcess object to indicate that a function evaluation is in progress. This will also send a FuncEvalStarting event and it will mark the process as running, so that no operations which require a stopped process will be allowed.</summary>
      <returns>[Out] True if the base debug monitor should resume execution of the target process. This will be true unless both DkmFuncEvalFlags.AllowStoppingEvents and DkmFuncEvalFlags.RunAllThreads are set -and- there are events waiting to be processed.</returns>
      <param name="Flags">[In] Flags affecting how function evaluation requests are performed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.OnContinueExecution">
      <summary>OnContinueExecution is called by the base debug monitor on the event thread. This method is called as part of the implementation of IDkmContinueExecution.ContinueExecution, which is what is used by the IDE to continue the target process. This method is used by the Dispatcher to either dispatch stopping events which could not be processed earlier, or to update the internal state of the DkmProcess object to indicate that the target process is now running. Before marking the process as running, the Dispatcher will send a Continue event. A base debug monitor should expect to be reentrantly called when it is in this method.</summary>
      <returns>[Out] True if the base debug monitor should resume execution of the target process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.OnEmbeddedBreakpointHit(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean)">
      <summary>Raise a EmbeddedBreakpointHit event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="InstructionAddress">[In,Optional] The address where the embedded breakpoint was hit.</param>
      <param name="ShowAsException">[In] If true, the UI will display an exception hit dialog for a breakpoint exception. If false, UI will just break and the DkmInstructionAddress is not used.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.OnInterceptExceptionCompleted(System.UInt64)">
      <summary>Raise a InterceptExceptionCompleted event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller. This method may only be called by the component which created the object.</summary>
      <param name="Cookie">[In] Cookie that was distributed when intercept exception request came in.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.RaiseExecutionControlException(System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.Resume(System.Boolean)">
      <summary>Resume this thread.</summary>
      <returns>[Out,Optional] The previous number of suspensions for this thread minus the ones internal to the debugger before this resume is applied.</returns>
      <param name="InternalSuspension">[In] Pass true if this suspension should be hidden in calls to GetSuspensionCount. This is useful for internal suspensions that should not be reported to the user such as thread slippage suspensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.SetContext(System.Byte[])">
      <summary>Update the context (register values) of a thread.</summary>
      <param name="Context">[In] A CONTEXT structure that contains the context to be set in the specified thread. The value of the ContextFlags member of this structure specifies which parts of a thread's context to set. Some values in the CONTEXT structure that cannot be specified are silently set to the correct value. This includes bits in the CPU status register that specify the privileged processor mode, global enabling bits in the debugging register, and other states that must be controlled by the operating system.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.SetExtendedRegisterValue(System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Sets the value of the extended register in the thread's context.</summary>
      <param name="RegisterIndex">[In] The CV constant of the register to set. For AVX, this can be any of the YMM register enumeration codes. The caller is expected to set the full YMM register (including the portions which are aliased on XMM registers).</param>
      <param name="Value">[In] The value to set the register to. The size of the byte array must match the width of the register being set.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.SetTlsValue(System.Int32,System.UInt64)">
      <summary>Stores a value in the debuggee thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
      <param name="TlsIndex">[In] The TLS index that was allocated when the target process called the TlsAlloc function.</param>
      <param name="Value">[In] The pointer-sized value to store in the thread's TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be ignored.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.Suspend(System.Boolean)">
      <summary>Suspend this thread.</summary>
      <returns>[Out,Optional] The previous number of suspensions for this thread minus the ones internal to the debugger.</returns>
      <param name="InternalSuspension">[In] Pass true if this suspension should be hidden in calls to GetSuspensionCount. This is useful for internal suspensions that should not be reported to the user such as thread slippage suspensions.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.SystemInformation">
      <summary>Contains information about the computer system that this thread is running under. If this thread is running under WOW (32-bit emulation on a 64-bit OS) this information will be for the 32-bit subsystem instead of the 64-bit subsystem.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.SystemPart">
      <summary>[Optional] Describes traits of the thread which are relevant to a full Win32 thread. Currently, this value is required, and all threads will have a 'System' block. In the future, this value may be NULL if the DkmThread represents something other than a full Win32 thread.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread.System" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.TebAddress">
      <summary>Address in the target process, where the Win32 thread environment block is stored. See documentation on the TEB structure in MSDN for more information.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmThread.UniqueId">
      <summary>Guid which uniquely identifies this thread object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.Unload(System.Int32)">
      <summary>ThreadExit is sent by the dispatcher when DkmThread::Unload is invoked by the monitor. This method may only be called by the component which created the object.</summary>
      <param name="ExitCode">[In] 32-bit value that the process returned on exit. This is the same value that would be reported from the kernel32!GetExitCodeThread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmThread.System">
      <summary>Describes traits of the thread that are relevant to a full Win32 thread. Currently, this value is required, and all threads will have a 'System' block. In the future, this value might be NULL if the DkmThread represents something other than a full Win32 thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmThread.System.#ctor(System.Int32)">
      <summary>Initializes a new System value.</summary>
      <param name="Id">[In] Thread ID (TID) assigned by the operating system. While running, this uniquely identifies the thread in a particular DkmProcess.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmThread.System.Id">
      <summary>Thread ID (TID) assigned by the operating system. While running, this uniquely identifies the thread in a particular DkmProcess.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmUnknownInstructionAddress">
      <summary>Represents an address which could not be resolved to a module.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmUnknownInstructionAddress.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction)">
      <summary>Create a new DkmUnknownInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="CPUInstruction">[In,Optional] CPUInstruction provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmUserMessage">
      <summary>Contains information about a message that is to be displayed to the user.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.Connection">
      <summary>Connection used to send the message to the debugger. This will value is usually obtained from DkmProcess.Connection unless the message has to be sent before the DkmProcess is created.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmUserMessage.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind,System.String,Microsoft.VisualStudio.Debugger.MessageBoxFlags,System.Int32)">
      <summary>Create a new DkmUserMessage object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] Connection used to send the message to the debugger. This will value is usually obtained from DkmProcess.Connection unless the message has to be sent before the DkmProcess is created.</param>
      <param name="Process">[In,Optional] Process that this message refers to.</param>
      <param name="OutputKind">[In] Indicates where a DkmUserMessage should be output in the debugger IDE.</param>
      <param name="MessageText">[In] Text to display inside the message box or inside the output window. If an error code is provided, '%1' will be replaced with the text for the error message. For example: 'Unable to stand on my head. %1'.</param>
      <param name="MessageBoxFlags">[In] Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored if OutputKind is not set to 'MessageBox'.</param>
      <param name="ErrorCode">[In] Error code to display a message for. This value should be S_OK (0) if the message is not for an error.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmUserMessage.DisplayPrompt">
      <summary>Displays a message to the user inside the Visual Studio debugger IDE. This function waits for the Visual Studio IDE to complete processing this message. This method may not be called from code that runs as part of UI event processing. Doing so will cause a deadlock. This method requires DkmUserMessage.Process to be non-null.</summary>
      <returns>[Out] Win32 'ID' code from displaying the message box (ex: IDYES). These codes are defined in winuser.h from the Windows SDK.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.ErrorCode">
      <summary>Error code to display a message for. This value should be S_OK (0) if the message is not for an error.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.MessageBoxFlags">
      <summary>Win32 message box flags from winuser.h (ex: MB_OK). These flags are ignored if OutputKind is not set to 'MessageBox'.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.MessageBoxFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.MessageText">
      <summary>Text to display inside the message box or inside the output window. If an error code is provided, '%1' will be replaced with the text for the error message. For example: 'Unable to stand on my head. %1'.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.OutputKind">
      <summary>Indicates where a DkmUserMessage should be output in the debugger IDE.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmUserMessage.Post">
      <summary>Displays a message to the user inside the Visual Studio debugger IDE. This function does not block waiting for the user to dismiss the error message.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmUserMessage.Process">
      <summary>[Optional] Process that this message refers to.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind">
      <summary>Indicates where a DkmUserMessage should be output in the debugger IDE.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.UnfilteredOutputWindowMessage">
      <summary>Message should be displayed in the output window. It will always appear and cannot be filtered by the user.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.ExceptionOutputWindowMessage">
      <summary>Message should be displayed in the output window. If the user has chosen to hide the exception message, the message will not be displayed. Typically, messages of this kind inform the user that an exception has occurred in the debuggee.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.ProgramOutput">
      <summary>Message should be displayed in the output window. If the user has chosen to hide program output, the message will not be displayed. Typically, messages of this kind are sent from the debuggee using APIs such as OutputDebugString() or System.Diagnostics.Debugger.WriteLine().</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.MessageBox">
      <summary>Message should be displayed in a message box.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.JustMyCodePrompt">
      <summary>Message displayed in message box prompts to enable/disable JustMyCode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.StepFilterOutputWindowMessage">
      <summary>Step filtering-related message. Will go to the output window unless the user chooses to turn off step-filtering messages.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmUserMessageOutputKind.StepFilterPrompt">
      <summary>Message box informing the user that we stepped over a property or operator. UI layer will handle the logic of suppressing the dialog box if it was already shown before.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmWorkList">
      <summary>Collection of asynchronous work items which are processed together. Work items are appended by calling any of the asynchronous methods throughout this API. Work items may be appended freely until the work list starts execution. Once execution has begun, additional work may only be appended from the implementation of a work item processing interface, or from a completion routine.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmWorkList.BeginExecution">
      <summary>Start execution of the items in this work list. This API will return immediately and completion routines are fired to return results. Callbacks will fire as results complete (unordered). This method may only be called by the component which created the object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmWorkList.Cancel">
      <summary>Cancel execution of this work list. This API will return after all work on this work queue has stopped (worklist is canceled or completed). The request is ignored if the work list is already canceled. This method may only be called by the component which created the object. Note for components declared as 'Synchronized' in the component configuration: calling this API may implicitly release and then reacquire the lock around your component. Be mindful of possible state changes.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmWorkList.Create(Microsoft.VisualStudio.Debugger.DkmWorkListCompletionRoutine)">
      <summary>Creates a new empty work list object. Callers should append operations to the work list and then start execution ('BeginExecution' or 'Execute'). Once created, a WorkList object will continue to exist until its execution is completed, or until the request is canceled. So callers should make sure that 'Cancel' is called in the case of failure.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="CompletionRoutine">[In,Optional] Optional function which is fired when the work list is complete. This includes firing all completion routines.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmWorkList.Execute">
      <summary>Synchronously execute all items in the work list and return when processing is complete or has been canceled. This includes firing all completion routines. Callbacks will fire as results are complete (unordered). This method may only be called by the component which created the object. This method will throw if execution is already in progress.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmWorkList.IsCanceled">
      <summary>This property allows a component processing a work item to determine whether it is canceled, or for a completion routine to determine whether the operation was canceled.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DkmWorkList.IsCurrentInstanceCanceled">
      <summary>This property allows a component to determine whether the current operation should be canceled. This will return true when it is called from a thread which is currently processing a work list, and when this work list has been canceled. This will throw if called from a completion routine or from a thread that is not currently processing an interface call.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmWorkListCompletionRoutine">
      <summary>Optional function that is fired when the work list is complete. This includes firing all completion routines.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DkmXmm128">
      <summary>DkmXmm128 represents the content of a 128-bit XMM register on x64 systems</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmXmm128.#ctor(System.Double,System.Double)">
      <summary>Create a DkmXmm128 value from double-precision floating point values</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmXmm128.#ctor(System.Single,System.Single,System.Single,System.Single)">
      <summary>Create a DkmXmm128 value from single-precision floating point values</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmXmm128.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Create a DkmXmm128 value from UInt32s</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DkmXmm128.#ctor(System.UInt64,System.UInt64)">
      <summary>Create a DkmXmm128 value from a UInt64 pair</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Double0"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Double1"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Single0"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Single1"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Single2"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.Single3"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u32v0"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u32v1"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u32v2"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u32v3"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u64v0"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.DkmXmm128.u64v1"></member>
    <member name="T:Microsoft.VisualStudio.Debugger.MessageBoxFlags"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.None">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_OK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_OKCANCEL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ABORTRETRYIGNORE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_YESNOCANCEL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_YESNO">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_RETRYCANCEL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_CANCELTRYCONTINUE">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONHAND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONQUESTION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONEXCLAMATION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONASTERISK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_USERICON">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONWARNING">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONERROR">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONINFORMATION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONSTOP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFBUTTON1">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFBUTTON2">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFBUTTON3">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFBUTTON4">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_APPLMODAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_SYSTEMMODAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_TASKMODAL">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_HELP">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_NOFOCUS">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_SETFOREGROUND">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFAULT_DESKTOP_ONLY">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_TOPMOST">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_RIGHT">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_RTLREADING">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_SERVICE_NOTIFICATION">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_SERVICE_NOTIFICATION_NT3X">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_TYPEMASK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_ICONMASK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_DEFMASK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_MODEMASK">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.MessageBoxFlags.MB_MISCMASK">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint">
      <summary>Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location. Each location would have a DkmBoundBreakpoint object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Close">
      <summary>Closes the bound breakpoint. This is performed by breakpoint manager. DkmBoundBreakpoint objects are automatically closed when their associated DkmPendingBreakpoint object is closed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.CompilerId">
      <summary>Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Create(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Called by a breakpoint manager to create a DkmBoundBreakpoint object for each location that a DkmPendingBreakpoint binds to.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="PendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="Target">[In,Optional] The low-level runtime breakpoint which backs this high-level bound breakpoint.</param>
      <param name="SourcePosition">[In,Optional] An optional reference to the document and text position this breakpoint bound to. This should be set unless the bound location does not have source information.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmBoundBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Disable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult})">
      <summary>Disable the bound breakpoint so that it will no longer hit. If the bound breakpoint is already disabled, this operation has no effect. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Enable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult})">
      <summary>Enables the bound breakpoint so that it can be hit. If the bound breakpoint is already enabled, this operation has no effect. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.GetHitCountValue(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult})">
      <summary>Returns the number of times that a bound breakpoint has been hit. This value should not include any times when the breakpoint's instruction was executed, but the breakpoint's condition indicated that the debugger should not stop. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.IsEnabled">
      <summary>Query to determine whether the bound breakpoint is enabled. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] 'true' if the breakpoint is enabled.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.OnHit(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Raise a BoundBreakpointHit event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller. This method may only be called by the component which created the object.</summary>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="HasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread which hit the breakpoint. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception specific logic should apply without making another network round-trip.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.PendingBreakpoint">
      <summary>High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes. Therefore, this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.SetCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition)">
      <summary>Initialize or update or clear the condition on a breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.SetHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition)">
      <summary>Initialize, update or clear the hit count condition on a breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.SetHitCountValue(System.Int32)">
      <summary>Modifies the value for a breakpoint hit count. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="NewValue">[In] New value for the hit count.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.SourcePosition">
      <summary>[Optional] An optional reference to the document and text position this breakpoint bound to. This should be set unless the bound location does not have source information.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.Target">
      <summary>[Optional] The low-level runtime breakpoint which backs this high-level bound breakpoint.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint.UniqueId">
      <summary>Guid which uniquely identifies this bound breakpoint object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition">
      <summary>Conditions under which a breakpoint should fire.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.CompilationFlags">
      <summary>Flags which effect how the condition text should be compiled by the expression evaluator.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.CompilerId">
      <summary>Language of the breakpoint condition. May be Guid.Empty/Guid.Empty to indicate that the language of the stack frame should be used. If present, the vendor id must be defined.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.Create(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags,System.String,System.UInt32)">
      <summary>Create a new DkmBreakpointCondition object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Operator">[In] Indicates how the breakpoint text should be used ('BreakWhenTrue' or 'BreakWhenChanged').</param>
      <param name="CompilerId">[In] Language of the breakpoint condition. May be Guid.Empty/Guid.Empty to indicate that the language of the stack frame should be used. If present, the vendor id must be defined.</param>
      <param name="CompilationFlags">[In] Flags which effect how the condition text should be compiled by the expression evaluator.</param>
      <param name="Text">[In] Source text of the parsed expression.</param>
      <param name="Timeout">[In] This is the time-out that will be used for potentially slow operations such as a function evaluation. This value is in milliseconds.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.Operator">
      <summary>Indicates how the breakpoint text should be used ('BreakWhenTrue' or 'BreakWhenChanged').</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.Text">
      <summary>Source text of the parsed expression.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition.Timeout">
      <summary>This is the time-out that will be used for potentially slow operations such as a function evaluation. This value is in milliseconds.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator">
      <summary>Indicates how the breakpoint text should be used ('BreakWhenTrue' or 'BreakWhenChanged').</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator.BreakWhenTrue">
      <summary>Breakpoint should fire when the expression evaluates to Boolean 'true'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator.BreakWhenChanged">
      <summary>Breakpoint should fire when the value of the input expression changes.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointFileUpdateNotification">
      <summary>Object used to send file update notifications to breakpoint managers.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointFileUpdateNotification.Create(System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
      <summary>Creates a new DkmBreakpointFileUpdateNotification object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FilePaths">[In] File paths of the various files that have been updated.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointFileUpdateNotification.FilePaths">
      <summary>File path of the various files that have been updated.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointFileUpdateNotification.Send(Microsoft.VisualStudio.Debugger.DkmWorkList)">
      <summary>Provides notification that one or more files that contain breakpoints have been updated. This method will append a new work item to the specified work list and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition">
      <summary>Values of the breakpoints hit count that should cause the breakpoint to fire.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition.Create(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator,System.Int32)">
      <summary>Creates a new DkmBreakpointHitCountCondition object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Operator">[In] Operator to use between the current hit count and the condition operand to decide whether the hit count condition has been satisfied.</param>
      <param name="Operand">[In] Value to apply against the current hit when you evaluate this condition.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition.Operand">
      <summary>Value to apply against the current hit when you evaluate this condition.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition.Operator">
      <summary>Operator to use between the current hit count and the condition operand to decide whether the hit count condition has been satisfied.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator">
      <summary>Operator to use between the current hit count and the condition operand to decide whether the hit count condition has been satisfied.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator.Equal">
      <summary>Break when 'CurrentHitCount == Operand'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator.EqualOrGreater">
      <summary>Break when 'CurrentHitCount &gt;= Operand'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountConditionOperator.Modulo">
      <summary>Break when 'CurrentHitCount % Operand == 0'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel">
      <summary>Describes the severity of a message sent from a breakpoint manager back to the source component. This list is sorted in order of priority, as the UI will only display the most important warning. All warnings are ignored if the breakpoint is bound.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel1">
      <summary>This is the message level for the least significant breakpoint warnings. This level is used for catch-all messages such as the 'The specified module has not been loaded' message. This is equivalent to BPET_SEV_LOW in AD7.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel2">
      <summary>This is the message level reserved for third-party components that want to provide their own catch-all errors. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel3">
      <summary>Level 3 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel4">
      <summary>Level 4 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel5">
      <summary>Level 5 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel6">
      <summary>Level 6 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel7">
      <summary>Level 7 warning. This is equivalent to BPET_SEV_GENERAL in AD7. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel8">
      <summary>Level 8 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel9">
      <summary>Level 9 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel10">
      <summary>Level 10 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel11">
      <summary>Level 11 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel12">
      <summary>Level 12 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel13">
      <summary>Level 13 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel14">
      <summary>Level 14 warning. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.WarningLevel15">
      <summary>Highest warning level. This is equivalent to BPET_SEV_HIGH in AD7. Warning levels go from 1 to 16 and in order of increasing severity (1 = Lowest, 15 = Highest).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.LowError">
      <summary>Lowest level breakpoint error.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.StandardError">
      <summary>Typical level for errors binding breakpoints.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel.HighestError">
      <summary>Highest level breakpoint error.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointUnboundReason">
      <summary>Describes the reason for a breakpoint to be unbound.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointUnboundReason.CodeUnload">
      <summary>Breakpoint is being unbound because the target code element has been unloaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointUnboundReason.Rebind">
      <summary>Breakpoint is being unbound because it is being rebound to a different location. (For example, this can occur after an ENC when the breakpoint moves, or if this breakpoint was originally bound with a less than perfect file name match.) Generally, the IDE will discard any persisted information about this breakpoint.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointConditionsAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.ClearConditions call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointConditionsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.ClearConditions.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointConditionsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointConditionsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.ClearHitCountCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult.#ctor(System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeBreakpoint.ClearHitCountCondition.</summary>
      <param name="CurrentHitCount">[In] Number of times that the breakpoint has been hit as of the time that the condition was removed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.ClearHitCountCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult.CurrentHitCount">
      <summary>Number of times that the breakpoint has been hit as of the time that the condition was removed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask">
      <summary>Mask of reasons why the data breakpoint should fire. For example, if 'Write' is set, the breakpoint will fire when the memory location is written.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask.Write">
      <summary>Stop when the CPU writes to the specified address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask.ReadWrite">
      <summary>Stop when the CPU reads or writes to the specified address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask.Execute">
      <summary>Stop when the CPU tries to execute an instruction at the specified address.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmBoundBreakpoint.Disable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmBoundBreakpoint.Disable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmPendingBreakpoint.Disable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmPendingBreakpoint.Disable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableRuntimeBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.Disable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableRuntimeBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.Disable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableRuntimeBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableRuntimeBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmBoundBreakpoint.Enable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmBoundBreakpoint.Enable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmPendingBreakpoint.Enable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmPendingBreakpoint.Enable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableRuntimeBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.Enable call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableRuntimeBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.Enable.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableRuntimeBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableRuntimeBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmPendingBreakpoint.Enroll call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmPendingBreakpoint.Enroll.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition">
      <summary>Represents a condition that is evaluated on the target computer. These objects are used for languages where the expression evaluator is implemented on the target.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Close"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Create(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Evaluate(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.Boolean@,System.String@)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Language">
      <summary>Language used to parse the condition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Parse(System.String@)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.RuntimeBreakpoint">
      <summary>Runtime breakpoint that this condition is used on.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.Source">
      <summary>The breakpoint condition that is evaluated.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition.UniqueId">
      <summary>GUID that uniquely identifies this condition object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult">
      <summary>Result of an asynchronous DkmBoundBreakpoint.GetHitCountValue call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult.#ctor(System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmBoundBreakpoint.GetHitCountValue.</summary>
      <param name="CurrentHitCount">[In] Number of times that the breakpoint has been hit.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmBoundBreakpoint.GetHitCountValue.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult.CurrentHitCount">
      <summary>Number of times that the breakpoint has been hit.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.GetHitCountConditionStatus call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult.#ctor(System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeBreakpoint.GetHitCountConditionStatus.</summary>
      <param name="CurrentHitCount">[In] Number of times that the breakpoint has been hit.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.GetHitCountConditionStatus.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult.CurrentHitCount">
      <summary>Number of times that the breakpoint has been hit.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressBreakpoint">
      <summary>Pending breakpoint that is requested to bind against a particular instruction address. Within the IDE, these breakpoints are set from the Call Stack window, Disassembly window, or by entering a hexadecimal address into the function breakpoint dialog box. Because the DkmInstructionAddress is given as input, these breakpoints can support runtimes that cannot persist their addresses to a string (ex: an interpreter).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressBreakpoint.Create(System.Guid,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new pending breakpoint object. After creation, the returned object will still be disabled and will not be tracked by the breakpoint manager. To complete initialization, the caller should set additional properties on the breakpoint and 'Enable' or 'Enroll' it. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components might be creating instances of a class. For example, source IDs can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="CompilerId">[In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="IsBarrier">[In] Indicates whether this breakpoint is a barrier that should be set on the hardware. This works for GPU debugging.</param>
      <param name="InstructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If the instruction address is unresolved (DkmUnknownInstructionAddress) and contains a CPU instruction, the breakpoint manager will attempt to bind the instruction if a module within that range loads.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPendingAddressBreakpoint instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressBreakpoint.InstructionAddress">
      <summary>Abstract representation of an executable code location (ex: EIP value). If the instruction address is unresolved (DkmUnknownInstructionAddress) and contains a CPU instruction, the breakpoint manager will attempt to bind the instruction if a module within that range loads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressNameBreakpoint">
      <summary>Pending breakpoint that is requested to bind against the code element at a specific instruction address string. Within the IDE, these breakpoints are created when the user sets a breakpoint in the call stack or disassembly window, and then the debugger is asked to rebind the breakpoint in another debug session or in another process in the same debug session.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressNameBreakpoint.AddressName">
      <summary>String representation of the address to bind to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressNameBreakpoint.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new pending breakpoint object. After creation, the returned object will still be disabled and will not be tracked by the breakpoint manager. To complete initialization, the caller should set additional properties on the breakpoint and Enable or Enroll it. The caller is responsible for closing the created object after finishing.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source IDs can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example, an internal breakpoint used for stepping).</param>
      <param name="CompilerId">[In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="IsBarrier">[In] Indicates whether this breakpoint is a barrier that should be set on the hardware. This works for GPU debugging.</param>
      <param name="ModuleName">[In] Name of the module to search for the breakpoint.</param>
      <param name="AddressName">[In] String representation of the address to bind to.</param>
      <param name="FunctionName">[In,Optional] Name of the function that contains the address.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPendingAddressNameBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressNameBreakpoint.FunctionName">
      <summary>[Optional] Name of the function that contains the address.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingAddressNameBreakpoint.ModuleName">
      <summary>Name of the module to search for the breakpoint.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint">
      <summary>High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time. Derived classes: DkmPendingAddressBreakpoint, DkmPendingAddressNameBreakpoint, DkmPendingDataBreakpoint, DkmPendingFileLineBreakpoint, DkmPendingFunctionBreakpoint</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Close">
      <summary>Closes a DkmPendingBreakpoint object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmPendingBreakpoint objects are automatically closed when their associated DkmProcess object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.CompilerId">
      <summary>Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Disable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult})">
      <summary>Disable the pending breakpoint object so that it will no longer fire. If the pending breakpoint is already bound, any bound breakpoints will be implicitly disabled. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Enable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult})">
      <summary>Sets the state of the pending breakpoint so that instances of the breakpoint that bind in the future will get hit. If the pending breakpoint is not yet enrolled, then this method will also enroll the breakpoint. Enrolling a pending breakpoint consists of trying to resolve the breakpoint against any modules which are currently loaded and adding the breakpoint to the list of breakpoints which the breakpoint manager will bind on any module load. If the pending breakpoint is already enrolled, existing bound breakpoints will not automatically get enabled. Bound breakpoints must get enabled separately. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Enroll(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult})">
      <summary>This method will enroll the pending breakpoint without enabling it. The result is a breakpoint which the breakpoint manager will attempt to resolve, but which will not fire. Enrolling a pending breakpoint consists of trying to resolve the breakpoint against any modules which are currently loaded and adding the breakpoint to the list of breakpoints which the breakpoint manager will bind on any module load. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.GetBoundBreakpoints">
      <summary>GetBoundBreakpoints enumerates the DkmBoundBreakpoint elements of this DkmPendingBreakpoint object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.IsBarrier">
      <summary>Indicates if this breakpoint is a barrier that should be set on the hardware, this works for GPU debugging.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.OnBreakpointBound(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint[])">
      <summary>Notification from the breakpoint manager when a breakpoint has been bound. In the case of user-set breakpoints, this notification will be sent to the AD7 AL, and the AD7 AL will fire a IDebugBreakpointBoundEvent2 to the Visual Studio Debugger UI.</summary>
      <param name="BoundBreakpoints">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.OnBreakpointMessage(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel,System.String)">
      <summary>Notification from the breakpoint manager concerning the status of binding the breakpoint.</summary>
      <param name="Level">[In] Describes the severity of a message sent from a breakpoint manager back to the source component. This list is sorted in order of priority, as the UI will only display the most important warning. All warnings are ignored if the breakpoint is bound.</param>
      <param name="Message">[In] Message string to display to the user.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.OnBreakpointUnbound(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint[],Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointUnboundReason)">
      <summary>Notification from the breakpoint manager which indicates that the given breakpoint is being unbound.</summary>
      <param name="BoundBreakpoints">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="Reason">[In] Describes the reason for a breakpoint to be unbound.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.SetCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult})">
      <summary>Initialize, update or clear the language-level condition on all bound breakpoints of this condition breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.SetHitCountCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult})">
      <summary>Initialize, update or clear the hit count condition on all bound breakpoints of this pending breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. Note that the hit count condition acts independently on each bound breakpoint, instead of being aggregated together on the pending breakpoint. For example, if the hit count is configured to stop at hit #2, and the breakpoint to two separate locations, each of which hit the breakpoint one time, the UI will still not have gone into break mode because neither individual bound breakpoint has hit two times. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.TagValue">
      <summary>DkmPendingBreakpoint is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Thread">
      <summary>[Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.UniqueId">
      <summary>Guid which uniquely identifies this pending breakpoint object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag">
      <summary>DkmPendingBreakpoint is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag.FileLineBreakpoint">
      <summary>Object is an instance of 'DkmPendingFileLineBreakpoint'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag.FunctionBreakpoint">
      <summary>Object is an instance of 'DkmPendingFunctionBreakpoint'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag.AddressBreakpoint">
      <summary>Object is an instance of 'DkmPendingAddressBreakpoint'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag.AddressNameBreakpoint">
      <summary>Object is an instance of 'DkmPendingAddressNameBreakpoint'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint.Tag.DataBreakpoint">
      <summary>Object is an instance of 'DkmPendingDataBreakpoint'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingDataBreakpoint">
      <summary>Pending breakpoint which is tied to a data expression instead of a code expression. Data breakpoints fire when the specified element is written to.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingDataBreakpoint.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,System.String,System.Int32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new pending breakpoint object. After creation, the returned object will still be disabled and will not be tracked by the breakpoint manager. To complete initialization, the caller should set additional properties on the breakpoint and 'Enable' or 'Enroll' it. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="CompilerId">[In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="IsBarrier">[In] Indicates if this breakpoint is a barrier that should be set on the hardware, this works for GPU debugging.</param>
      <param name="DataElementLocation">[In] Indicates the location of the data value to watch.</param>
      <param name="Size">[In] Specifies the size of the location, in bytes, to monitor for access. Valid sizes may depend on the target processor (x86, x64, etc) and type of code being debugging. For example, native code uses the CPU's breakpoint registers, and x86-based processor supports sizes of 1, 2, and 4.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPendingDataBreakpoint instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingDataBreakpoint.DataElementLocation">
      <summary>Indicates the location of the data value to watch.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingDataBreakpoint.Size">
      <summary>Specifies the size of the location, in bytes, to monitor for access. Valid sizes may depend on the target processor (x86, x64, etc) and type of code being debugging. For example, native code uses the CPU's breakpoint registers, and x86-based processor supports sizes of 1, 2, and 4.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint">
      <summary>Pending breakpoint which is requested to bind against code elements that point back to a text span in a source file.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new pending breakpoint object. After creation, the returned object will still be disabled and will not be tracked by the breakpoint manager. To complete initialization, the caller should set additional properties on the breakpoint and 'Enable' or 'Enroll' it. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="CompilerId">[In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="IsBarrier">[In] Indicates if this breakpoint is a barrier that should be set on the hardware, this works for GPU debugging.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPendingFileLineBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint.GetCurrentSourcePosition">
      <summary>Returns the current location of a file/line breakpoint. In edit and continue scenarios, the location of the text marker may change in a debug session.</summary>
      <returns>[Out] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint.GetCurrentSourceText">
      <summary>Returns the current text at the location of a file/line breakpoint.</summary>
      <returns>[Out,Optional] The current source text.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFunctionBreakpoint">
      <summary>Pending breakpoint which is requested to bind against code elements that have a specific function name.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFunctionBreakpoint.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,System.String,System.String,System.UInt32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new pending breakpoint object. After creation, the returned object will still be disabled and will not be tracked by the breakpoint manager. To complete initialization, the caller should set additional properties on the breakpoint and 'Enable' or 'Enroll' it. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="CompilerId">[In] Identifies the source language (ex: C#) and compiler vendor (ex: Microsoft) that the breakpoint should bind against. 'LanguageId' may be left as Guid.Empty to indicate that the breakpoint should bind against all languages. 'VendorId' is almost always left as Guid.Empty, which indicates that only the language is known (not the compiler).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="IsBarrier">[In] Indicates if this breakpoint is a barrier that should be set on the hardware, this works for GPU debugging.</param>
      <param name="ModuleName">[In,Optional] Name of the module to search for the breakpoint. If null, all modules will be searched.</param>
      <param name="FunctionName">[In] Name of the function to bind to.</param>
      <param name="LineOffset">[In] The line of the function to bind to.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPendingFunctionBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFunctionBreakpoint.FunctionName">
      <summary>Name of the function to bind to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFunctionBreakpoint.LineOffset">
      <summary>The line of the function to bind to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFunctionBreakpoint.ModuleName">
      <summary>[Optional] Name of the module to search for the breakpoint. If null, all modules will be searched.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRequestBreakpointEventOnModifiedThreadAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRequestBreakpointEventOnModifiedThreadAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRequestBreakpointEventOnModifiedThreadAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRequestBreakpointEventOnModifiedThreadAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint">
      <summary>Low-level breakpoint object which is supported by debug monitors. Derived classes: DkmRuntimeHardwareDataBreakpoint, DkmRuntimeInstructionBreakpoint</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.ClearConditions">
      <summary>Clears any compiled/evaluation condition associated with the specified DkmRuntimeBreakpoint. This method is implicitly called when the DkmRuntimeBreakpoint is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.ClearConditions(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointConditionsAsyncResult})">
      <summary>Clears any compiled/evaluation condition associated with the specified DkmRuntimeBreakpoint. This method is implicitly called when the DkmRuntimeBreakpoint is closed. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.ClearHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,System.Int32@)">
      <summary>Clears the hit count condition on a breakpoint.</summary>
      <param name="Condition">[In] Condition to apply to this breakpoint.</param>
      <param name="CurrentHitCount">[Out] Number of times that the breakpoint has been hit as of the time that the condition was removed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.ClearHitCountCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmClearRuntimeBreakpointHitCountConditionAsyncResult})">
      <summary>Clears the hit count condition on a breakpoint.This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Condition">[In] Condition to apply to this breakpoint.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Close">
      <summary>Closes the breakpoint object instance. This will release any resources associated with this object across all components. If the breakpoint is currently enabled, it will be implicitly disabled.DkmRuntimeBreakpoint objects are automatically closed when their associated DkmRuntimeInstance object is closed. This method can only be called by the component that created the object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Disable">
      <summary>Disables a breakpoint. Disabling a breakpoint is typically implemented by modifying the state of the target process so the breakpoint will no longer fire. For example, removing a previously inserted int3 from the instruction stream. If the breakpoint is already disabled, this operation has no effect. In addition to this method, a breakpoint is implicitly disabled when it is closed. If multiple breakpoints are set on the same instruction, disabling one breakpoint does not affect the other breakpoints set on this instruction. This method can only be called by the component that created the object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Disable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableRuntimeBreakpointAsyncResult})">
      <summary>Disables a breakpoint. Disabling a breakpoint is typically implemented by modifying the state of the target process so the breakpoint will no longer fire.For example, removing a previously inserted int3 from the instruction stream.If the breakpoint is already disabled, this operation has no effect. In addition to this method, a breakpoint is implicitly disabled when it is closed.If multiple breakpoints are set on the same instruction, disabling one breakpoint does not affect the other breakpoints set on this instruction.This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. This method can only be called by the component that created the object.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Enable">
      <summary>Enables a breakpoint. Breakpoints start off disabled. Therefore, this method must be called before the breakpoint can be set. Enabling a breakpoint is typically implemented in the debug monitor by modifying the state of the target process. For example, inserting an int3 instruction into the code stream. If the breakpoint is already enabled, this operation has no effect.Once a breakpoint has been enabled, the debug monitor will raise a RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger condition (ex: target instruction is executed) is met. Multiple DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug monitor will raise a different RuntimeBreakpoint event for each breakpoint object. Similarly, if a step and a breakpoint both complete on the same instruction, the debug monitor will raise both events. This method can only be called by the component that created the object.</summary>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded.-or-E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Enable(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableRuntimeBreakpointAsyncResult})">
      <summary>Enables a breakpoint. Breakpoints start off disabled. Therefore, this method must be called before the breakpoint can be set. Enabling a breakpoint is typically implemented in the debug monitor by modifying the state of the target process. For example, inserting an int3 instruction into the code stream. If the breakpoint is already enabled, this operation has no effect.Once a breakpoint has been enabled, the debug monitor will raise a RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger condition (ex: target instruction is executed) is met. Multiple DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug monitor will raise a different RuntimeBreakpoint event for each breakpoint object. Similarly, if a step and a breakpoint both complete on the same instruction, the debug monitor will raise both events. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. This method can only be called by the component that created the object.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.GetCompiledCondition(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator@)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.GetHitCountConditionStatus(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetRuntimeBreakpointHitCountConditionAsyncResult})">
      <summary>Obtains the current hit count value for a DkmRuntimeBreakpoint that has a hit count condition. This function will fail if the DkmRuntimeBreakpoint does not currently have a hit count condition. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.GetHitCountConditionStatus(System.Int32@)">
      <summary>Obtains the current hit count value for a DkmRuntimeBreakpoint that has a hit count condition. This function will fail if the DkmRuntimeBreakpoint does not currently have a hit count condition.</summary>
      <param name="CurrentHitCount">[Out] Number of times that the breakpoint has been hit.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.OnBreakpointConditionFailed(System.String)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.OnHit(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Raises a RuntimeBreakpoint event. Components that implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="HasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread that hit the breakpoint. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>The breakpoint condition processor does not break on the given thread but on another thread of the same warp. Therefore, the breakpoint condition processor instructs the base debug monitor to re-send the breakpoint event on the other thread.</summary>
      <param name="ModifiedBreakThread">[In] The base debug monitor should re-send breakpoint event on this thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.RequestBreakpointEventOnModifiedThread(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmRequestBreakpointEventOnModifiedThreadAsyncResult})">
      <summary>The breakpoint condition processor does not break on the given thread but on another thread of the same warp. Therefore, the breakpoint condition processor instructs the base debug monitor to re-send the breakpoint event on the other thread. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="ModifiedBreakThread">[In] The base debug monitor should re-send breakpoint event on this thread.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetCompiledConditionPending">
      <summary>This method resembles SetCompiledCondition, but is used when the instruction address is not known up front, such as data breakpoints. In these cases, when the breakpoint is first hit at a particular address, a call will be made to the breakpoint client to obtain a new compiled condition for this address (IDkmBreakpointConditionProcessorClient.GetCompiledCondition). This is used for languages that are evaluated in the IDE process (ex: C++).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetCompiledConditionPending(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionPendingAsyncResult})">
      <summary>This method resembles SetCompiledCondition, but is used when the instruction address is not known up front, such as data breakpoints. In these cases, when the breakpoint is first hit at a particular address, a call will be made to the breakpoint client to obtain a new compiled condition for this address (IDkmBreakpointConditionProcessorClient.GetCompiledCondition). This is used for languages that are evaluated in the IDE process (ex: C++). This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetEvaluationCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,System.String@)">
      <summary>Sets a breakpoint condition that is evaluated on the target computer. This is used for .NET Framework languages.</summary>
      <param name="Condition">[In] Conditions under which a breakpoint should fire.</param>
      <param name="ErrorText">[Out,Optional] If the condition could not be parsed, this indicates why. This value should be null if the compile succeeded.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetEvaluationCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult})">
      <summary>Sets a breakpoint condition that is evaluated on the target computer. This is used for .NET Framework languages. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Condition">[In] Conditions under which a breakpoint should fire.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,System.Int32)">
      <summary>Initializes or updates the hit count condition/value on a breakpoint. If a breakpoint has both a language-level condition and a hit count condition, the language-level condition is applied first. The condition is implicitly removed if the DkmRuntimeBreakpoint is closed.</summary>
      <param name="Condition">[In] Condition to apply to this breakpoint.</param>
      <param name="HitCountValue">[In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD indicates that the current hit count value should be preserved.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SetHitCountCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetRuntimeBreakpointHitCountConditionAsyncResult})">
      <summary>Initializes or updates the hit count condition/value on a breakpoint. If a breakpoint has both a language-level condition and a hit count condition, the language-level condition is applied first. The condition is implicitly removed if the DkmRuntimeBreakpoint is closed. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Condition">[In] Condition to apply to this breakpoint.</param>
      <param name="HitCountValue">[In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD indicates that the current hit count value should be preserved.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.SourceId">
      <summary>Identifies the source of an object. Source IDs are used to enable filtering in scenarios when multiple components might be creating instances of a class. For example, source IDs can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example, an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.TagValue">
      <summary>DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Tag" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Test">
      <summary>Determines whether the given DkmRuntimeBreakpoint could be enabled. This is used in the breakpoints dialog box to validate breakpoints before the dialog box is closed.</summary>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded.-or-E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Test(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmTestRuntimeBreakpointAsyncResult})">
      <summary>Determines whether the given DkmRuntimeBreakpoint could be enabled. This is used in the breakpoints dialog box to validate breakpoints before the dialog box is closed. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Thread">
      <summary>[Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.UniqueId">
      <summary>GUID that uniquely identifies this pending breakpoint object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Tag">
      <summary>DkmRuntimeBreakpoint is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Tag.InstructionBreakpoint">
      <summary>Object is an instance of 'DkmRuntimeInstructionBreakpoint'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint.Tag.NativeDataBreakpoint">
      <summary>Object is an instance of 'DkmRuntimeHardwareDataBreakpoint'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeHardwareDataBreakpoint">
      <summary>Low-level data breakpoint which is set using the hardware breakpoint registers of the CPU.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeHardwareDataBreakpoint.Access">
      <summary>Mask of reasons why the data breakpoint should fire. For example, if 'Write' is set, then the breakpoint will fire when the memory location is written.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeHardwareDataBreakpoint.Address">
      <summary>Address to stop on. This address must be suitably aligned to match the Size parameter (example: if Size is 4, Address must be a multiple of 4).</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeHardwareDataBreakpoint.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.Guid,Microsoft.VisualStudio.Debugger.DkmThread,System.UInt64,Microsoft.VisualStudio.Debugger.Breakpoints.DkmDataAccessStopMask,System.Int32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmRuntimeHardwareDataBreakpoint object. After creation, the breakpoint is in the disabled state, and must be explicitly enabled. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="Address">[In] Address to stop on. This address must be suitably aligned to match the Size parameter (example: if Size is 4, Address must be a multiple of 4).</param>
      <param name="Access">[In] Mask of reasons why the data breakpoint should fire. For example, if 'Write' is set, then the breakpoint will fire when the memory location is written.</param>
      <param name="Size">[In] Specifies the size of the location, in bytes, to monitor for access. On an x86-based processor, this parameter can be 1, 2, or 4. However, if Access is DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based processor, this parameter can be 1, 2, 4, or 8. However, if Access equals Access is DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor, this parameter can be any power of 2, from 1 to 0x80000000.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmRuntimeHardwareDataBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeHardwareDataBreakpoint.Size">
      <summary>Specifies the size of the location, in bytes, to monitor for access. On an x86-based processor, this parameter can be 1, 2, or 4. However, if Access is DkmDataAccessStopMask.Execute, Size must be 1. On an x64-based processor, this parameter can be 1, 2, 4, or 8. However, if Access equals Access is DkmDataAccessStopMask.Execute, Size must be 1. On an Itanium-based processor, this parameter can be any power of 2, from 1 to 0x80000000.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint">
      <summary>Low-level breakpoint which is set on an instruction address.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.Create(System.Guid,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmRuntimeInstructionBreakpoint object. After creation, the breakpoint is in the disabled state, and must be explicitly enabled. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="Thread">[In,Optional] Thread on which this breakpoint should fire. If null, the breakpoint will fire on all threads.</param>
      <param name="InstructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="IsBarrier">[In] Indicates if this instruction breakpoint works as a barrier, used in GPU debugging scenarios.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmRuntimeInstructionBreakpoint instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.InstructionAddress">
      <summary>Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.IsBarrier">
      <summary>Indicates if this instruction breakpoint works as a barrier, used in GPU debugging scenarios.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.SetCompiledCondition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionAsyncResult})">
      <summary>This sets an associated compiled condition on the specified runtime instruction breakpoint. The breakpoint condition processor will then test the condition whenever it is hit. This is used for languages which are evaluated in the IDE process (ex: C++). This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="ConditionOperator">[In] Operator to use when you evaluate the condition.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.SetCompiledCondition(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator)">
      <summary>This sets an associated compiled condition on the specified runtime instruction breakpoint. The breakpoint condition processor will then test the condition whenever it is hit. This is used for languages which are evaluated in the IDE process (ex: C++).</summary>
      <param name="CompiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="ConditionOperator">[In] Operator to use when you evaluate the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice">
      <summary>Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryClearConditionOnTargetDeviceAsyncResult})">
      <summary>Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryPushConditionToTargetDeviceAsyncResult})">
      <summary>This tries to push the associated condition on the specified runtime instruction breakpoint to the target. This is useful for GPU debugging because testing the condition on the target (GPU hardware or VSD3D ref) is much more efficient than doing it in the debugger. Once this method succeeds, breakpoint event will only be received by the debugger when the condition tests to be true on the debuggee; if it fails, the debugger can still test the condition. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="ConditionOperator">[In] Operator to use when you evaluate the condition.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator)">
      <summary>This tries to push the associated condition on the specified runtime instruction breakpoint to the target. This is useful for GPU debugging because testing the condition on the target (GPU hardware or VSD3D ref) is much more efficient than doing it in the debugger. Once this method succeeds, breakpoint event will only be received by the debugger when the condition tests to be true on the debuggee; if it fails, the debugger can still test the condition.</summary>
      <param name="CompiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="ConditionOperator">[In] Operator to use when you evaluate the condition.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstructionBreakpoint.SetCompiledCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstructionBreakpoint.SetCompiledCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionPendingAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.SetCompiledConditionPending call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionPendingAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.SetCompiledConditionPending.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionPendingAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetCompiledConditionPendingAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.SetEvaluationCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult.#ctor(System.String)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeBreakpoint.SetEvaluationCondition.</summary>
      <param name="ErrorText">[In,Optional] If the condition could not be parsed, this indicates why. This value should be null if the compile succeeded.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.SetEvaluationCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetEvaluationConditionAsyncResult.ErrorText">
      <summary>[Optional] If the condition could not be parsed, this indicates why. This value should be null if the compile succeeded.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult">
      <summary>Result of an asynchronous DkmPendingBreakpoint.SetCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmPendingBreakpoint.SetCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult">
      <summary>Result of an asynchronous DkmPendingBreakpoint.SetHitCountCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmPendingBreakpoint.SetHitCountCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetRuntimeBreakpointHitCountConditionAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.SetHitCountCondition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetRuntimeBreakpointHitCountConditionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.SetHitCountCondition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetRuntimeBreakpointHitCountConditionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetRuntimeBreakpointHitCountConditionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTestRuntimeBreakpointAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeBreakpoint.Test call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTestRuntimeBreakpointAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeBreakpoint.Test.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTestRuntimeBreakpointAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTestRuntimeBreakpointAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryClearConditionOnTargetDeviceAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryClearConditionOnTargetDeviceAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstructionBreakpoint.TryClearConditionOnTargetDevice.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryClearConditionOnTargetDeviceAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryClearConditionOnTargetDeviceAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryPushConditionToTargetDeviceAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryPushConditionToTargetDeviceAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstructionBreakpoint.TryPushConditionToTargetDevice.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryPushConditionToTargetDeviceAsyncResult" />.</returns>
      <param name="exception">[In] Exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Breakpoints.DkmTryPushConditionToTargetDeviceAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmArmFrameRegisters">
      <summary>Arm registers.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmArmFrameRegisters.Pc">
      <summary>Instruction pointer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmArmFrameRegisters.Sp">
      <summary>Stack pointer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterList">
      <summary>Holds the list of implementations of the IDkmCallStackFilter interface that may be called by a component. This object is used to call these stack frame filters.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterList.Count">
      <summary>Returns the number of implementations of the IDkmCallStackFilter interface that may be called through this object.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterList.Create">
      <summary>Creates a new DkmCallStackFilterList object instance. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterList.FilterNextFrame(System.Int32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame)">
      <summary>Provides a filter with the next stack frame. A filter can just pass this frame on through, it can suppress the frame by returning nothing, or it can provide its own set of annotated frames. The stack provider will ignore NotImplementedException (E_NOTIMPL). All other errors will truncate the stack walk. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmStackWalkFrame[] represents a frame on a call stack that has been walked but that might not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
      <param name="ImplementationIndex">[In] Zero-based index into the collection of {0} implementations that the caller wants to be invoked. This should be less than the 'Count' property.</param>
      <param name="StackContext">[In] DkmStackContext objects are created by components that want to request the stack from the stack provider. A component must close the context after they have completed the stack walk. To obtain the stack, a component should create this object and then call GetNextFrames.</param>
      <param name="Input">[In,Optional] The next frame to examine. After all frames have been filtered, this function will be called one last time with a null input frame.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions">
      <summary>Options for how the call stack should be filtered.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions.None">
      <summary>No filter option flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions.FilterHiddenFrames">
      <summary>Removes frames from the call stack that are in hidden code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions.FilterNonuserCode">
      <summary>Removes non-user code from the call stack.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions">
      <summary>Collection of settings that affect how the stack provider formats a DkmStackFrame.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags,System.UInt32,System.UInt32)">
      <summary>Initializes a new DkmFrameFormatOptions value.</summary>
      <param name="ArgumentFlags">[In] Flags that indicate what information is requested for a variable.</param>
      <param name="FrameNameFormat">[In] Flags that affect how the stack provider create DkmStackFrame objects.</param>
      <param name="EvaluationFlags">[In] Flags that effect how an input expression should be parsed, compiled, or displayed.</param>
      <param name="Timeout">[In] The time-out that will be used for potentially slow operations, such as function evaluations. This value is in milliseconds.</param>
      <param name="Radix">[In] The radix to use when formatting integer data. Currently supported values are '16' and '10'.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.ArgumentFlags">
      <summary>Flags that indicate what information is requested for a variable.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.EvaluationFlags">
      <summary>Flags that affect how an input expression should be parsed, compiled, or displayed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.FrameNameFormat">
      <summary>Flags that affect how the stack provider create DkmStackFrame objects.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.Radix">
      <summary>The radix to use when formatting integer data. Currently supported values are '16' and '10'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions.Timeout">
      <summary>The time-out that will be used for potentially slow operations, such as function evaluations. This value is in milliseconds.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions">
      <summary>Flags which affect how the stack provider create DkmStackFrame objects.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.None">
      <summary>No additional information is included in the frame name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.Module">
      <summary>Include the module name in the frame name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.Lines">
      <summary>Include the number of lines at the end of the frame name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.ByteOffsets">
      <summary>Include the byte offset at the end of the frame name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.ReturnType">
      <summary>Include the return type in the frame name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.ReturnTypeField">
      <summary>Include the return type field in the frame object.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameNameFormatOptions.DocumentPositionField">
      <summary>Include the document position in the frame object.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters">
      <summary>DkmFrameRegisters represents the registers of a stack frame. Derived classes: DkmArmFrameRegisters, DkmX64FrameRegisters, DkmX86FrameRegisters</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.GetInstructionPointer">
      <summary>Returns the processor-independent instruction pointer which is stored in this frame register object.</summary>
      <returns>[Out] Instruction pointer value which is stored in the specified registers structure (ex: EIP on x86, RIP on x64).</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.GetRegisterValue(System.UInt32,System.Byte[])">
      <summary>A helper function for searching the array of unwound register values for a DkmStackWalkFrame. If the register was not unwound, a failed HRESULT is returned.</summary>
      <returns>[Out] The caller allocated buffer that receives the contents of the requested register.</returns>
      <param name="Id">[In] The unique constant for the requested register. Normally, this is a cvconst value such as CV_REG_EIP.</param>
      <param name="Buffer">[In,Out] A buffer that receives the value of the register.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.GetRegisterValue(System.UInt32,System.Void*,System.Int32)">
      <summary>A helper function for searching the array of unwound register values for a DkmStackWalkFrame. If the register was not unwound, a failed HRESULT is returned.</summary>
      <returns>[Out] The caller allocated buffer that receives the contents of the requested register.</returns>
      <param name="Id">[In] The unique constant for the requested register. Normally, this is a cvconst value such as CV_REG_EIP.</param>
      <param name="Buffer">[In,Out] A buffer that receives the value of the register.</param>
      <param name="Size">[In] The size of the value in bytes.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.GetStackPointer">
      <summary>Returns the processor-independent stack pointer which is stored in this frame register object.</summary>
      <returns>[Out] Stack pointer value which is stored in the specified registers structure (ex: ESP on x86, RSP on x64).</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.TagValue">
      <summary>DkmFrameRegisters is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.UnwoundRegisters">
      <summary>The register set that was actually unwound by the unwinder.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.Tag">
      <summary>DkmFrameRegisters is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.Tag.ArmRegisters">
      <summary>Object is an instance of 'DkmArmFrameRegisters'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.Tag.X86Registers">
      <summary>Object is an instance of 'DkmX86FrameRegisters'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters.Tag.X64Registers">
      <summary>Object is an instance of 'DkmX64FrameRegisters'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult">
      <summary>Result of an asynchronous DkmThread.GetCurrentLocation call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult.#ctor(System.String)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmThread.GetCurrentLocation.</summary>
      <param name="LocationName">[In] The name of the current location.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmThread.GetCurrentLocation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult.LocationName">
      <summary>The name of the current location.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult">
      <summary>Result of an asynchronous DkmStackContext.GetNextFrames call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmStackContext.GetNextFrames.</summary>
      <param name="Frames">[In] DkmStackFrame[] represents a frame on the call stack after filtering and translation.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmStackContext.GetNextFrames.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult.Frames">
      <summary>[Optional] DkmStackFrame[] represents a frame on the call stack after filtering and translation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult">
      <summary>Result of an asynchronous DkmStackWalkContext.HeuristicWalkFrames call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame[],Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmStackWalkContext.HeuristicWalkFrames.</summary>
      <param name="Frames">[In] DkmStackWalkFrame[] represents a frame on a call stack that has been walked but might not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="NextRegisters">[In,Optional] Indicates the registers of the next frame (the caller of 'FrameObject'). This will be null if the stack is complete or if the EndStackPointer was reached.</param>
      <param name="EndOfStack">[In] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmStackWalkContext.HeuristicWalkFrames.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.EndOfStack">
      <summary>Returns true if the monitor reached the end of the stack.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.Frames">
      <summary>DkmStackWalkFrame[] represents a frame on a call stack that has been walked but might not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult.NextRegisters">
      <summary>[Optional] Indicates the registers of the next frame (the caller of 'FrameObject'). This will be null if the stack is complete or if the EndStackPointer was reached.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext">
      <summary>Allows the various components DkmSymbolStackWalkContext with this call stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.Close"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.Initialize(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.ThreadContext">
      <summary>[Optional] The initial Win32 CONTEXT to use when it performs the stack walk. This value is typically 'null' but can be set in order to view another call stack (ex: .cxr).</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.UniqueId">
      <summary>GUID that uniquely identifies this DkmMonitorStackWalkContext.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.UpdatePosition(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext.WalkNextFrame">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult">
      <summary>Return result from IDkmMonitorStackWalk.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult.#ctor(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkStatus,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.UInt64)"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult.FrameObject">
      <summary>[Optional] FrameObject is required when 'Status' is 'FrameFound'. This object contains information about the stack frame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult.NextRegisters">
      <summary>[Optional] NextRegisters is required when 'Status' is 'FrameFound'. NextRegisters is used to inform other walkers where the previous walker left off. If an walker does not return the next registers then the walk will be truncated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult.NextStackPointer">
      <summary>NextStackPointer is required when 'Status' is 'OutsideOfRuntime'. This is used by the stack frame merger to advance the stack walk when frames are encountered which cannot be monitor walked (walking requires symbols). The stack frame merger will not invoke the walker again until it has progressed to this stack pointer value, and the walker should update its state so that the next call to 'WalkNextFrame' retrieves the frame at this position.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkResult.Status">
      <summary>Status code for the walk.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult">
      <summary>Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame[],System.Boolean,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext,System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache.</summary>
      <param name="Frames">[In] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</param>
      <param name="EndOfStack">[In] Returns true if the monitor reached the end of the stack.</param>
      <param name="ActualStackHash">[In,Optional] The actual hash of the call stack. This may be NULL for runtimes that do not support call stack hashing.</param>
      <param name="ActualStackWalkContext">[In] The DkmStackWalkContext object that can used later to continue the walk. If the cache is valid, this is the original context. If the cache is invalid, this will be a new DkmStackWalkContext object.</param>
      <param name="IsCacheValid">[In] True if the cache was valid, false if not.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.ActualStackHash">
      <summary>[Optional] The actual hash of the call stack. This may be NULL for runtimes that do not support call stack hashing.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.ActualStackWalkContext">
      <summary>The DkmStackWalkContext object that can used later to continue the walk. If the cache is valid, this is the original context. If the cache is invalid, this will be a new DkmStackWalkContext object.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.EndOfStack">
      <summary>Returns true if the monitor reached the end of the stack.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.Frames">
      <summary>Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult.IsCacheValid">
      <summary>True if the cache was valid, false if not.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult">
      <summary>Result of an asynchronous DkmStackWalkContext.RuntimeWalkNextFrames call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame[],System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmStackWalkContext.RuntimeWalkNextFrames.</summary>
      <param name="Frames">[In] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</param>
      <param name="EndOfStack">[In] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmStackWalkContext.RuntimeWalkNextFrames.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult.EndOfStack">
      <summary>Returns true if the monitor reached the end of the stack.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult.Frames">
      <summary>Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext">
      <summary>DkmStackContext objects are created by components that want to request the stack from the stack provider. A component must close the context after they have completed the stack walk. To obtain the stack a component should create this object and then call GetNextFrames.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.Close">
      <summary>Closes a DkmStackContext object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmStackContext objects are automatically closed when their associated DkmInspectionSession object is closed. This method may only be called by the component which created the object. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmStackContext object instance. The caller is responsible for closing the created object after they have finished. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionSession">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="FilterOptions">[In] Options for how the call stack should be filtered.</param>
      <param name="FormatOptions">[In] Collection of settings that affect how the stack provider formats a DkmStackFrame.</param>
      <param name="ThreadContext">[In,Optional] The initial thread context to use when it performs the stack walk.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmStackContext instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.FilterOptions">
      <summary>Options for how the call stack should be filtered.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmCallStackFilterOptions" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.FormatOptions">
      <summary>Collection of settings that affect how the stack provider formats a DkmStackFrame.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.GetNextFrames(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult})">
      <summary>Obtain the next frames from the call stack. If this is the first call on a particular DkmStackContext then this will return the first frames. This method is the recommended way to obtain the call stack because the stack provider maintains a cache of the physical cache. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="RequestSize">[In] RequestSize is the number of frames that the caller wants returned. The implementation of GetNextFrames may return fewer frames in the case that stack does not contain that many frames. Negative values, or request to read more than MaxFrames (currently 5,000) will be capped to MaxFrames.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.InspectionSession">
      <summary>DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.ThreadContext">
      <summary>[Optional] The initial thread context to use when it performs the stack walk. This value is typically 'null' but can be set in order to view another call stack (ex: .cxr).</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext.UniqueId">
      <summary>Guid which uniquely identifies this DkmStackContext.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame">
      <summary>Represents a frame on the call stack after filtering and translation.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.CompilerId">
      <summary>LanguageId/VendorId for the compiler that produced the code for this stack frame. If this is unknown (ex: no symbols loaded for this module), both values will be Guid.Empty. Otherwise, both values should be non-zero.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.Create(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,System.String,System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition)">
      <summary>Creates a new DkmStackFrame object instance. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Frame">[In] Represents a frame on the call stack after filtering and translation.</param>
      <param name="Options">[In] Collection of settings that affect how the stack provider formats a DkmStackFrame.</param>
      <param name="CompilerId">[In] LanguageId/VendorId for the compiler that produced the code for this stack frame. If this is unknown (ex: no symbols loaded for this module), both values will be Guid.Empty. Otherwise, both values should be non-zero.</param>
      <param name="FrameName">[In] Name of the stack frame. DkmStackFrame.FormatOptions determines the format of the function name.</param>
      <param name="ReturnType">[In,Optional] Name of the stack frame's return type. This is only provided when DkmFrameNameFormatOptions.ReturnTypeField is set.</param>
      <param name="SourcePosition">[In,Optional] Source code location for this stack frame. This is only provided when DkmFrameNameFormatOptions.DocumentPositionField is set.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.ExtractFromAD7Object(Microsoft.VisualStudio.Debugger.Interop.IDebugStackFrame2)">
      <summary>Obtains a DkmStackFrame from an AD7 stack frame object. This API is used by Visual Studio packages or addins that want to access the Concord API to obtain more detailed information about the debugged process. This API will only function correctly from the main thread of Visual Studio.</summary>
      <returns>[Optional] DkmStackFrame that backs the AD7 object. NULL in the case that this stack frame is not backed by a Concord frame (ex: frame from the SQL debug engine).</returns>
      <param name="frameObject">AD7 stack frame object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.ExtractFromDTEObject(EnvDTE.StackFrame)">
      <summary>Obtains a DkmStackFrame from a DTE (debugger automation) stack frame object. This API is used by Visual Studio packages or addins that want to access the Concord API to obtain more detailed information about the debugged process. The automation object is often obtained from the 'OnContextChanged' automation event or from the Debugger.CurrentStackFrame property. This API will only function correctly from the main thread of Visual Studio.</summary>
      <returns>[Optional] DkmStackFrame that backs the AD7 object. NULL in the case that this stack frame is not backed by a Concord frame (ex: frame from the SQL debug engine).</returns>
      <param name="frameObject">AD7 stack frame object.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.FrameName">
      <summary>Name of the stack frame. DkmStackFrame.FormatOptions determines the format of the function name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.GetEffectiveAddresses(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>A method that calculates and returns the effective addresses for the requested address. The effective address is the calculated address that an instruction operand represents. For instance, on x86, an instruction may be of the form dwordptr [esp-12]. The effective address of this operand will be the result of subtracting 12 from esp. The number of operands and effective addresses are architecture specific. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The collection of effective addresses for this instruction, if any.</returns>
      <param name="Address">[In] The address for which to obtain the effective addresses.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.Options">
      <summary>Collection of settings that affect how the stack provider formats a DkmStackFrame.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.ReturnType">
      <summary>[Optional] Name of the stack frame's return type. This is only provided when DkmFrameNameFormatOptions.ReturnTypeField is set.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame.SourcePosition">
      <summary>[Optional] Source code location for this stack frame. This is only provided when DkmFrameNameFormatOptions.DocumentPositionField is set.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash">
      <summary>Information used to determine whether a cache of a call stack is valid.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash.Create(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Creates a new DkmStackHash object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Thread">[In] The thread the cache applies to.</param>
      <param name="StackMemoryRange">[In] The range of the thread's stack.</param>
      <param name="RegisterHash">[In] MD5 hash of the thread's CONTEXT structure at the point in which the cache was created.</param>
      <param name="MemoryHash">[In] MD5 hash of the stack memory of the thread at the point in which the cache was created.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash.MemoryHash">
      <summary>MD5 hash of the stack memory of the thread at the point in which the cache was created.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash.RegisterHash">
      <summary>MD5 hash of the thread's CONTEXT structure at the point in which the cache was created.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash.StackMemoryRange">
      <summary>The range of the thread's stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash.Thread">
      <summary>The thread the cache applies to.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange">
      <summary>The limit/base address for the memory that contains a thread's stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.#ctor(System.UInt64,System.UInt64)">
      <summary>Initialize a new DkmStackMemoryRange value.</summary>
      <param name="StackBase">[In] The address where this thread's stack began. Since stacks grow down in Windows, the value will be larger than the limit.</param>
      <param name="StackLimit">[In] The minimum address that is allocated in the stack's range.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.CompareTo(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.Equals(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>True if the two elements are equal.</returns>
      <param name="other">Value to compare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_Equality(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_GreaterThan(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_Inequality(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_LessThan(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange,Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange)">
      <summary>Compares two elements of the DkmStackMemoryRange structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.StackBase">
      <summary>The address where this thread's stack began. Since stacks grow down in Windows, the value will be larger than the limit.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackMemoryRange.StackLimit">
      <summary>The minimum address that is allocated in the stack's range.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext">
      <summary>DkmStackWalkContext allows the various components which walk, filter, or examine call stacks to store private data which is associated with this call stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.Close">
      <summary>Closes a DkmStackWalkContext object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmStackWalkContext objects are automatically closed when their associated DkmThread object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.Create(Microsoft.VisualStudio.Debugger.DkmThread,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmStackWalkContext object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="ThreadContext">[In,Optional] The initial Win32 CONTEXT to use when it performs the stack walk.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmStackWalkContext instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.FindSymbolStackWalkContext(System.Guid)">
      <summary>Find a DkmSymbolStackWalkContext element within this DkmStackWalkContext. If no element that has the given input key is present, FindSymbolStackWalkContext will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="SymbolProviderId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.HeuristicWalkFrames(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32,System.UInt64,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters@,System.Boolean@)">
      <summary>Attempt to walk through a region of the stack using a heuristic stack walk algorithm. This is used in x86 when no symbols are available. It is not implemented on other platforms as PDATA allows for walking of all frames.</summary>
      <returns>[Out] DkmStackWalkFrame[] represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
      <param name="Registers">[In] Registers to attempt to walk from.</param>
      <param name="RequestSize">[In] RequestSize is the number of frames that the caller wants returned. The implementation of HeuristicWalkFrames may return fewer frames in the case that stack does not contain that many frames.</param>
      <param name="EndStackPointer">[In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the no end stack pointer is present.</param>
      <param name="NextRegisters">[Out,Optional] NextRegisters indicates the registers of the next frame (the caller of 'FrameObject'). This will be null if the stack is complete, or if the EndStackPointer was reached.</param>
      <param name="EndOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.HeuristicWalkFrames(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32,System.UInt64,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmHeuristicWalkFramesAsyncResult})">
      <summary>Attempt to walk through a region of the stack using a heuristic stack walk algorithm. This is used in x86 when no symbols are available. It is not implemented on other platforms as PDATA allows for walking of all frames. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Registers">[In] Registers to attempt to walk from.</param>
      <param name="RequestSize">[In] RequestSize is the number of frames that the caller wants returned. The implementation of HeuristicWalkFrames may return fewer frames in the case that stack does not contain that many frames.</param>
      <param name="EndStackPointer">[In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the no end stack pointer is present.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.RuntimeWalkNextFrames(Microsoft.VisualStudio.Debugger.DkmWorkList,System.UInt32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAsyncResult})">
      <summary>Attempt to walk the stack without the use of symbols. This will call into various components that know how to walk parts of the stack (ex: CLR frames will be walked by the CLR debug monitor). An 'unresolved' frame will be left for parts of the stack which cannot be walked without information stored in the symbol file. These 'unresolved' frames have no InstructionAddress or Description. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="RequestSizeHint">[In] RequestSizeHint is a hint as to the number of frame that the caller needs.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.RuntimeWalkNextFrames(System.UInt32,System.Boolean@)">
      <summary>Attempt to walk the stack without the use of symbols. This will call into various components that know how to walk parts of the stack (ex: CLR frames will be walked by the CLR debug monitor). An 'unresolved' frame will be left for parts of the stack which cannot be walked without information stored in the symbol file. These 'unresolved' frames have no InstructionAddress or Description.</summary>
      <returns>[Out] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</returns>
      <param name="RequestSizeHint">[In] RequestSizeHint is a hint as to the number of frame that the caller needs.</param>
      <param name="EndOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache(Microsoft.VisualStudio.Debugger.DkmWorkList,System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmRuntimeWalkNextFramesAndCheckCacheAsyncResult})">
      <summary>Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call stack is still valid. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="RequestSizeHintIfCacheIsValid">[In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value. A request size hint of 0 means not to do any stack walking at all if the cache is valid.</param>
      <param name="RequestSizeHintIfCacheIsInvalid">[In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value.</param>
      <param name="CachedHash">[In,Optional] Cached call stack hash, will not walk the stack if cache is still valid. This parameter is optional. If null, we will still compute the actual hash and do the stack walk, but will skip the comparing of the actual hash against the cached hash to suppress the stack walk.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.RuntimeWalkNextFramesAndCheckCache(System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash,System.Boolean@,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash@,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext@,System.Boolean@)">
      <summary>Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call stack is still valid.</summary>
      <returns>[Out] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</returns>
      <param name="RequestSizeHintIfCacheIsValid">[In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value. A request size hint of 0 means not to do any stack walking at all if the cache is valid.</param>
      <param name="RequestSizeHintIfCacheIsInvalid">[In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value.</param>
      <param name="CachedHash">[In,Optional] Cached call stack hash, will not walk the stack if cache is still valid. This parameter is optional. If null, we will still compute the actual hash and do the stack walk, but will skip the comparing of the actual hash against the cached hash to suppress the stack walk.</param>
      <param name="EndOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
      <param name="ActualStackHash">[Out,Optional] The actual hash of the call stack. This may be NULL for runtimes that do not support call stack hashing.</param>
      <param name="ActualStackWalkContext">[Out] The DkmStackWalkContext object that can used later to continue the walk. If the cache is valid, this is the original context. If the cache is invalid, this will be a new DkmStackWalkContext object.</param>
      <param name="IsCacheValid">[Out] True if the cache was valid, false if not.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.ThreadContext">
      <summary>[Optional] The initial Win32 CONTEXT to use when it performs the stack walk. This value is typically 'null' but can be set in order to view another call stack (ex: .cxr).</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext.UniqueId">
      <summary>Guid which uniquely identifies this DkmStackWalkContext.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame">
      <summary>DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead. Derived classes: DkmStackFrame</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Annotations">
      <summary>[Optional] A read only collection of stack frame annotations. These are defined by an unwinder and are specific to that unwinder. An example usage is how inline frame data is passed from inline stack filter to the formatter.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.CanSetNextStatement(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>CanSetNextStatement determines whether it is possible to move the IP of a stack frame. The stack frame is always the leaf stack frame on a particular thread. This API may only be implemented in the engine process. The Result out parameter should be S_OK or the value of a failed HRESULT that the UI can map to an error message. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The error code to return to the UI. This should be S_OK or the value of a failed HRESULT that the UI can map to an error message.</returns>
      <param name="NewStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Create(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.UInt64,System.UInt32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags,System.String,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameAnnotation})">
      <summary>Create a new DkmStackWalkFrame object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Thread">[In] The thread that this stack frame is on.</param>
      <param name="InstructionAddress">[In,Optional] The instruction of this frame. This can be omitted for annotated frames.</param>
      <param name="FrameBase">[In] Base stack pointer of the frame. This is used by the SDM to sort the frame, and it is used by the stack merger to assess walk progress. Therefore, this value is required even for annotated frames. This value should only be invalid in the case that the debuggee's stack is corrupted.</param>
      <param name="FrameSize">[In] Number of bytes of the stack consumed by this frame. This value will be zero for annotated frames, or if the value is unknown.</param>
      <param name="Flags">[In] Flags properties of a DkmStackWalkFrame.</param>
      <param name="Description">[In,Optional] Description of the frame which will be displayed in the call stack window. This should be provided for annotated frames.</param>
      <param name="Registers">[In,Optional] Registers of the walked frame. These should be provided for non-annotated frames.</param>
      <param name="Annotations">[In,Optional] A read only collection of stack frame annotations. These are defined by an unwinder and are specific to that unwinder. An example usage is how inline frame data is passed from inline stack filter to the formatter.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Description">
      <summary>[Optional] Description of the frame which will be displayed in the call stack window. This should be provided for annotated frames.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Flags">
      <summary>Flags properties of a DkmStackWalkFrame.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Format(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions)">
      <summary>Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step of what the stack provider does during GetNextFrames. This method can be used to format a frame in a different way than was originally performed by the stack provider in GetNextFrames. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmStackFrame represents a frame on the call stack after filtering and translation.</returns>
      <param name="InspectionSession">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="Options">[In] Collection of settings that affect how the stack provider formats a DkmStackFrame.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.FrameBase">
      <summary>Base stack pointer of the frame. This is used by the SDM to sort the frame, and it is used by the stack merger to assess walk progress. Therefore, this value is required even for annotated frames. This value should only be invalid in the case that the debuggee's stack is corrupted.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.FrameSize">
      <summary>Number of bytes of the stack consumed by this frame. This value will be zero for annotated frames, or if the value is unknown.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.GetInspectionInterface(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Guid)">
      <summary>GetInspectionInterface is used to obtain a ICorDebugFrame or other implementation-specific interfaces which a component can use to deeply inspect the stack frame. The returned interface may ONLY be used to inspect the target process, and should NEVER be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior. Location constraint: This API must be called from the same process where the target runtime implements stack walk. For managed debugging, this means that when you debug 64-bit or remote processes, this API must be called from a debug monitor component.</summary>
      <returns>[Out] Returned frame interface. This may be cast to the interface pointer corresponding to 'InterfaceID'.</returns>
      <param name="Session">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="InterfaceID">[In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain the CorDebug frame interface for a managed frame. Other debug monitors or stack walkers may provide their own interface.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.GetInstructionSymbol">
      <summary>Return a DkmInstructionSymbol for a stack frame. If the stack frame has no instruction address (annotated frame) or the instruction address has no associated DkmModule, then GetInstructionSymbol will return null (S_FALSE in native code).</summary>
      <returns>[Out,Optional] DkmInstructionSymbol represents a method in the target process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.GetUnwindAddress(Microsoft.VisualStudio.Debugger.DkmInstructionAddress@)">
      <summary>Returns the address that represents the location if an exception were to be intercepted to this frame.</summary>
      <param name="NewAddress">[Out] Possible new address if an exception was unwound to this frame.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.InstructionAddress">
      <summary>[Optional] The instruction of this frame. This can be omitted for annotated frames.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.InterceptCurrentException(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags,System.UInt64@)">
      <summary>InterceptCurrentException is used to unwind to this frame as if there was an exception handler at that frame.</summary>
      <param name="InterceptAction">[In] Specifies exception interception actions.</param>
      <param name="Cookie">[Out] Cookie that represents this intercept request. The value is returned when an exception interception completed event is sent.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.ModuleInstance">
      <summary>[Optional] The module that contains this address. Addresses without a module cannot have symbols (even for custom addresses). CLR addresses will always have a module. Native addresses will not have a module if either the CPU jumped to an invalid address (ex: NULL), or if the CPU is executing dynamically-emitted code.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmModuleInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.OnSetNextStatementCompleted(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>OnSetNextStatementCompleted is a general purpose method to allow for components to clear state after a set next statement completed. The DkmStackWalkFrame will be the frame before the SetNextStatement call.</summary>
      <param name="NewStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Registers">
      <summary>[Optional] Registers of the walked frame. These should be provided for non-annotated frames.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.RuntimeInstance">
      <summary>[Optional] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.SetNextStatement(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>SetNextStatement moves the IP of a stack frame. The stack frame is always the leaf stack frame on a particular thread.</summary>
      <param name="NewStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame.Thread">
      <summary>The thread that this stack frame is on.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameAnnotation">
      <summary>A Guid / Value pair set by a frame filter or unwinder. Can be used to pass custom flags about the frame from one component to another.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameAnnotation.Create(System.Guid,System.UInt64)">
      <summary>Create a new DkmStackWalkFrameAnnotation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In] The Guid that uniquely identifies this annotation flag. This is specific to the creator of the stack walk frame.</param>
      <param name="Value">[In] The value of this annotation. The meaning of this value is specific to the creator.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameAnnotation.Id">
      <summary>The Guid that uniquely identifies this annotation flag. This is specific to the creator of the stack walk frame.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameAnnotation.Value">
      <summary>The value of this annotation. The meaning of this value is specific to the creator.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags">
      <summary>Flags properties of a DkmStackWalkFrame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.None">
      <summary>No flags are set on this stack frame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.TopFrame">
      <summary>Stack frame is the top frame in the call stack. This is used to detect the top frame when the full stack frame collection is not available. Unwinders should set this on top frame when doing an unwind. Unwinders must decide whether it makes sense for logical frames (such as inline frames) that appear above physical frame should also be marked. Doing so would cause multiple frames being marked as a top frame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.Hidden">
      <summary>Stack frame is located within hidden code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.NonuserCode">
      <summary>Stack frame is located within non-user code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.InlineOptimized">
      <summary>Stack frame is an inlined optimized frame, not a physical frame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.MaxFramesExceeded">
      <summary>Stack frame is used to indicate that the maximum number of walked stack frame has been exceeded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.ExceptionUnwindTarget">
      <summary>Stack frame can be unwound to after an exception has been thrown.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrameFlags.FuncEvalFrame">
      <summary>Stack frame is an annotated frame that shows what is being evaluated example 'Evaluation of: xyz'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkStatus">
      <summary>Return status from a monitor walk operation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkStatus.FrameFound">
      <summary>The walker found a frame within its runtime.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkStatus.OutsideOfRuntime">
      <summary>The walker determined that the current frame is outside its runtime. Lower priority walkers will be given a chance to walk.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkStatus.EndOfStack">
      <summary>The walker determined that the end of the stack has been reached. StackWalking should stop.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext">
      <summary>Allows the various symbol providers that walk the call stack to store private data that is associated with this call stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.Close">
      <summary>Closes a DkmSymbolStackWalkContext object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmSymbolStackWalkContext objects are automatically closed when their associated DkmStackWalkContext object is closed. This method may only be called by the component that created the object. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.Create(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext,System.Guid,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmSymbolStackWalkContext object instance. The caller is responsible for closing the created object after finishing. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="StackWalkContext">[In] DkmStackWalkContext allows the various components that walk, filter, or examine call stacks to store private data that is associated with this call stack.</param>
      <param name="SymbolProviderId">[In] </param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmSymbolStackWalkContext instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.Initialize(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)">
      <summary>Initialize is invoked on each walker exactly one time at the start of the walk process. This gives each walker a chance to initialize any state. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Registers">[In] Registers to attempt to walk from.</param>
      <param name="StackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.StackWalkContext">
      <summary>DkmStackWalkContext allows the various components that walk, filter, or examine call stacks to store private data that is associated with this call stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.SymbolProviderId">
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.ThreadContext">
      <summary>[Optional] The initial Win32 CONTEXT to use when it performs the stack walk. This value is typically 'null' but can be set in order to view another call stack (ex: .cxr).</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.UpdatePosition(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>UpdatePosition is invoked by the stack provider after another walker has walked one or more frames, so this walker must be updated before invoking WalkNextFrame. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Registers">[In] Registers to attempt to walk from.</param>
      <param name="StackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
      <param name="InstructionAddress">[In] Address from the instruction pointer in the registers. This will be either a 'Native' or 'Unresolved' address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext.WalkNextFrame(Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters@)">
      <summary>Walk the next stack frame from the call stack. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] Created frame object for the current registers.</returns>
      <param name="NextRegisters">[Out,Optional] NextRegisters indicates the registers of the next frame (the caller of 'FrameObject'). It is used to invoke UpdatePosition if the next frame is owned by a different symbol provider. A null NextRegisters value indicates that the returned frame is the last frame of the call stack. Therefore the stack walk will end here.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister">
      <summary>Represents a register of a stack frame that was unwound by an unwinder.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister.Create(System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmUnwoundRegister object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Identifier">[In] the code-view register constant for this value.</param>
      <param name="Value">[In] A byte array representing the contents of the register. The size of the register in bytes can be found by the length of this array.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister.Identifier">
      <summary>The code-view register constant for this value.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmUnwoundRegister.Value">
      <summary>A byte array representing the contents of the register. The size of the register in bytes can be found by the length of this array.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmX64FrameRegisters">
      <summary>x64 registers. For leaf frames, all registers will be available. For non-leaf frames, only the registers actually unwound by the unwinder will be available. Unwound registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Rip and Rsp are provided because they are always unwound and accessed often.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmX64FrameRegisters.Rip">
      <summary>Instruction pointer.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmX64FrameRegisters.Rsp">
      <summary>Stack pointer.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CallStack.DkmX86FrameRegisters">
      <summary>x86 registers. For leaf frames, all registers will be available. For non-leaf frames, only the registers actually unwound by the unwinder will be available. Unwound registers can be found in the DkmFrameRegisters' UnwoundRegisters collection. Eip and Esp are provided because they are always unwound and accessed often.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmX86FrameRegisters.Eip">
      <summary>Instruction pointer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmX86FrameRegisters.Esp">
      <summary>Stack pointer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CallStack.DkmX86FrameRegisters.VFrame">
      <summary>VFrame virtual register.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain">
      <summary>Represents a CLR application domain inside a process that is being debugged.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.Close">
      <summary>Closes a DkmClrAppDomain object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmClrAppDomain objects are automatically closed when their associated DkmClrRuntimeInstance object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.Create(System.Int32,Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>This method is called by the managed debug monitor to create a DkmClrAppDomain object. It is called on the event thread in response to the target process creating an AppDomain. The caller is responsible for closing the created object after they are finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In] Id of the underlying CLR application domain. While running, this uniquely identifies the application domain in a particular DkmRuntimeInstance.</param>
      <param name="RuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="Name">[In] AppDomain name.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmClrAppDomain instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.FindClrModuleInstance(System.Guid)">
      <summary>Finds a DkmClrModuleInstance element within this DkmClrAppDomain. If no element that has the given input key is present, FindClrModuleInstance will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Mvid">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.GetClrModuleInstances">
      <summary>Enumerates the DkmClrModuleInstance elements of this DkmClrAppDomain object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.GetCorObject">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugAppDomain" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.Id">
      <summary>Id of the underlying CLR application domain. While running, this uniquely identifies the application domain in a particular DkmRuntimeInstance.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.Name">
      <summary>AppDomain name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes. Therefore this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.RuntimeInstance">
      <summary>Represents a CLR instance running in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain.UniqueId">
      <summary>GIUD that uniquely identifies this application domain object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation">
      <summary>In an async method, all the possible locations the debugger could have stopped.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.None">
      <summary>Not an async method.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.FirstStatement">
      <summary>First statement of an async method. We step out synchronously here.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.NonAwaitStatement">
      <summary>In an async method but not at an await expression.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.BeforeYield">
      <summary>In an await statement and before a yield point.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.AtYield">
      <summary>At a yield point.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation.LastStatement">
      <summary>Last statement of the method. Step into or step over should become step out.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo">
      <summary>Contains the offsets for an await expression.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo.#ctor(System.UInt32,System.UInt32,System.UInt32)">
      <summary>Initialize a new DkmClrAwaitExpressionInfo value.</summary>
      <param name="YieldOffset">[In] The offset at which the expression yields.</param>
      <param name="ResumeOffset">[In] The offset at which the expression resumes.</param>
      <param name="ResumeMethodToken">[In] The method in which the expression resumes.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo.ResumeMethodToken">
      <summary>The method in which the expression resumes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo.ResumeOffset">
      <summary>The offset at which the expression resumes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo.YieldOffset">
      <summary>The offset at which the expression yields.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId">
      <summary>Indicates which version of the CLR debugging services (mscordbi.dll or other implementation of the ICorDebug API) should be used when you debug this process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.OutOfProcessPipeline">
      <summary>Debug an application that uses .NET Framework version 4 or a later version out-of-process CLR execution pipeline.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.DesktopClrV4">
      <summary>Debug an application that is running under .NET Framework version 4 or a later version. Note that this value can use either the in-process (helper-thread based) or out-of-process implementation of ICorDebug.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.DesktopClrV2">
      <summary>Debug an application that is running under .NET Framework version 2.0 or earlier.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.SilverlightWindows">
      <summary>Debug an application that is running on Silverlight on a Windows operating system.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.SilverlightMac">
      <summary>Debug an application that is running on Silverlight on a Mac operating system.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.DevicesClr">
      <summary>Debug an application that is running under the .NET Framework on a Windows CE–based device.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrDebuggingServicesId.CoreSystemClr">
      <summary>Debug an application that is running under the CoreCLR on a Windows Phone device.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrExceptionInformation">
      <summary>Provides information about a CLR exception that was raised in the target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrExceptionInformation.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,System.String,Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress)">
      <summary>Creates a new DkmClrExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="Name">[In] Type name of the exception. Example: 'System.NullReferenceException'.</param>
      <param name="InstructionAddress">[In,Optional] Address where the exception occurred. This will be null if the CLR exception occurred inside the runtime when no managed code was on the stack.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrExceptionInformation.InstructionAddress">
      <summary>[Optional] Address where the exception occurred. This will be null if the CLR exception occurred inside the runtime when no managed code was on the stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrExceptionInformation.Name">
      <summary>Type name of the exception. Example: 'System.NullReferenceException'.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus">
      <summary>Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the loaded module. This indicates which type of binary was loaded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus.NativeBinary">
      <summary>The binary contains no CLR code. This value is used for binaries without an IMAGE_COR20_HEADER.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus.MixedModeBinary">
      <summary>The binary contains both managed and native code. This value is used for binaries with an IMAGE_COR20_HEADER and without the COMIMAGE_FLAGS_ILONLY flag.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus.ManagedOnlyBinary">
      <summary>The binary contains only managed code. This value is used for binaries with an IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_ILONLY flag.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus.NGenBinary">
      <summary>The binary contains only pre-JITed managed code. This value is used for binaries with an IMAGE_COR20_HEADER and with the COMIMAGE_FLAGS_IL_LIBRARY flag.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress">
      <summary>DkmClrInstructionAddress is used for addresses in managed code.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.Create(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction)">
      <summary>Creates a new DkmClrInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="ModuleInstance">[In] The module that contains the InstructionPointer.</param>
      <param name="MethodId">[In] The version/token pair for this method.</param>
      <param name="NativeOffset">[In] A byte offset relative to the start of the method where the CPU instruction can be found. For the purpose of this value, the method should be treated as a contiguous block of bytes. If the method has not been Just-in-time compiled or if this address is being used to refer purely to the MSIL address, <paramref name="NativeOffset" /> will be set to UInt32.MaxValue.</param>
      <param name="ILOffset">[In] The index of the MSIL instruction that this address represents.</param>
      <param name="CPUInstruction">[In,Optional] Provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses, depending on how the address object was created.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.GetCorFunction">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugFunction" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.GetNativeCodeMap(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame)">
      <summary>Provides the map of how this method was compiled to native code.</summary>
      <returns>[Out] Structure to define the MSIL instruction mapping for one or more native instructions.</returns>
      <param name="StackFrame">[In,Optional] Stack frame where this address is from. This is necessary for CLR 2 support. This argument will be ignored for CLR 4.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.GetNonUserCodeMetadataFlags">
      <summary>Obtains non-user code status for this instruction address.</summary>
      <returns>[Out] The non-user code status for this instruction address.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.ILOffset">
      <summary>ILOffset is the index of the MSIL instruction that this address represents. This value may be set to UInt32.MaxValue for an instruction that is in the given method, but not tied to a particular MSIL instruction. This is used for CLR native instructions that do not map to an MSIL instruction. (ICorDebugILFrame::GetIP indicates MAPPING_UNMAPPED_ADDRESS).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.MethodId">
      <summary>The version/token pair for this method.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.ModuleInstance">
      <summary>The module that contains the InstructionPointer.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.NativeOffset">
      <summary>NativeOffset is a byte offset relative to the start of the method where the CPU instruction can be found. For the purpose of this value, the method should be treated as a contiguous block of bytes. If the method has not been Just-in-time compiled or if this address is being used to refer purely to the MSIL address, NativeOffset will be set to UInt32.MaxValue.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress.RuntimeInstance">
      <summary>Represents a CLR instance running in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,System.UInt32)">
      <summary>Create a new DkmClrInstructionSymbol object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or at one time was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="MethodId">[In] The version/token pair for this method.</param>
      <param name="ILOffset">[In] ILOffset is the index of the IL instruction that this symbol represents.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement">
      <summary>Gets the yield and resume points contained in the statement surrounding the given instruction symbol. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] An array of the yield and resume points for the statement.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult})">
      <summary>Gets the yield and resume points contained in the statement surrounding the given instruction symbol. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAsyncKickoffMethod">
      <summary>If the current method is an async method then return the kickoff method for this async method. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] Kickoff method token.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAsyncKickoffMethod(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult})">
      <summary>If the current method is an async method then return the kickoff method for this async method. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAsyncMethodCatchHandlerILOffset(System.UInt32@)">
      <summary>Gets the optional starting IL offset of an async method's generated catch handler. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] True if async method has a catch handler IL offset in the PDB.</returns>
      <param name="CatchHandlerILOffset">[Out] The catch handler's starting IL offset.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAsyncMethodLocation">
      <summary>Gets the location of the instruction symbol in its method. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] The location of the given instruction.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetAsyncMethodLocation(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult})">
      <summary>Gets the location of the instruction symbol in its method. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetNextAwaitExpressionInfo">
      <summary>Get the yield and resume information about the next await expression. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] Next await expression information.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.GetNextAwaitExpressionInfo(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult})">
      <summary>Get the yield and resume information about the next await expression. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.ILOffset">
      <summary>ILOffset is the index of the IL instruction that this symbol represents. This value may be set to UInt32.MaxValue for an instruction that is in the given method, but not tied to a particular instruction. This is used for CLR native instructions that do not map to an IL instruction.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol.MethodId">
      <summary>The version/token pair for this method.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant">
      <summary>Represents a local constant defined in a method scope. These are defined by using ISymUnmanagedWriter::DefineConstant or ISymUnmanagedWriter2::DefineConstant2.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.AdditionalData">
      <summary>[Optional] Additional data that is used by the symbol provider to identify the constant. Meaning is implementation specific.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,System.Object,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmClrLocalConstant object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] Module where this local constant is defined.</param>
      <param name="Name">[In] Name of the constant.</param>
      <param name="Value">[In,Optional] Value assigned to this constant. No value implies VT_EMPTY.</param>
      <param name="AdditionalData">[In,Optional] Additional data that is used by the symbol provider to identify the constant. Meaning is implementation specific.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.GetSignature">
      <summary>Provides the COR_SIGNATURE for a local constant. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] The COR_SIGNATURE for the constant, which defines the type of this constant.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.Module">
      <summary>Module where this local constant is defined.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.Name">
      <summary>Name of the constant.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant.Value">
      <summary>[Optional] Value assigned to this constant. No value implies VT_EMPTY.</summary>
      <returns>Returns <see cref="T:System.Object" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable">
      <summary>Represents a local variable defined in a method scope. These are defined by using ISymUnmanagedWriter::DefineLocalVariable or ISymUnmanagedWriter2::DefineLocalVariable2.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.AdditionalData">
      <summary>[Optional] Additional data that is used by the symbol provider to identify the local variable. Meaning is implementation specific.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.Attributes">
      <summary>Variable attributes defined in CorSymVarFlag. Currently, the only defined bit is VAR_IS_COMP_GEN (0x1).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,System.UInt32,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmClrLocalVariable object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] Module where this local variable is defined.</param>
      <param name="Name">[In] Name of the local variable.</param>
      <param name="Attributes">[In] Variable attributes defined in CorSymVarFlag. Currently, the only defined bit is VAR_IS_COMP_GEN (0x1).</param>
      <param name="Slot">[In] The local slot used by the IL in stloc/ldloc instructions.</param>
      <param name="AdditionalData">[In,Optional] Additional data that is used by the symbol provider to identify the local variable. Meaning is implementation specific.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.GetSignature">
      <summary>Provides the COR_SIGNATURE for a local Variable. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] The COR_SIGNATURE for the Variable, which defines the type of this Variable.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.Module">
      <summary>Module where this local variable is defined.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.Name">
      <summary>Name of the local variable.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable.Slot">
      <summary>The local slot used by the IL in stloc/ldloc instructions.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId">
      <summary>DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.#ctor(System.Int32,System.UInt32)">
      <summary>Initialize a new DkmClrMethodId value.</summary>
      <param name="Token">[In] The method definition metadata token of the method that contains this symbol.</param>
      <param name="Version">[In] Version is a 1-based index. This will be '1' for methods that have not been edited through Edit-and-continue. For edited methods, the version indicates the ENC apply of this method. Thus if the user does 5 ENC applies and a particular method is only edited in the fifth apply, then there are two method ids for this method, and they have Version=1 and Version=5.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.CompareTo(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.Equals(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId structure.</summary>
      <returns>'true' if the two elements are equal.</returns>
      <param name="other">Value to comare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_Equality(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_GreaterThan(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_Inequality(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_LessThan(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Compare two elements of the DkmClrMethodId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.Token">
      <summary>The method definition metadata token of the method that contains this symbol.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId.Version">
      <summary>Version is a 1-based index. This will be '1' for methods that have not been edited through Edit-and-continue. For edited methods, the version indicates the ENC apply of this method. Thus if the user does 5 ENC applies and a particular method is only edited in the fifth apply, then there are two method ids for this method, and they have Version=1 and Version=5. The debugger must deal with old versions of the method because they will continue to be on the call stack until control is unwound. The debugger can also hit breakpoints or stop for exceptions within exception handling regions of old methods. In other words, if the user sets a breakpoint in the catch block of a non-leaf method, the debugger has to set that breakpoint in the old version of the method. In scenarios such as function breakpoint binding, the value '0' may be used to indicate the current version of the method.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData">
      <summary>Describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmILRange,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant},System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
      <summary>Initializes a new DkmClrMethodScopeData value.</summary>
      <param name="ILRange">[In] The MSIL range of this scope.</param>
      <param name="ParentScope">[In] The index of the parent scope in the array of scopes for the method.</param>
      <param name="LocalVariables">[In] Local variables defined in the PDB.</param>
      <param name="LocalConstants">[In] Local constants defined in the PDB.</param>
      <param name="Namespaces">[In] Namespaces that are being 'used' within this scope.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.ILRange">
      <summary>The MSIL range of this scope.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.LocalConstants">
      <summary>Local constants defined in the PDB.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.LocalVariables">
      <summary>Local variables defined in the PDB.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.Namespaces">
      <summary>Namespaces that are being 'used' within this scope.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData.ParentScope">
      <summary>The index of the parent scope in the array of scopes for the method.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags">
      <summary>Flags that indicate traits of a DkmModuleInstance that has been loaded by the CLR.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags.None">
      <summary>No CLR module flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags.Dynamic">
      <summary>Module is a dynamic module (types can be added to the module as it runs).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags.RuntimeModule">
      <summary>Set if the module is the core module for the managed runtime (mscorlib.dll).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags.FullyTrusted">
      <summary>Corresponds to the value returned by ICorDebugAssembly2::IsFullyTrusted. If the CLR the process is running on does not implement ICorDebugAssembly2, or if ICorDebugAssembly2::IsFullyTrusted fails, this flag will not be set.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance">
      <summary>Used for modules which are loaded into the Common Language Runtime.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.AppDomain">
      <summary>DkmClrAppDomain represents a CLR application domain inside a process that is being debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.ClrFlags">
      <summary>Flags that indicate traits of a DkmModuleInstance that has been loaded by the CLR.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.Create(System.String,System.String,System.UInt64,Microsoft.VisualStudio.Debugger.DkmModuleVersion,Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId,Microsoft.VisualStudio.Debugger.DkmModuleFlags,Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout,System.UInt64,System.UInt32,System.UInt32,System.String,Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,System.Guid,Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleFlags,Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain,System.Boolean,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmClrModuleInstance object instance. This method will send a ModuleInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] Short representation of the module name. For file-based modules, this is the file name and extension (ex: kernel32.dll).</param>
      <param name="FullName">[In] Fully qualified module name. For file-based modules, this is the full path of the module (ex: c:\windows\system32\kernel32.dll.)</param>
      <param name="TimeDateStamp">[In] Date/time of when the loaded module was built. This value is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a FILETIME value, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
      <param name="Version">[In,Optional] File version information.</param>
      <param name="SymbolFileId">[In,Optional] Contains information that is required to locate symbols for this module. On Win32, this information is contained in the IMAGE_DEBUG_DIRECTORY.</param>
      <param name="Flags">[In] Flags that indicate traits of a DkmModuleInstance.</param>
      <param name="MemoryLayout">[In] Enumeration that indicates how a module is laid out in memory.</param>
      <param name="BaseAddress">[In,Optional] The starting memory address of where the module loaded. This value will be zero if the module did not load in a contiguous block of memory.</param>
      <param name="LoadOrder">[In] The integer count of the number of module instances that have loaded, up to and including this module. Each runtime instance keeps track of its own load order count.</param>
      <param name="Size">[In,Optional] The number of bytes in the module's memory region. This value will be zero if the module did not load in a contiguous block of memory.</param>
      <param name="LoadContext">[In] String description of the context under which this module has been loaded.</param>
      <param name="RuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="Mvid">[In] Module Version Identifier from the loaded module. This is a unique value that is embedded in an .exe/.dll by linkers/compilers when the .dll/.exe is built. A new value is generated every time the .dll/.exe is compiled.</param>
      <param name="ClrFlags">[In] Flags that indicate traits of a DkmModuleInstance that has been loaded by the CLR.</param>
      <param name="AppDomain">[In] DkmClrAppDomain represents a CLR application domain inside a process that is being debugged.</param>
      <param name="IsDisabled">[In] Indicates whether this module instance has been disabled. Disabled modules are largely ignored by the debugger. For native modules, the address range of the disabled module is treated as if it where unmapped. For CLR modules, any frames from these modules are hidden from the call stack.</param>
      <param name="Module">[In,Optional] The symbol handler's representation of a module (DkmModule) that is associated with this module instance. This value is at first null, and is assigned if symbols are associated with this module instance.</param>
      <param name="MinidumpInfo">[In,Optional] Used to convey additional information about modules in a DkmProcess for a minidump.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmClrModuleInstance instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.GetCorObject">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.GetMetaDataBytes">
      <summary>Obtains the bytes of the CLR metadata from a given module. These bytes can then be passed to IMetaDataDispenser::OpenScope to decode the metadata.</summary>
      <returns>[Out] The raw metadata for this module.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.GetMetaDataImport">
      <summary>Obtains the CLR metadata from a given module. See IMetaDataImport documentation on MSDN for more information about metadata.</summary>
      <returns>[Out] The IMetaDataImport interface for this managed module instance.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.Mvid">
      <summary>Module Version Identifier from the loaded module. This is a unique value that is embedded in an .exe/.dll by linkers/compilers when the .dll/.exe is built. A new value is generated every time the .dll/.exe is compiled.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance.RuntimeInstance">
      <summary>Represents a CLR instance running in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry">
      <summary>Structure to define the MSIL instruction mapping for one or more native instructions.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry.#ctor(System.UInt64,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Initializes a new DkmClrNativeCodeMapEntry value.</summary>
      <param name="NativeAddress">[In] Starting address for this block of native code.</param>
      <param name="NativeSize">[In] Number of bytes of native instruction memory described by this DkmClrNativeCodeMapEntry.</param>
      <param name="NativeOffset">[In] Offset of the native instruction.</param>
      <param name="ILOffset">[In] Offset of the MSIL instruction. '-1' is used to indicate that the native instructions cannot be mapped to an MSIL instruction. '-2' is used to indicate that the native instructions are part of the prolog. '-3' is used to indicate that the naive instructions are part of the epilog.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry.ILOffset">
      <summary>Offset of the MSIL instruction. '-1' is used to indicate that the native instructions cannot be mapped to an MSIL instruction. '-2' is used to indicate that the native instructions are part of the prolog. '-3' is used to indicate that the naive instructions are part of the epilog.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry.NativeAddress">
      <summary>Starting address for this block of native code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry.NativeOffset">
      <summary>Offset of the native instruction.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmClrNativeCodeMapEntry.NativeSize">
      <summary>Number of bytes of native instruction memory described by this DkmClrNativeCodeMapEntry.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance">
      <summary>Represents a CLR instance running in a target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.CanDoFuncEval(Microsoft.VisualStudio.Debugger.DkmThread)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.ContinueForFuncEval(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,System.UInt32,System.String)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.CORSystemDirectory">
      <summary>[Optional] The installation directory of the common language runtime (CLR) instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is the same path returned from the GetCORSystemDirectory API, and it always includes the trailing slash.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,System.String,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new runtime instance object from a debug monitor. This method must be called from the event thread when a debug monitor detects that a new runtime instance has loaded (for example, when the corresponding runtime dll loads in the target process). This method will send a RuntimeInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes. Therefore this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="Id">[In] Identifies a DkmRuntimeInstance object in a process.</param>
      <param name="CORSystemDirectory">[In,Optional] The installation directory of the common language runtime (CLR) instance. For example 'c:\Windows\Microsoft.NET\Framework\v2.0.50727\'. This is the same path returned from the GetCORSystemDirectory API, and it always includes the trailing slash.</param>
      <param name="RuntimeVersion">[In,Optional] The version string for the CLR instance (ex: 'v2.0.50727').</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmClrRuntimeInstance instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.FindAppDomain(System.Int32)">
      <summary>Find a DkmClrAppDomain element within this DkmClrRuntimeInstance. If no element that has the given input key is present, FindAppDomain will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Id">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.FindClrModuleInstance(Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.GetAppDomains">
      <summary>GetAppDomains enumerates the DkmClrAppDomain elements of this DkmClrRuntimeInstance object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.GetCorProcess">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.GetCorThread(Microsoft.VisualStudio.Debugger.DkmThread)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.CorDebugInterop.ICorDebugThread" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.OnFuncEvalQuickAbortDllLoaded(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.PrepareForFuncEvalQuickAbort(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean@,System.UInt64@)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance.RuntimeVersion">
      <summary>[Optional] The version string for the CLR instance (ex: 'v2.0.50727').</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult">
      <summary>Result of an asynchronous DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement.</summary>
      <param name="AsyncExpressionInfo">[In] An array of the yield and resume points for the statement.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult.AsyncExpressionInfo">
      <summary>An array of the yield and resume points for the statement.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmClrInstructionSymbol.GetAllAwaitExpressionInfoForStatement.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAllAwaitExpressionInfoForStatementAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult">
      <summary>Result of an asynchronous DkmClrInstructionSymbol.GetAsyncKickoffMethod call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult.#ctor(System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmClrInstructionSymbol.GetAsyncKickoffMethod.</summary>
      <param name="KickoffMethodToken">[In] Kickoff method token.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmClrInstructionSymbol.GetAsyncKickoffMethod.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncKickoffMethodAsyncResult.KickoffMethodToken">
      <summary>Kickoff method token.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult">
      <summary>Result of an asynchronous DkmClrInstructionSymbol.GetAsyncMethodLocation call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmClrInstructionSymbol.GetAsyncMethodLocation.</summary>
      <param name="AsyncLocation">[In] The location of the given instruction.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult.AsyncLocation">
      <summary>The location of the given instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmClrInstructionSymbol.GetAsyncMethodLocation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetAsyncMethodLocationAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult">
      <summary>Result of an asynchronous DkmClrInstructionSymbol.GetNextAwaitExpressionInfo call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmClrInstructionSymbol.GetNextAwaitExpressionInfo.</summary>
      <param name="AwaitExpressionInfo">[In] Next await expression information.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult.AwaitExpressionInfo">
      <summary>Next await expression information.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmClrInstructionSymbol.GetNextAwaitExpressionInfo.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Clr.DkmGetNextAwaitExpressionInfoAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmILRange">
      <summary>Describes a range of IL instructions in a method.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Clr.DkmILRange.#ctor(System.UInt32,System.UInt32)">
      <summary>Initialize a new DkmILRange value.</summary>
      <param name="StartOffset">[In] Beginning IL offset the range.</param>
      <param name="EndOffset">[In] Ending IL offset of the range.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmILRange.EndOffset">
      <summary>Ending IL offset of the range.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmILRange.StartOffset">
      <summary>Beginning IL offset the range.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags">
      <summary>Indicates whether non user code is because of DebuggerHidden, DebuggerStepThrough, or DebuggerNonUserCode attribute marked on method or class or marked hidden due 0xfeefee sequence point.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags.None">
      <summary>Method or class is not marked with non user code related attributes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags.HiddenAttribute">
      <summary>Method or class is marked with the DebuggerHidden attribute or marked hidden because of 0xfeefee sequence point.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags.StepThroughAttribute">
      <summary>Method or class is marked with the DebuggerStepThrough attribute.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags.NonUserCodeAttribute">
      <summary>Method or class is marked with the DebuggerNonUserCode attribute.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmActiveScriptDebugMonitor">
      <summary>Interface implemented by the Script DM to provide direct access to the target script runtime. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmActiveScriptDebugMonitor.AbortExecutionOnResume(Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance)">
      <summary>API that is called from break mode which tells the script runtime that execution should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an MSHTML v10+ target execution environment.</summary>
      <param name="scriptRuntimeInstance">[In] Represents a script-based execution environment executing in a target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmActiveScriptDebugMonitor.GetRemoteDebugApplication(Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance)">
      <summary>Allows a caller to obtain a direct access to the IRemoteDebugApplication interface from the target process. This can be used to load .dlls into the target application or inspect the target application. Note that this should never be used for execution control, breakpoints, or evaluation.</summary>
      <returns>[Out] Debug application interface from the debugged process.</returns>
      <param name="scriptRuntimeInstance">[In] Represents a script-based execution environment executing in a target process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAfterSetNextStatementNotification">
      <summary>IDkmAfterSetNextStatementNotification implemented by components that want to receive notification after a set next statement completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAfterSetNextStatementNotification.OnSetNextStatementCompleted(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>OnSetNextStatementCompleted is a general purpose method to allow components to clear state after a set next statement completed. The DkmStackWalkFrame will be the frame before the SetNextStatement call.</summary>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="newStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAppPackageInfo">
      <summary>Interface to enumerate App Package information on the local or remote system. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAppPackageInfo.EnumPackages(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection)">
      <summary>Enumerates installed and launchable (App Packages with applications) App Packages.</summary>
      <returns>[Out] Array of App Packages found.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreak">
      <summary>This interface contains the API for performing an async-break on the debuggee process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreak.AsyncBreak(Microsoft.VisualStudio.Debugger.DkmProcess,System.Boolean)">
      <summary>This method will tell the debug monitors to asynchronously break execution of the debuggee process. An AsyncBreakComplete event is sent after the operation is completed.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="stopImmediately">[In] If this is set to true, implementers should immediately enter break instead of trying to find a thread inside the process that is executing code.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreakCompleteNotification">
      <summary>IDkmAsyncBreakCompleteNotification is implemented by components that want to listen for the AsyncBreakComplete event. IDkmAsyncBreakCompleteNotification is invoked after all implementations of IDkmAsyncBreakCompleteReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent by a debug monitor after a request to async break the process has completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreakCompleteNotification.OnAsyncBreakComplete(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnAsyncBreakComplete is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="status">[In] Indicates the type of async-break that occurred.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreakCompleteReceived">
      <summary>IDkmAsyncBreakCompleteReceived is implemented by components that want to listen for the AsyncBreakComplete event. IDkmAsyncBreakCompleteReceived is invoked before IDkmAsyncBreakCompleteNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent by a debug monitor after a request to async break the process has completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmAsyncBreakCompleteReceived.OnAsyncBreakCompleteReceived(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmAsyncBreakStatus,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnAsyncBreakCompleteReceived is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="status">[In] Indicates the type of async-break that occurred.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBaseFuncEvalService">
      <summary>Interface implemented by base debug monitors to allow for resuming the process for a function evaluation. This interface contains the basic services used by 'ExecuteFuncEval'. Setup, cleanup, time-out handling, exception handling and completion detection are all handled by the higher-level debug monitors. This interface is not provided for CLR v2 debugging. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBaseFuncEvalService.BeginFuncEvalExecution(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags)">
      <summary>This method is used to resume the target process so that a function evaluation may occur. This function is called by a runtime debug monitor after it has set up a function evaluation in order to make the target process run. The runtime monitor will first update the thread context, update any necessary memory in the target process, and setup any detection that the function evaluation is completed. Callers of this method MUST always call EndFuncEvalExecution before they return from the operation that triggered the function evaluation. The behavior is undefined if a caller does not do so. This method is implemented in the base debug monitor by first updating the target process to be in function evaluation mode (DkmThread.OnBeginFuncEvalExecution), then suspending and resuming threads as specified by the function evaluation flags and finally continuing the target process. This method may be called from any thread. However, OnBeginFuncEvalExecution must be called from the stopping event thread, so that the base debug monitor may have to perform as thread switch as part of the implementation of this method. The base debug monitor should not return from BeginFuncEvalExecution until after the target has been resumed.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="flags">[In] Flags affecting how function evaluation requests are performed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBaseNativeExecutionController">
      <summary>IDkmBaseNativeExecutionController is implemented by base debug monitors that support setting native breakpoints or single stepping over native instructions. It provides the advanced execution control primitives needed for CLR debugging. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBaseNativeExecutionController.RaiseExecutionControlException(Microsoft.VisualStudio.Debugger.DkmThread,System.UInt32)">
      <summary>API that may be called from a IDkmSingleStepCompleteReceived or IDkmRuntimeBreakpointReceived implementation to force the base DM to fire the EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP exception in the target process when execution is resumed. Normally, the breakpoint or single-step exception is implicitly suppressed. This allows the EXCEPTION_BREAKPOINT/EXCEPTION_SINGLE_STEP to be handled by exception handlers in the target process. This API will fail if the thread is not currently sitting at a step complete or breakpoint event.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="exceptionCode">[In] Win32 exception code to raise. Currently, this must be EXCEPTION_BREAKPOINT or EXCEPTION_SINGLE_STEP.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBinaryLocator">
      <summary>This interface contains methods implemented by the symbol provider to enable debug monitors to search for binaries on symbol servers and local disks. This is required because the symbol server APIs are not thread safe and the symbol provider owns access to them. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBinaryLocator.LocateBinary(Microsoft.VisualStudio.Debugger.DkmProcess,System.String,System.String,System.String,System.UInt32,System.UInt32)">
      <summary>This method will search the local disk and any configured symbol servers for a binary that matches the parameters. The path of this file on the local disk is returned. If the file was on a symbol server, it is downloaded to a cache and the local path is returned.</summary>
      <returns>[Out,Optional] The path on the local disk of the local (or downloaded) binary.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="applicationPath">[In] The original path of the exe stored in the minidump.</param>
      <param name="dumpPath">[In] The path of the dump file.</param>
      <param name="originalPath">[In] The original path of the binary stored in the minidump.</param>
      <param name="timeDateStamp">[In] The time date stamp of the binary in the time_t format.</param>
      <param name="imageSize">[In] The size of the image.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBoundBreakpointHitNotification">
      <summary>IDkmBoundBreakpointHitNotification is implemented by components that want to listen for the BoundBreakpointHit event. IDkmBoundBreakpointHitNotification is invoked after all implementations of IDkmBoundBreakpointHitReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound breakpoints are the high-level breakpoint objects. Notification for the low-level breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBoundBreakpointHitNotification.OnBoundBreakpointHit(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnBoundBreakpointHit is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint that has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread that hit the breakpoint. Currently, only managed runtime instances set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBoundBreakpointHitReceived">
      <summary>IDkmBoundBreakpointHitReceived is implemented by components that want to listen for the BoundBreakpointHit event. IDkmBoundBreakpointHitReceived is invoked before IDkmBoundBreakpointHitNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Provides notification that a bound breakpoint (DkmBoundBreakpoint) has been hit. Bound breakpoints are the high-level breakpoint objects. Notification for the low-level breakpoints (DkmRuntimeBreakpoint) is obtained through the RuntimeBreakpoint event. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBoundBreakpointHitReceived.OnBoundBreakpointHitReceived(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnBoundBreakpointHitReceived is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint that has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates, you could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) locations.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread that hit the breakpoint. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor">
      <summary>Interface implemented on the target computer to handle evaluating breakpoint conditions and hit counts. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.ClearConditions(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint)">
      <summary>Clear any compiled/evaluation condition associated with the specified DkmRuntimeBreakpoint. This method is implicitly called when the DkmRuntimeBreakpoint is closed.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.ClearHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,System.Int32@)">
      <summary>Clears the hit count condition on a breakpoint.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
      <param name="condition">[In] Condition to apply to this breakpoint.</param>
      <param name="currentHitCount">[Out] Number of times that the breakpoint has been hit as of the time that the condition was removed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.GetHitCountConditionStatus(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,System.Int32@)">
      <summary>Obtains the current hit count value for a DkmRuntimeBreakpoint which has a hit count condition. This function will fail if the DkmRuntimeBreakpoint does not currently have a hit count condition.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
      <param name="currentHitCount">[Out] Number of times that the breakpoint has been hit.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.SetCompiledCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator)">
      <summary>This sets an associated compiled condition on the specified runtime instruction breakpoint. The breakpoint condition processor will then test the condition whenever it is hit. This is used for languages which are evaluated in the IDE process (ex: C++).</summary>
      <param name="instructionBreakpoint">[In] Low-level breakpoint which is set on an instruction address.</param>
      <param name="compiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="conditionOperator">[In] Operator to use when you evaluate the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.SetCompiledConditionPending(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint)">
      <summary>This method resembles SetCompiledCondition, but is used when the instruction address is not known up front, such as data breakpoints. In these cases, when the breakpoint is first hit at a particular address, a call will be made to the breakpoint client to obtain a new compiled condition for this address (IDkmBreakpointConditionProcessorClient.GetCompiledCondition). This is used for languages which are evaluated in the IDE process (ex: C++).</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.SetEvaluationCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,System.String@)">
      <summary>Sets a breakpoint condition which is evaluated on the target computer. This is used for .NET languages.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
      <param name="condition">[In] Conditions under which a breakpoint should fire.</param>
      <param name="errorText">[Out,Optional] If the condition could not be parsed, this indicates the reason why. This value should be null if the compile succeeded.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessor.SetHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,System.Int32)">
      <summary>Initialize or update the hit count condition/value on a breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. The condition is implicitly removed if the DkmRuntimeBreakpoint is closed.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
      <param name="condition">[In] Condition to apply to this breakpoint.</param>
      <param name="hitCountValue">[In] The initial value of the breakpoint's hit count. A value of -1/MAXDWORD indicates that the current hit count value should be preserved.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorClient">
      <summary>Implemented by callers of DkmRuntimeBreakpoint.SetCompiledConditionPending to provide compiled conditions when a breakpoint is hit. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorClient.GetCompiledCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator@)">
      <summary>Callback invoked from the breakpoint condition processor to the breakpoint manager (or other component that calls SetCompiledConditionPending) when the breakpoint condition must be recompiled for a new instruction address.</summary>
      <returns>[Out,Optional] The compiled condition that will be used for the specified instruction address. This value is null in the case that the condition did not compile. In this case, the condition processor should stop on the breakpoint.</returns>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <param name="instructionAddress">[In] The instruction address to compile the condition against.</param>
      <param name="conditionOperator">[Out] Operator to use when you evaluate the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorClient.OnBreakpointConditionFailed(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,System.String)">
      <summary>Callback invoked from the breakpoint condition processor to the breakpoint manager when a breakpoint condition encounters a runtime error.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <param name="errorMessage">[In] The message to display to the user.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorGpuExtension">
      <summary>Extension interface for GPU debugging, implemented on the target computer to handle evaluating breakpoint conditions. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorGpuExtension.RequestBreakpointEventOnModifiedThread(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>The breakpoint condition processor decides not to break on the given thread but another thread of the same warp. Therefore the breakpoint condition processor instructs the base debug monitor to re-send the breakpoint event on the other thread.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object which is supported by debug monitors.</param>
      <param name="modifiedBreakThread">[In] The base debug monitor should re-send breakpoint event on this thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorGpuExtension.TryClearConditionOnTargetDevice(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint)">
      <summary>Clear any condition associated with the specified DkmRuntimeInstructionBreakpoint.</summary>
      <param name="instructionBreakpoint">[In] Low-level breakpoint which is set on an instruction address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointConditionProcessorGpuExtension.TryPushConditionToTargetDevice(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeInstructionBreakpoint,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointConditionOperator)">
      <summary>This tries to push the associated condition on the specified runtime instruction breakpoint to the target. This is useful for GPU debugging because testing the condition on the target (GPU hardware or VSD3D ref) is much more efficient than doing it in the debugger. Once this method succeeds, breakpoint event will only be received by the debugger when the condition tests to be true on the debuggee; if it fails, the debugger can still test the condition.</summary>
      <param name="instructionBreakpoint">[In] Low-level breakpoint which is set on an instruction address.</param>
      <param name="compiledCondition">[In] Compiled query used to evaluate the condition.</param>
      <param name="conditionOperator">[In] Operator to use when you evaluate the condition.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager">
      <summary>This interface is implemented by the Breakpoint Manager component to provide the default handling for breakpoints. Other components in the system may also implement this interface to remap the meaning of breakpoints for certain languages. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.DisableBoundBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisableBoundBreakpointAsyncResult})">
      <summary>Disable the bound breakpoint so that it will no longer hit. If the bound breakpoint is already disabled, this operation has no effect.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.DisablePendingBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmDisablePendingBreakpointAsyncResult})">
      <summary>Disable the pending breakpoint object so that it will no longer fire. If the pending breakpoint is already bound, any bound breakpoints will be implicitly disabled.</summary>
      <param name="pendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.EnableBoundBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnableBoundBreakpointAsyncResult})">
      <summary>Enables the bound breakpoint so that it can be hit. If the bound breakpoint is already enabled, this operation has no effect.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.EnablePendingBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnablePendingBreakpointAsyncResult})">
      <summary>Sets the state of the pending breakpoint so that instances of the breakpoint that bind in the future will get hit. If the pending breakpoint is not yet enrolled, then this method will also enroll the breakpoint. Enrolling a pending breakpoint consists of trying to resolve the breakpoint against any modules which are currently loaded and adding the breakpoint to the list of breakpoints which the breakpoint manager will bind on any module load. If the pending breakpoint is already enrolled, existing bound breakpoints will not automatically get enabled. Bound breakpoints must get enabled separately.</summary>
      <param name="pendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.EnrollPendingBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmEnrollPendingBreakpointAsyncResult})">
      <summary>This method will enroll the pending breakpoint without enabling it. The result is a breakpoint which the breakpoint manager will attempt to resolve, but which will not fire. Enrolling a pending breakpoint consists of trying to resolve the breakpoint against any modules which are currently loaded and adding the breakpoint to the list of breakpoints which the breakpoint manager will bind on any module load.</summary>
      <param name="pendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.GetBoundBreakpointHitCountValue(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmGetBoundBreakpointHitCountValueAsyncResult})">
      <summary>Returns the number of times that a bound breakpoint has been hit. This value should not include any times when the breakpoint's instruction was executed, but the breakpoint's condition indicated that the debugger should not stop.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.IsBoundBreakpointEnabled(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint)">
      <summary>Query to determine whether the bound breakpoint is enabled.</summary>
      <returns>[Out] 'true' if the breakpoint is enabled.</returns>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.SetBoundBreakpointCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition)">
      <summary>Initialize or update or clear the condition on a breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.SetBoundBreakpointHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition)">
      <summary>Initialize, update or clear the hit count condition on a breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.SetBoundBreakpointHitCountValue(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint,System.Int32)">
      <summary>Modifies the value for a breakpoint hit count.</summary>
      <param name="boundBreakpoint">[In] Represents a breakpoint which has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates one could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
      <param name="newValue">[In] New value for the hit count.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.SetPendingBreakpointCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointConditionAsyncResult})">
      <summary>Initialize, update or clear the language-level condition on all bound breakpoints of this condition breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first.</summary>
      <param name="pendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManager.SetPendingBreakpointHitCountCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointHitCountCondition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Breakpoints.DkmSetPendingBreakpointHitCountConditionAsyncResult})">
      <summary>Initialize, update or clear the hit count condition on all bound breakpoints of this pending breakpoint. If the same breakpoint has both a language-level condition, and a hit count condition, the language-level condition is applied first. Note that the hit count condition acts independently on each bound breakpoint, instead of being aggregated together on the pending breakpoint. For example, if the hit count is configured to stop at hit #2, and the breakpoint to two separate locations, each of which hit the breakpoint one time, the UI will still not have gone into break mode because neither individual bound breakpoint has hit two times.</summary>
      <param name="pendingBreakpoint">[In] High level breakpoint object which is tied to a user-level construct (ex: source file, function name) which may map to zero or more code-level constructs (DkmBoundBreakpoint) and which may be tracked over time.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="condition">[In,Optional] Condition to apply to this breakpoint. This value may be 'null' if the caller wishes to remove the condition.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerFileUpdate">
      <summary>Interface implemented by breakpoint managers that want to receive notification when files are updated in the IDE. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small .dll, or that the implementation is configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerFileUpdate.OnBreakpointFilesUpdated(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointFileUpdateNotification,Microsoft.VisualStudio.Debugger.DkmWorkList)">
      <summary>Provides notification that one or more files that contain breakpoints have been updated.</summary>
      <param name="fileUpdateNotification">[In] Object used to send file update notifications to breakpoint managers.</param>
      <param name="workList">WorkList that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerNotification">
      <summary>This interface is implemented by components that add breakpoints to the breakpoint manager (such as the AD7 AL). This allows a component to be notified when the breakpoint manager binds a breakpoint or detects a breakpoint error or warning. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerNotification.OnBreakpointBound(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint[])">
      <summary>Notification from the breakpoint manager when a breakpoint has been bound. In the case of user-set breakpoints, this notification will be sent to the AD7 AL, and the AD7 AL will raise an IDebugBreakpointBoundEvent2 to the Visual Studio Debugger UI.</summary>
      <param name="pendingBreakpoint">[In] High-level breakpoint object that is tied to a user-level construct (ex: source file, function name) that may map to zero or more code-level constructs (DkmBoundBreakpoint) and that may be tracked over time.</param>
      <param name="boundBreakpoints">[In] Represents a breakpoint that has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates you could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int') or many (ex: template is used with many template arguments) location.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerNotification.OnBreakpointMessage(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel,System.String)">
      <summary>Notification from the breakpoint manager concerning the status of binding the breakpoint.</summary>
      <param name="pendingBreakpoint">[In] High-level breakpoint object that is tied to a user-level construct (ex: source file, function name) that may map to zero or more code-level constructs (DkmBoundBreakpoint) and that may be tracked over time.</param>
      <param name="level">[In] Describes the severity of a message sent from a breakpoint manager back to the source component. This list is sorted in order of priority, as the UI will only display the most important warning. All warnings are ignored if the breakpoint is bound.</param>
      <param name="message">[In] Message string to display to the user.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmBreakpointManagerNotification.OnBreakpointUnbound(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingBreakpoint,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBoundBreakpoint[],Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointUnboundReason)">
      <summary>Notification from the breakpoint manager that indicates that the given breakpoint is being unbound.</summary>
      <param name="pendingBreakpoint">[In] High-level breakpoint object that is tied to a user-level construct (ex: source file, function name) that may map to zero or more code-level constructs (DkmBoundBreakpoint) and that may be tracked over time.</param>
      <param name="boundBreakpoints">[In] Represents a breakpoint that has been bound (resolved) to a particular code instruction address or a particular data element. For example, in C++ templates you could create a DkmPendingBreakpoint for a source line. The breakpoint manager would resolve it to zero (ex: module not loaded), one (ex: template is only used on 'int'), or many (ex: template is used with many template arguments) location.</param>
      <param name="reason">[In] Describes the reason for a breakpoint to be unbound.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCallStackFilter">
      <summary>Allows a component to add more annotation to the call stack or remove physical frames from the call stack. For performance reasons, stack frame filters are invoked before evaluation by expression evaluators. One example stack frame filter is to hide external code in the call stack. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small dll, or that the implementation is configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCallStackFilter.FilterNextFrame(Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame)">
      <summary>Provides a filter with the next stack frame. A filter can just pass this frame on through, it can suppress the frame by returning nothing, or it can provide its own set of annotated frames. The stack provider will ignore NotImplementedException (E_NOTIMPL). All other errors will truncate stack walk.</summary>
      <returns>[Out] DkmStackWalkFrame[] represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
      <param name="stackContext">[In] DkmStackContext objects are created by components that want to request the stack from the stack provider. A component must close the context after they have completed the stack walk. To obtain the stack a component should create this object and then call GetNextFrames.</param>
      <param name="input">[In,Optional] Input is the next frame to examine. After all frame have been filtered, this function will be called one last time with a null input frame.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrAppDomainNameChanged">
      <summary>Interface to update name of the AppDomain. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrAppDomainNameChanged.OnAppDomainNameChanged(Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain)">
      <summary>Called when 'Name' is changed.</summary>
      <param name="appDomain">[In] DkmClrAppDomain represents a CLR application domain inside a process which is being debugged.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrMetaDataProvider">
      <summary>Interface implemented by the managed DM to obtain the metadata from a given module. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrMetaDataProvider.GetMetaDataImport(Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance)">
      <summary>Obtains the CLR metadata from a given module. See the IMetaDataImport documentation on MSDN for more information about metadata.</summary>
      <returns>[Out] The IMetaDataImport interface for this managed module instance.</returns>
      <param name="clrModuleInstance">[In] 'DkmClrModuleInstance' is used for modules that are loaded into the Common Language Runtime.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrModuleLookup">
      <summary>Obtains the DkmClrModuleInstance from an ICorDebugModule. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrModuleLookup.FindClrModuleInstance(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.CorDebugInterop.ICorDebugModule)">
      <summary>Obtains the DkmClrModuleInstance from an ICorDebugModule.</summary>
      <returns>[Out] The DkmClrModuleInstance that matches the provided ICorDebugModule.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="corModule">[In] The CLR module to get the module instance for.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitor">
      <summary>Interface implemented by the managed DM to obtain information about the current runtime state of the process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitor.GetMetaDataBytes(Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance)">
      <summary>Obtains the bytes of the CLR metadata from a given module. These bytes can then be passed to IMetaDataDispenser::OpenScope to decode the metadata.</summary>
      <returns>[Out] The raw metadata for this module.</returns>
      <param name="clrModuleInstance">[In] 'DkmClrModuleInstance' is used for modules which are loaded into the Common Language Runtime.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitor.GetNativeCodeMap(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame)">
      <summary>Provides the map of how this method was compiled to native code.</summary>
      <returns>[Out] Structure to define the IL instruction mapping for one or more native instructions.</returns>
      <param name="clrAddress">[In] DkmClrInstructionAddress is used for addresses in managed code.</param>
      <param name="stackFrame">[In,Optional] Stack frame where this address is from. This is necessary for CLR v2 support. This argument will be ignored for CLR v4.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitor.GetNonUserCodeMetadataFlags(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress)">
      <summary>Obtains non user code status for this instruction address.</summary>
      <returns>[Out] The non user code status for this instruction address.</returns>
      <param name="clrAddress">[In] DkmClrInstructionAddress is used for addresses in managed code.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect">
      <summary>Interface implemented by the managed DM to provide expression evaluators and other components direct access to ICorDebug interfaces. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect.GetCorAppDomain(Microsoft.VisualStudio.Debugger.Clr.DkmClrAppDomain)">
      <summary>Provides direct access to the ICorDebugAppDomain object, which expression evaluators or other components can use to inspect the application domain. The returned interface should only be used to inspect the target process, and should never be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior.</summary>
      <returns>[Out] ICorDebug interface representing an application domain inspection.</returns>
      <param name="appDomain">[In] DkmClrAppDomain represents a CLR application domain inside a process that is being debugged.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect.GetCorFunction(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionAddress)">
      <summary>Provides direct access to the ICorDebugFunction object, which expression evaluators or other components can use to inspect the application domain. The returned interface should only be used to inspect the target process, and should never be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior.</summary>
      <returns>[Out] ICorDebug interface representing an application domain inspection.</returns>
      <param name="clrAddress">[In] DkmClrInstructionAddress is used for addresses in managed code.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect.GetCorModule(Microsoft.VisualStudio.Debugger.Clr.DkmClrModuleInstance)">
      <summary>Provides direct access to the ICorDebugModule object, which expression evaluators or other components can use to inspect the application domain. The returned interface should only be used to inspect the target process, and should never be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior.</summary>
      <returns>[Out] ICorDebug interface representing an application domain inspection.</returns>
      <param name="clrModuleInstance">[In] 'DkmClrModuleInstance' is used for modules that are loaded into the Common Language Runtime.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect.GetCorProcess(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance)">
      <summary>Provides direct access to the ICorDebugProcess object, which expression evaluators or other components can use for inspection. The returned interface should only be used to inspect the target process, and should never be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior.</summary>
      <returns>[Out] ICorDebug interface representing a process.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrRuntimeDebugMonitorDirect.GetCorThread(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Provides direct access to the ICorDebugThread object, which expression evaluators or other components can use to inspect the application domain. The returned interface should only be used to inspect the target process, and should never be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will cause undefined behavior.</summary>
      <returns>[Out] ICorDebug interface representing an application domain inspection.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="thread">[In] DkmThread object that should be mapped to the CorDebug thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback">
      <summary>This API allows an Expression Evaluator to obtain information contained in a CLR PDB File or CLR dynamic module symbol store. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetAllAwaitExpressionInfoForStatement(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetAsyncKickoffMethod(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetAsyncMethodCatchHandlerILOffset(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol,System.UInt32@)">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetAsyncMethodLocation(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAsyncMethodLocation" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetFirstMethodInFirstDocument(Microsoft.VisualStudio.Debugger.Symbols.DkmModule)">
      <summary>Returns the first method in the first document.</summary>
      <returns>[Out] DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or one time was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different app domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetMethodSymbolStoreData(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Returns the scopes in a method. There will always be at least one scope.</summary>
      <returns>[Out] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="methodId">[In] DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetMethodSymbolStoreDataPreRemap(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,System.Int32@)">
      <summary>Returns the scopes in a method. There will always be at least one scope.</summary>
      <returns>[Out] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="methodId">[In] Method Id PreRemap.</param>
      <param name="remapToken">[Out] Method token after the Remap.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetNextAwaitExpressionInfo(Microsoft.VisualStudio.Debugger.Clr.DkmClrInstructionSymbol)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrAwaitExpressionInfo" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolCallback.GetTokenSymbolStoreAttribute(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Int32,System.Boolean,System.String)">
      <summary>Gets a custom attribute based on its name. Not to be confused with Metadata custom attributes, these attributes are held in the symbol store.</summary>
      <returns>[Out] The value of the requested symbol store attribute.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="parentToken">[In] The token of the method where the symbol store attribute is stored.</param>
      <param name="isPreRemap">[In] True if the specified token value is not a real method token but was internally computed by the compiler before the method was emitted using the CLR image creation APIs.</param>
      <param name="attributeName">[In] The name of the attribute to find.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolSignatureCallback">
      <summary>Provides APIs to expression evaluators to obtain the signature of local variables and constants. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following property may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolSignatureCallback.GetSignatureForConstant(Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalConstant)">
      <summary>Provides the COR_SIGNATURE for a local constant.</summary>
      <returns>[Out] The COR_SIGNATURE for the constant, which defines the type of this constant.</returns>
      <param name="clrLocalConstant">[In] Represents a local constant defined in a method scope. These are defined by using ISymUnmanagedWriter::DefineConstant or ISymUnmanagedWriter2::DefineConstant2.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrSymbolSignatureCallback.GetSignatureForVariable(Microsoft.VisualStudio.Debugger.Clr.DkmClrLocalVariable)">
      <summary>Provides the COR_SIGNATURE for a local variable.</summary>
      <returns>[Out] The COR_SIGNATURE for the variable, which defines the type of this variable.</returns>
      <param name="clrLocalVariable">[In] Represents a local variable defined in a method scope. These are defined by using ISymUnmanagedWriter::DefineLocalVariable or ISymUnmanagedWriter2::DefineLocalVariable2.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrUIVisualizerService">
      <summary>Implemented by expression evaluators that support the C# EE's method of custom viewers (that is, IPropertyProxyEESide). This interface is subject to change in future releases. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small .dll, or that the implementation be configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrUIVisualizerService.GetManagedViewerCreationData(Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy,System.String@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.String@,System.UInt32@,System.Boolean@)">
      <param name="propertyProxy">[In] Concord wrapper around IPropertyProxyEESide.</param>
      <param name="assemblyName">[Out,Optional]</param>
      <param name="assemblyBytes">[Out,Optional]</param>
      <param name="assemblyPdb">[Out,Optional]</param>
      <param name="className">[Out,Optional] Class name.</param>
      <param name="assemblyResolution">[Out] enum_ASSEMBLYLOCRESOLUTION enumeration.</param>
      <param name="replacementOk">[Out] Replacement ok.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrUIVisualizerService.InitSourceDataProvider(Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy)">
      <returns>[Out,Optional] The result bytes.</returns>
      <param name="propertyProxy">[In] Concord wrapper around IPropertyProxyEESide.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrUIVisualizerService.InPlaceUpdateObject(Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy,System.Byte[])">
      <returns>[Out,Optional]</returns>
      <param name="propertyProxy">[In] Concord wrapper around IPropertyProxyEESide.</param>
      <param name="dataIn">[In]</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmClrUIVisualizerService.ResolveAssemblyReference(Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy,System.String,System.UInt32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.String@,System.UInt32@)">
      <summary>Implements IPropertyProxyEESide::ResolveAssemblyReference().</summary>
      <param name="propertyProxy">[In] Concord wrapper around IPropertyProxyEESide.</param>
      <param name="assemblyName">[In]</param>
      <param name="flags">[In] GETASSEMBLY flags.</param>
      <param name="assemblyBytes">[Out,Optional]</param>
      <param name="assemblyPdb">[Out,Optional]</param>
      <param name="assemblyLocation">[Out,Optional]</param>
      <param name="assemblyResolution">[Out] ASSEMBLYLOCRESOLUTION enumeration.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCompiledInspectionQueryProcessor">
      <summary>Provides execution of compiled inspection queries. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompiledInspectionQueryKind, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCompiledInspectionQueryProcessor.ExecuteQuery(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue},Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason@)">
      <summary>Executes a compiled inspection query and returns any results.</summary>
      <returns>[Out] Results of the evaluations. Each ILEvaluationResult object contains an index that indicates which DkmILInstruction in the instructions parameter this result came from. NOTE: some instructions will not return a result.</returns>
      <param name="query">[In] Represents a query which is produced by an expression evaluator or similar component and set to the target computer to obtain information about the dynamic state of the program (ex: the current value of a register).</param>
      <param name="parameters">[In,Optional] Optional array of parameter values to pass to the IL stream.</param>
      <param name="iLContext">[In] The stack frame context we are evaluating on.</param>
      <param name="timeout">[In] This is the time-out that will be used for potentially slow operations such as a function evaluation. This value is in milliseconds.</param>
      <param name="funcEvalFlags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="failureReason">[Out] If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmComputeKernelExitNotification">
      <summary>Implemented by components that want to listen for the ComputeKernelExit event. The target process may continue to run during this notification. The event when a GPU compute kernel has finished running. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmComputeKernelExitNotification.OnComputeKernelExit(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int32,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnComputeKernelExit is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="exitCode">[In] 32-bit value that the compute kernel returned on exit.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmContinueExecution">
      <summary>This interface contains the API for resuming execution after the engine has sent a stopping event to the Visual Studio debugger package. This interface should only be implemented by Base Debug Monitor components. Unlike almost all other interfaces, one implementation of this interface may not chain to another implementation. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmContinueExecution.ContinueExecution(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>This method is provided by base debug monitors to resume execution of the target process. This interface is always triggered by a request to resume the process by the Visual Studio Debugger UI/SDM. Concord components cannot resume the target process after a stopping event has been sent to the UI/SDM. Base debug monitors implement this by calling from the request thread onto the stopping event thread. On the stopping event thread, the base debug monitor calls DkmThread.OnContinueExecution and then modifies the target process so that it will resume. After the target is running, the base debug monitor signals the request thread so that ContinueExecution will return.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomMessageCallbackReceiver">
      <summary>Implemented by components that want to receive custom messages from another Concord component. This is interface resembles IDkmCustomMessageForwardReceiver, except that this method requires that the caller be at a lower level in the component hierarchy than the component that receives the notification (ex: Base Debug Monitor -&gt; AD7 AL). Implementers of this interface typically use a SourceId filter. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomMessageCallbackReceiver.SendHigher(Microsoft.VisualStudio.Debugger.DkmCustomMessage)">
      <summary>Sends a message to a listening component which is higher in the hierarchy.</summary>
      <returns>[Out,Optional] Message sent back from the implementation.</returns>
      <param name="customMessage">[In] Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomMessageForwardReceiver">
      <summary>Implemented by components that want to receive custom messages from the IDE or from another Concord component. This is interface resembles IDkmCustomMessageCallbackReceiver, except that this method requires that the caller be at a higher level in the component hierarchy than the component that receives the (ex: AD7 AL -&gt; Base Debug Monitor). Implementers of this interface typically use a SourceId filter. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomMessageForwardReceiver.SendLower(Microsoft.VisualStudio.Debugger.DkmCustomMessage)">
      <summary>Sends a message to a listening component which is lower in the hierarchy.</summary>
      <returns>[Out,Optional] Message sent back from the implementation.</returns>
      <param name="customMessage">[In] Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomStopNotification">
      <summary>IDkmCustomStopNotification is implemented by components that want to listen for the CustomStop event. IDkmCustomStopNotification is invoked after all implementations of IDkmCustomStopReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). The CustomStop event allows a concord component to raise a stopping event to a custom UI component or to a higher-level Concord component. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomStopNotification.OnCustomStop(Microsoft.VisualStudio.Debugger.DkmCustomMessage,Microsoft.VisualStudio.Debugger.DkmThread,System.Guid,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnCustomStop is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="customMessage">[In] Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc.).</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="vsService">[In] Visual Studio service that this event should be sent to. A Visual Studio package must register this service ID (ex: Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}), and this package must implement the IVsCustomDebuggerStoppingEventHandler110 interface.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomStopReceived">
      <summary>IDkmCustomStopReceived is implemented by components that want to listen for the CustomStop event. IDkmCustomStopReceived is invoked before IDkmCustomStopNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). The CustomStop event allows a concord component to raise a stopping event to a custom UI component or to a higher-level concord component. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomStopReceived.OnCustomStopReceived(Microsoft.VisualStudio.Debugger.DkmCustomMessage,Microsoft.VisualStudio.Debugger.DkmThread,System.Guid,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>Invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="customMessage">[In] Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc.).</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="vsService">[In] Visual Studio service that this event should be sent to. A Visual Studio package must register this service id (ex: Software\Microsoft\VisualStudio\$(ver)\Services\{VsService}) and this package must implement the IVsCustomDebuggerStoppingEventHandler110 interface.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer">
      <summary>This interface is implemented by custom expression evaluator visualizers in order to customize the view of an expression programmatically. This is ordinarily done to support visualizations that are not possible using the native visualizer syntax or to enable visualization without full symbolic information. The visualizer can take complete control of the expression including expansion of children, or it can obtain the default expression from the expression evaluator, modify it slightly but defer other operations such as expansion back to the EE. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: EngineId, RuntimeId, SourceId, VisualizerId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.EvaluateVisualizedExpression(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>Evaluate a visualized expression returning a DkmEvaluationResult for it.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="resultObject">[Out] Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object. The expression evaluator reserves the right to override this instance so do not rely on storing data items in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data container instead.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.GetChildren(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression[]@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext@)">
      <summary>Gets an enumeration context used to obtain the children of this evaluation result. This is used in all expression evaluation windows.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="initialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be at first returned. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="inspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="initialChildren">[Out] The initial children to return.</param>
      <param name="enumContext">[Out] Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.GetItems(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression[]@)">
      <summary>Called to obtain items from an instance of DkmEvaluationResultEnumContext created by an earlier call to GetChildren.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="enumContext">[In] The enum context to use for this call. This instance will have been returned from a previous call to DkmVisualizedExpression.</param>
      <param name="startIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="items">[Out] The DkmChildVisualizedExpression items to return.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.GetUnderlyingString(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression)">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window (click the magnifying glass icon).</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.SetValueAsString(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="value">[In] Textual representation of value to assign to the evaluation result.</param>
      <param name="timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="errorText">[Out,Optional] If the operation failed, this indicates the reason why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizer.UseDefaultEvaluationBehavior(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.Boolean@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>Called by the expression evaluator when a visualized expression's children are being expanded, the value is being set, or the underlying string is being obtained. If the visualizer addin wants complete control of the expression it should return false. It will then receive calls to GetChildren, GetItems, SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to defer these operations to the expression evaluator, it should return true. It must also give the expression evaluator back the instance of DkmEvaluationResult that came from the EE via one of the IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the default DkmEvaluationResult from the EE if it wants the EE to control the object. Returning true from this method is primarily used by visualizer addins that just adjust something small such as the view of a value but do not want to modify expansion or setting values.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="useDefaultEvaluationBehavior">[Out] Return true to use default expansion, false otherwise.</param>
      <param name="defaultEvaluationResult">[Out,Optional] The instance of DkmEvaluationResult returned from a call to one of the methods of IDkmCustomVisualizerCallback. The expression evaluator can only control DkmEvaluationResults it understands.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback">
      <summary>This interface is implemented the expression evaluator to allow an EE addin to call back to the expression evaluator. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: EngineId, RuntimeId, SourceId, VisualizerId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.CreateDefaultChildFullName(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.Int32)">
      <summary>This method will construct a default full name for a custom visualized child expression. This name will be the root expression's full name and an expand format string that will cause the expression evaluator to call back to the visualizer to obtain children. The DkmVisualizedExpression instance this is called on should be the parent visualized expression for a child and the root visualized expression for a root.</summary>
      <returns>[Out] The returned full name string.</returns>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="index">[In] The index of child for which this full name is created. Ignored for a root item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.EvaluateExpressionCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>This method allows a visualizer addin to use the expression evaluator to compile and evaluate the default value for an expression. The addin can use this result as is or override fields by creating a new result. The addin can also decide to use the expression evaluator for expansion using the get children callbacks.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="inspectionContext">[In] The inspection context to use for this evaluation.</param>
      <param name="expression">[In] The expression the visualizer addin wants the expression evaluator to evaluate.</param>
      <param name="stackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="resultObject">[Out] Object that contains the result of the evaluation.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_PROCESS_DESTROYED indicates that the process exited while it tries to evaluate.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.GetChildrenCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[]@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext@)">
      <summary>This method allows a visualizer addin to use the expression evaluator for expansion. The evaluation result contained in the visualized expression must have come from the expression evaluator via EvaluateExpressionCallback.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="defaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can only control the expansion of evaluations it understands.</param>
      <param name="initialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be returned at first. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="inspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="initialChildren">[Out] The initial children to return. Each child must be closed by the caller when the caller has finished.</param>
      <param name="enumContext">[Out] Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.GetItemsCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[]@)">
      <summary>This method allows a visualizer addin to use the expression evaluator for expansion using the passed enumeration context. This is used to obtain local variables of a stack frame or child members from an evaluation result.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="enumContext">[In] Context object that is used to enumerate the children.</param>
      <param name="startIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes, which would cause out-of-memory if all elements were requested.</param>
      <param name="items">[Out] The DkmEvaluationResult items to return. Each item must be closed by the caller when the caller has finished.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.GetSymbolInterface(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.Guid,System.Object@)">
      <summary>Allows custom expression evaluator addins to obtain the symbol interface for the type being visualized. This is not stored in the DkmVisualizedExpression to enable addins that live on the remote computer and do not depend on symbols.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="typeSymbolInterfaceId">[In] The GUID of the TypeSymbolInterface interface requested from the caller. For the Microsoft native C++ expression evaluator, this should be IID_IDiaSymbol.</param>
      <param name="typeSymbolInterface">[Out] The symbol interface of the type that was used to evaluate the expression.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.GetUnderlyingStringCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window. (Click the magnifying glass icon.)</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="defaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can only control evaluations it understands.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmCustomVisualizerCallback.SetValueAsStringCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows.</summary>
      <param name="visualizedExpression">[In] Dispatcher object that is used for custom visualization through a concord EE addin.</param>
      <param name="defaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can control only evaluations it understands.</param>
      <param name="value">[In] Textual representation of value to assign to the evaluation result.</param>
      <param name="timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="errorText">[Out,Optional] If the operation failed, this indicates why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDebugMonitorExceptionNotification">
      <summary>IDkmDebugMonitorExceptionNotification is implemented by components that want to listen for the DebugMonitorException event. When this notification fires, the target process will be suspended and can be examined. The 'DebugMonitorException' event provides notification from debug monitors about exceptions that occur in the target process. This event notification is consumed by the exception manager and by debug monitors operating at component levels above the debug monitor that detected the exception. Higher level components should use exception triggers instead. See DkmExceptionTrigger for more information. If the exception is sent unhandled (DkmExceptionProcessingStage.Unhandled is set), the IDE will stop. Other exceptions might stop depending on any DkmExceptionTriggers set by the AD7 AL or other components. The AD7 AL reads the default set of triggers from %VSRegistryRoot%\AD7Metrics\Exception\%CategoryGuid%\*. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDebugMonitorExceptionNotification.OnDebugMonitorException(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnDebugMonitorException is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="exception">[In] Provides information about an exception that was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDeploymentCommandCallback">
      <summary>Callback interface implemented by callers of DkmDeploymentCommand.Start to receive notification of events in the deployment command. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SourceId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDeploymentCommandCallback.OnProcessExit(Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand,System.Int32)">
      <summary>Indication that the launched command has completed. After this is received, no additional notifications will be sent.</summary>
      <param name="deploymentCommand">[In] Object representing an arbitrary executable which is executed on the target computer.</param>
      <param name="exitCode">[In] 32-bit value which the processed returned on exit. This is the same value that would be reported from the kernel32!GetExitCodeProcess.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDeploymentCommandCallback.OnStdErr(Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand,System.String)">
      <summary>Indication that the target wrote to stderr. This will not be used if the DkmDeploymentCommandFlags.CombineStdErr flag is used. Note that the output from stderr and stdout is not synchronized. Therefore if a program writes to stdout before stderr, a listener may still get the stderr output first (or vice versa).</summary>
      <param name="deploymentCommand">[In] Object representing an arbitrary executable which is executed on the target computer.</param>
      <param name="text">[In] Text written to stderr.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDeploymentCommandCallback.OnStdOut(Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand,System.String)">
      <summary>Indication that the target wrote to stdout. This is also used for StdErr if the DkmDeploymentCommandFlags.CombineStdErr flag is used.</summary>
      <param name="deploymentCommand">[In] Object representing an arbitrary executable which is executed on the target computer.</param>
      <param name="text">[In] Text written to stdout.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDisassemblyProvider">
      <summary>Used to disassemble instructions in the debuggee address space. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDisassemblyProvider.Disassemble(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.UInt32)">
      <summary>Disassembles an address range in the debuggee process.</summary>
      <returns>[Out] The results of disassembling the address range.</returns>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The address where disassembly should start.</param>
      <param name="count">[In] The number of instructions to disassemble.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDisassemblyProvider.GetEffectiveAddresses(Microsoft.VisualStudio.Debugger.CallStack.DkmStackFrame,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>A method that calculates and returns the effective addresses for the requested address. The effective address is the calculated address that an instruction operand represents. For instance, on x86, an instruction may be of the form dwordptr [esp-12]. The effective address of this operand will be the result of subtracting 12 from esp. The number of operands and effective addresses are architecture specific.</summary>
      <returns>[Out] The collection of effective addresses for this instruction, if any.</returns>
      <param name="frame">[In] DkmStackFrame represents a frame on the call stack after filtering and translation.</param>
      <param name="address">[In] The address for which to obtain the effective addresses.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDisassemblyProvider.GetInstructionAddress(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Int32)">
      <summary>Returns the address of the kth instruction relative to a starting address. For constant-length instruction sets, this is simple arithmetic. For variable-length instruction sets, reverse-disassembly is required to obtain this address.</summary>
      <returns>[Out] The address of the instruction InstructionOffset instructions from StartAddress.</returns>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="startAddress">[In] The address of the current instruction where the offset should begin.</param>
      <param name="instructionOffset">[In] The number of instructions relative to StartAddress to find the desired address. This value can be negative.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDumpWriter">
      <summary>This interface contains the API for writing out a dump file of the debuggee process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmDumpWriter.WriteDump(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmDumpType,System.String,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>This method will write out a memory dump of the process to the path specified.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="dumpType">[In] The type of dump to write. Either minidump or full-memory minidump.</param>
      <param name="path">[In] The full path of where the minidump should be saved. In remote scenarios, this path is relative to the remote computer.</param>
      <param name="targetThread">[In,Optional] The thread to use for the minidump if there is no current exception.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEmbeddedBreakpointHitNotification">
      <summary>IDkmEmbeddedBreakpointHitNotification is implemented by components that want to listen for the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitNotification is invoked after all implementations of IDkmEmbeddedBreakpointHitReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent by the exception manager when an embedded breakpoint exception is encountered. Components underneath the exception manager must listen for the platform specific exception event instead. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEmbeddedBreakpointHitNotification.OnEmbeddedBreakpointHit(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnEmbeddedBreakpointHit is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="instructionAddress">[In,Optional] The address where the embedded breakpoint was hit.</param>
      <param name="showAsException">[In] If true, the UI will display an exception hit dialog for a breakpoint exception. If false, UI will just break and the DkmInstructionAddress is not used.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEmbeddedBreakpointHitReceived">
      <summary>IDkmEmbeddedBreakpointHitReceived is implemented by components that want to listen for the EmbeddedBreakpointHit event. IDkmEmbeddedBreakpointHitReceived is invoked before IDkmEmbeddedBreakpointHitNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent by the exception manager when an embedded breakpoint exception is encountered. Components underneath the exception manager must listen for the platform-specific exception event instead. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEmbeddedBreakpointHitReceived.OnEmbeddedBreakpointHitReceived(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>Invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="instructionAddress">[In,Optional] The address where the embedded breakpoint was hit.</param>
      <param name="showAsException">[In] If true, the UI will display an exception hit dialog box for a breakpoint exception. If false, the UI will just break and the DkmInstructionAddress is not used.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEntryPointNotification">
      <summary>IDkmEntryPointNotification is implemented by components that want to listen for the EntryPoint event. IDkmEntryPointNotification is invoked after all implementations of IDkmEntryPointReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Fired from the breakpoint manager when the entry point breakpoint has been hit. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEntryPointNotification.OnEntryPoint(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnEntryPoint is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEntryPointReceived">
      <summary>IDkmEntryPointReceived is implemented by components that want to listen for the EntryPoint event. IDkmEntryPointReceived is invoked before IDkmEntryPointNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Fired from the breakpoint manager when the entry point breakpoint has been hit. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmEntryPointReceived.OnEntryPointReceived(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnEntryPointReceived is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionContinuedNotification">
      <summary>IDkmExceptionContinuedNotification is implemented by components that want to listen for the ExceptionContinued event. When this notification fires, the target process will be suspended and can be examined. ExceptionContinued is sent by a debug monitor when execution is resumed in the target process and the given exception has not been squashed. In other words, the target process will continue with its standard exception processing. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionContinuedNotification.OnExceptionContinued(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnExceptionContinued is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="exception">[In] Provides information about an exception that was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionController">
      <summary>IDkmExceptionController is implemented by runtime debug monitors which fire exception events (DkmExceptionInformation.OnDebugMonitorException()). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionController.CanModifyProcessing(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation)">
      <summary>Determines if processing for this exception may be modified by the debugger. For example, if this user has performed an action (such as set next statement) that required the exception to be implicitly squashed, this may return false. This method may also return false if the runtime does not permit the exception from being squashed.</summary>
      <returns>[Out] True if the debug monitor can modify the processing of this exceptions.</returns>
      <param name="exception">[In] Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionController.SquashProcessing(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation)">
      <summary>Updates the state of the target process so that when execution is resumed, the target process will not continue standard exception processing (ex: handler search, stack unwinding). This method must be called before resuming execution.</summary>
      <param name="exception">[In] Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionFormatter">
      <summary>IDkmExceptionFormatter is implemented by runtime debug monitors which fire exception events. Unlike IDkmExceptionController, there is generally a single implementation of IDkmExceptionFormatter for each exception category. For example, when multiple base debug monitor implementations can detect Win32 exceptions, there only has to be one formatter implementation. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionFormatter.GetAdditionalInformation(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation)">
      <summary>Provides additional information about an exception which will appear when Visual Studio stops on the exception. For CLR exceptions, this contains the 'Message' property from the System.Exception which was thrown.</summary>
      <returns>[Out,Optional] String description of the exception. If no other information is available, null is returned.</returns>
      <param name="exception">[In] Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionFormatter.GetDescription(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation)">
      <summary>Provides a string description for an exception. This is used when tracing the exception to the output window.</summary>
      <returns>[Out] String description of the exception.</returns>
      <param name="exception">[In] Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionManager">
      <summary>Interface implemented by the exception manager component to allow for exception triggers to be enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionManager.AddExceptionTrigger(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger)">
      <summary>Adds an exception trigger so that ExceptionTriggerHit events will be sent when the exception trigger has been met. If there is already an exception triggered defined for this {SourceId, DkmExceptionTrigger} tuple then the existing trigger will be modified with the new settings. For example, if a component defines a trigger to stop when an access violation exception is thrown and later sets a trigger to fire when any Win32 exception goes unhandled, then the access violation trigger will be removed.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="sourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="trigger">[In] Describes an exception or collection of exceptions which a component wants to break on. When a higher level components wants to be notified about certain exceptions, it should create one or more exception triggers, and then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, a ExceptionTriggerHit exception will be fired whenever this trigger is met.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionManager.ClearExceptionTriggers(Microsoft.VisualStudio.Debugger.DkmProcess,System.Guid)">
      <summary>Removes all the exception triggers which have been set with a particular SourceId. After this method returns, the exception triggers will no longer raise ExceptionTriggerHit events. Exception triggers are automatically cleared when the DkmProcess object is closed.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="sourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionTriggerHitNotification">
      <summary>IDkmExceptionTriggerHitNotification is implemented by components that want to listen for the ExceptionTriggerHit event. IDkmExceptionTriggerHitNotification is invoked after all implementations of IDkmExceptionTriggerHitReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). The 'ExceptionTriggerHit' event provides notification that a previously set DkmExceptionTrigger has been met. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionTriggerHitNotification.OnExceptionTriggerHit(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnExceptionTriggerHit is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="hit">[In] Provides information about an exception trigger that was satisfied (hit) by an exception coming from the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionTriggerHitReceived">
      <summary>IDkmExceptionTriggerHitReceived is implemented by components that want to listen for the ExceptionTriggerHit event. IDkmExceptionTriggerHitReceived is invoked before IDkmExceptionTriggerHitNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). The 'ExceptionTriggerHit' event provides notification that a previously set DkmExceptionTrigger has been met. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionTriggerHitReceived.OnExceptionTriggerHitReceived(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnExceptionTriggerHitReceived is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="hit">[In] Provides information about an exception trigger which was satisfied (hit) by an exception coming from the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionWinRTErrorExtractor">
      <summary>Called by the exception manager to extract Windows Runtime enhanced error information from a JavaScript/CLR/C++/etc. exception. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, ExceptionCategory, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExceptionWinRTErrorExtractor.GetWinRTErrorInfo(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,System.String@,System.String@,System.String@)">
      <summary>Provides developer-oriented additional information about the exception. This information should be displayed together with GetDescription and GetAdditionalInformation to clarify the cause of the error.</summary>
      <param name="exception">[In] Provides information about an exception that was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
      <param name="restrictedDescription">[Out,Optional] RestrictedErrorInfo description of the exception. Due to security restrictions, this may not be available even if RestrictedErrorInfo is available for the exception.</param>
      <param name="restrictedErrorReference">[Out,Optional] If present, used to retrieve IRestrictedErrorInfo via the RoResolvedRestrictedErrorInfoReference API.</param>
      <param name="restrictedCapabilitySid">[Out,Optional] If present, specifies the missing capability.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExtendedRegisters">
      <summary>Gets the extended registers from the thread context. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExtendedRegisters.GetExtendedRegisters(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Gets the extended registers from the thread context.</summary>
      <returns>[Out] An array of extended registers.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmExtendedRegisters.SetExtendedRegisterValue(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Sets the value of the extended register in the thread's context.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="registerIndex">[In] The CV constant of the register to set. For AVX, this can be any of the YMM register enumeration codes. The caller is expected to set the full YMM register (including the portions which are aliased on XMM registers).</param>
      <param name="value">[In] The value to set the register to. The size of the byte array must match the width of the register being set.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFrameExceptionInterceptProvider">
      <summary>This interface is implemented by debug monitors that provide support for unwinding exceptions to a specific frame. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFrameExceptionInterceptProvider.GetUnwindAddress(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmInstructionAddress@)">
      <summary>Returns the address that represents the location if an exception were to be intercepted to this frame.</summary>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack that has been walked but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="newAddress">[Out] Possible new address if an exception was unwound to this frame.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFrameExceptionInterceptProvider.InterceptCurrentException(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags,System.UInt64@)">
      <summary>Used to unwind to this frame as if there were an exception handler at that frame.</summary>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack that has been walked but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="interceptAction">[In] Specifies exception interception actions.</param>
      <param name="cookie">[Out] Cookie that represents this intercept request. The value is returned when an exception interception completed event is sent.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFuncEvalCompletedNotification">
      <summary>IDkmFuncEvalCompletedNotification is implemented by components that want to listen for the FuncEvalCompleted event. The target process may continue to run during this notification. The FuncEvalCompleted event is sent after a function evaluation has completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFuncEvalCompletedNotification.OnFuncEvalCompleted(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnFuncEvalCompleted is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="flags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFuncEvalStartingNotification">
      <summary>IDkmFuncEvalStartingNotification is implemented by components that want to listen for the FuncEvalStarting event. The target process may continue to run during this notification. The FuncEvalStarting event is sent just before a function evaluation is started. In the case of nested break state, each new function evaluation will trigger another FuncEvalStarting event. In this scenario, the target stops, and a user performs an evaluation from the immediate window which triggers a FuncEvalStarting event. The user hits a breakpoint within their evaluated function, and the user does a second evaluation from there that triggers a second FuncEvalStarting event. The user lets both evaluations complete and this triggers two FuncEvalCompleted events. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFuncEvalStartingNotification.OnFuncEvalStarting(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnFuncEvalStarting is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="flags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFunctionTableProvider">
      <summary>Interface to provide access to the runtime function table of a process. A default implementation is provided by Microsoft's Native Debug Monitor which can find function tables in loaded Win32 modules and dynamic PData in live processes. This interface may be implemented by base debug monitors to provide runtime function table access for non-live processes (ex: minidumps). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFunctionTableProvider.GetFunctionTableEntry(Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance,System.UInt64)">
      <summary>Obtain the function table entry for the passed address. The format of the engine depends on the debuggee architecture.</summary>
      <returns>[Out] The contents of the function table entry.</returns>
      <param name="nativeModuleInstance">[In] 'DkmNativeModuleInstance' is used for modules which contain CPU code and are loaded by the Win32 loader.</param>
      <param name="address">[In] The address to search the function table for. Normally, each entry contains a start and an end address. Implementations should return the entry whose address range contains the requested address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmFunctionTableProvider.SearchRuntimeFunctionTable(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.UInt64@)">
      <summary>The method will return the contents of the IMAGE_RUNTIME_FUNCTION_ENTRY for an address if it is possible. For searching static entries, callers should call the equivalent method on DkmNativeModuleInstance.</summary>
      <returns>[Out,Optional] The runtime function table entry for this address if found.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The virtual address for which to find a function table entry for.</param>
      <param name="baseAddress">[Out] The base address for the runtime function table entry.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUBreakpointBehaviorQuery">
      <summary>Interface for querying the GPU debugging breakpoint behavior. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUBreakpointBehaviorQuery.GetGPUBreakpointBehavior(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Get the breakpoint behavior of the process.</summary>
      <returns>[Out] The breakpoint behavior of the process.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation">
      <summary>Provides the compute kernel hierarchy, i.e., the thread group, compute vector, and compute thread for view by the user. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetActiveThreadGroups(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int64[]@,System.Int32@)">
      <summary>Obtains the active thread groups from the compute kernel.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="activeThreadGroups">[Out] List of global thread group IDs of all active thread groups.</param>
      <param name="numberOfGroups">[Out] Number of active thread groups in the compute kernel.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetComputeKernelName(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel)">
      <summary>Gets the name of compute kernel.</summary>
      <returns>[Out] Name of the ComputeKernel that is started.</returns>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetComputeKernelProperties(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty[]@,System.Int32@)">
      <summary>Gets properties of the compute kernel.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="computeProperties">[Out] List of compute kernel properties.</param>
      <param name="numberOfProperties">[Out] Number of properties in the compute kernel.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetComputeVectorWidth(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int32@)">
      <summary>Obtains the warp size of the hardware or emulator.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="width">[Out] Width of the hardware.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetCurrentGroupDimensions(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="groupDimensions">[Out] Grid dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetCurrentThreadDimensions(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="threadDimensions">[Out] Thread group dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of thread block dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetFlatComputeKernelDimensions(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Int32[]@,System.Int32[]@,System.Int32@,Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="flatThreadDimensions">[Out] Thread group dimensions.</param>
      <param name="flatIndexBase">[Out] Thread group dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of thread block dimensions.</param>
      <param name="model">[Out] Model type.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetGroupId(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="groupDimensions">[Out] Grid dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetThisGroupDimension(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="groupDimensions">[Out] Grid dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetThisThreadDimension(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="threadDimensions">[Out] Thread group dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of thread block dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetThreadFromId(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.UInt64,Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread@)">
      <summary>Gets the DkmGPUComputeThread object for a given thread ID.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="threadId">[In] ID of the thread to return.</param>
      <param name="thread">[Out] Thread object that matches the given thread ID.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GetThreadId(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="threadDimensions">[Out] Thread group dimensions.</param>
      <param name="numberOfDimensions">[Out] Number of thread block dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.GroupBy(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause)">
      <summary>Runs the group by query on thread information objects.</summary>
      <returns>[Out] The result set of compute thread information objects.</returns>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="groupByFlags">[In] Flags specifying on which columns the group by is run.</param>
      <param name="from">[In] From clause specification for selection. (Can be empty to select from all available threads.)</param>
      <param name="where">[In] Where clause specification for group by.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.Select(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause)">
      <summary>Runs the select query on thread information objects.</summary>
      <returns>[Out] The result set of compute thread information objects.</returns>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="from">[In] From clause specification for selection. (Can be empty to select from all available threads.)</param>
      <param name="where">[In] Where clause specification for selection.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.UpdateFlaggedState(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause,System.Boolean)">
      <summary>Updates flagged state of compute threads.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="where">[In] Where clause specification for update.</param>
      <param name="flagged">[In] The value to update with.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUComputeKernelOperation.UpdateFrozenState(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause,System.Boolean)">
      <summary>Updates frozen state of compute threads.</summary>
      <param name="computeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="where">[In] Where clause specification for update.</param>
      <param name="frozen">[In] The value to update with.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUDisassemblyQuery">
      <summary>Used to query raw disassembly in the GPU debuggee byte code. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUDisassemblyQuery.GetGPUDisassembly(Microsoft.VisualStudio.Debugger.DkmModuleInstance,System.UInt64,System.UInt32,System.Boolean,System.Boolean@)">
      <summary>Obtains the disassembly of the address range in the debuggee module instance.</summary>
      <returns>[Out] The results of disassembly read from the debuggee byte code.</returns>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="address">[In] The address where disassembly should start.</param>
      <param name="count">[In] The number of instructions to disassemble.</param>
      <param name="isForward">[In] True if this is forward disassembling. Otherwise, this is reverse disassembling.</param>
      <param name="isEnd">[Out] True if the disassembly has reached the end of byte code; false otherwise.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUDisassemblyQuery.GetGPUDisassemblySize(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Returns the disassembly size in the debuggee module instance.</summary>
      <returns>[Out] The disassembly size.</returns>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUDisassemblyQuery.GetNextGPUInstructionAddress(Microsoft.VisualStudio.Debugger.DkmModuleInstance,System.UInt64)">
      <summary>Returns the address of the next instruction relative to a starting address.</summary>
      <returns>[Out] The address of the next instruction from StartAddress.</returns>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="startAddress">[In] The address of the current instruction.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUEnvironmentFilter">
      <summary>Optional internal interface that can be implemented to customize the environment of the GPU target process before it is started. From the debug monitor side, this API, or IDkmGPUEnvironmentFilter, can be implemented. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small .dll, or that the implementation be configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUEnvironmentFilter.GetGPUAdditionalEnvironmentVariables(Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings,Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario)">
      <summary>Obtains any environment variables that the extension wants to add.</summary>
      <returns>[Out,Optional] One or more environment variables that should be passed to the target process. Multiple variables are separated with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12". Null or empty string is returned if the caller does not want to customize the environment block for this launch.</returns>
      <param name="debugLaunchSettings">[In] Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</param>
      <param name="scenario">[In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter implementations are invoked.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUMemoryOperation">
      <summary>Implemented by base debug monitors to provide access to the memory of the target GPU process. Base debug monitors are responsible for performing the memory I/O. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUMemoryOperation.ReadMemory(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Byte[])">
      <summary>Read the memory of the target GPU process. The method is on DkmGPUComputeThread because it may read thread local memory, group shared memory or global memory.</summary>
      <returns>[Out] Indicates the number of bytes read from the target GPU process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be greater than zero.</returns>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="address">[In] The address from which to read the target GPU process's memory.</param>
      <param name="instructionPointer">[In] The instruction pointer where to resolve address to register location.</param>
      <param name="flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUMemoryOperation.UpdateBufferTag(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.UInt32)">
      <summary>Checks if a tag for a buffer has been forwarded for this kernel execution.</summary>
      <returns>[Out] The forwarded tag value.</returns>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="inputTag">[In] The C++ AMP pointer tag.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUMemoryOperation.ValidateAddress(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.UInt64)">
      <summary>Validate the specified GPU memory address.</summary>
      <returns>[Out] True if the specified address is a valid GPU memory address, false otherwise.</returns>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="address">[In] The address to validate.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUMemoryOperation.WriteMemory(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.UInt64,System.UInt64,System.Byte[])">
      <summary>Writes memory to the target GPU process. The method is on DkmGPUComputeThread because it may write thread local memory, group shared memory or global memory.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="address">[In] The base address from which to write the target GPU process's memory.</param>
      <param name="instructionPointer">[In] The instruction pointer where to resolve address to register location.</param>
      <param name="data">[In] Data to be written in the address space of the specified GPU process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGpuRaceHazardsAllowSameNotification">
      <summary>Interface to update components when 'IsGpuRaceHazardsAllowSameSettingEnabled' is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGpuRaceHazardsAllowSameNotification.OnGpuRaceHazardAllowSameSettingChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'IsGpuRaceHazardsAllowSameSettingEnabled' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine GUID (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPURegisterOperation">
      <summary>Implemented by base debug monitors to provide access to the registers of the GPU compute thread. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPURegisterOperation.GetRegisterDescriptions(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread)">
      <summary>Obtain the list of all register descriptions from the GPU compute thread.</summary>
      <returns>[Out] The list of all register descriptions from the GPU compute thread.</returns>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPURegisterOperation.SetRegisterValue(Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Set the value of a register in the GPU compute thread.</summary>
      <param name="computeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="registerDescription">[In] The description of a register from the GPU compute thread.</param>
      <param name="registerValue">[In] The value bytes of a register to be written in the GPU compute thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSetMemoryAccessWarningOperation">
      <summary>IDkmGPUSetMemoryAccessWarningOperation is used to configure GPU memory access warnings on the debugged GPU device. It is implemented by base debug monitors that support reporting GPU Memory Access Exceptions. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSetMemoryAccessWarningOperation.ClearAllGPUMemoryAccessWarnings(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Disables all active GPU memory access warnings.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSetMemoryAccessWarningOperation.SetGPUMemoryAccessWarning(Microsoft.VisualStudio.Debugger.DkmProcess,System.Int32,System.Boolean)">
      <summary>Enables / disables a particular GPU memory access warning.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="warningCode">[In] Warning code to set.</param>
      <param name="enable">[In] True to set the warning; false to clear it.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSingleStepCompleteNotification">
      <summary>IDkmGPUSingleStepCompleteNotification is implemented by components that want to listen for the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteNotification is invoked after all implementations of IDkmGPUSingleStepCompleteReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent when single stepping a GPU thread is completed. The event can be fired by a different thread from the request thread in the same warp. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSingleStepCompleteNotification.OnGPUSingleStepComplete(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnGPUSingleStepComplete is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSingleStepCompleteReceived">
      <summary>IDkmGPUSingleStepCompleteReceived is implemented by components that want to listen for the GPUSingleStepComplete event. IDkmGPUSingleStepCompleteReceived is invoked before IDkmGPUSingleStepCompleteNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent when single stepping a GPU thread is completed. The event can be fired by a different thread from the request thread in the same warp. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSingleStepCompleteReceived.OnGPUSingleStepCompleteReceived(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnGPUSingleStepCompleteReceived is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolProviderCallback">
      <summary>Callback interface which is implemented by GPU symbol providers to provide information from the symbol store to base debug monitors. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolProviderCallback.GetCompilerOptions(Microsoft.VisualStudio.Debugger.Symbols.DkmModule)">
      <summary>This method returns compiler flags of the given GPU module.</summary>
      <returns>[Out,Optional] returns the compiler flags.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolProviderCallback.GetGPUInstructionMetadataCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>This method returns address information to the GPU debug monitor.</summary>
      <returns>[Out,Optional] The address type information.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="instructionAddress">[In,Optional] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="nextInstruction">[In] The next instruction address which is used to determine inline function call.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolProviderCallback.GetNoSourceRanges(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>Queries the symbol provider to determine the ranges of instructions which do not correspond to any user source statements and are used by the base debug monitor to always step through during stepping.</summary>
      <returns>[Out] Array of no source ranges to always step through. This array will be empty if there are no no-source ranges for the given instruction.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolProviderCallback.TranslateAcceleratorTagByIP(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32,System.UInt32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>Translate accelerator pointer tag into HLSL register attributes.</summary>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="inputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="instructionPointer">[In] current instruction pointer used to obtain scope for pointer translation.</param>
      <param name="registerType">[Out] HLSL register type.</param>
      <param name="registerIndex">[Out] HLSL register index.</param>
      <param name="firstElement">[Out] Index of first vector element.</param>
      <param name="vectorElements">[Out] Number of vector elements.</param>
      <param name="byteOffset">[Out] Offset in bytes.</param>
      <param name="vectorElementSize">[Out] Size of each vector element.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery">
      <summary>This API is used to read information about a symbol for DPC++. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.GetAcceleratorTagTableSize(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32@)">
      <summary>Gets a C++ AMP address for a register.</summary>
      <returns>[Out] Maximum tag value found in actual C++ AMP pointers plus one.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="sizeOfForwardedTags">[Out] Maximum tag value that may be subject to buffer forwarding plus one.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.GetInstructionOffsetForRva(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32)">
      <summary>GetInstructionOffsetForRva is used by components to query symbol provider to perform instruction offset and RVA translation for DPC++.</summary>
      <returns>[Out] The instruction offset from stub function.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="rVA">[In] The RVA in a module.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.GetPointerToHLSLRegister(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean@)">
      <summary>Gets a C++ AMP address for a register.</summary>
      <returns>[Out] Address for register.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="registerType">[In] Type of HLSL register.</param>
      <param name="registerIndex">[In] Index of HLSL register.</param>
      <param name="firstElement">[In] Index of first vector element.</param>
      <param name="vectorElements">[In] Number of vector elements.</param>
      <param name="byteOffset">[In] Offset from start of register.</param>
      <param name="vectorElementSize">[In] Size of vector element.</param>
      <param name="rva">[In] RVA to use for mapping register information and tag address.</param>
      <param name="startLiveRange">[In] Start of live range for the symbol.</param>
      <param name="endLiveRange">[In] End of live range for the symbol.</param>
      <param name="isNewDynamicTag">[Out] Is the address newly generated by using dynamic tag.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.IsValidAcceleratorTag(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32,System.UInt32)">
      <summary>Verify if the accelerator pointer tag is valid.</summary>
      <returns>[Out] True if the given accelerator tag is valid at the given RVA. If RVA is zero, checks if the tag is valid anywhere including as a dynamically created tag.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="inputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="rva">[In] RVA to use for filtering; ignored if zero.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.SetPointerToHLSLRegister(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt64,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Sets a C++ AMP address for a register.</summary>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="address">[In] Address for register.</param>
      <param name="registerType">[In] Type of HLSL register.</param>
      <param name="registerIndex">[In] Index of HLSL register.</param>
      <param name="firstElement">[In] Index of first vector element.</param>
      <param name="vectorElements">[In] Number of vector elements.</param>
      <param name="byteOffset">[In] Offset from start of register.</param>
      <param name="vectorElementSize">[In] Size of vector element.</param>
      <param name="startLiveRange">[In] Start of live range for the symbol.</param>
      <param name="endLiveRange">[In] End of live range for the symbol.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQuery.TranslateAcceleratorTagByRva(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32,System.UInt32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>Translate accelerator pointer tag into HLSL register attributes using relative virtual address.</summary>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="inputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="rva">[In] RVA to use for filtering; ignored if zero.</param>
      <param name="registerType">[Out] HLSL register type.</param>
      <param name="registerIndex">[Out] HLSL register index.</param>
      <param name="firstElement">[Out] Index of first vector element.</param>
      <param name="vectorElements">[Out] Number of vector elements.</param>
      <param name="byteOffset">[Out] Offset in bytes.</param>
      <param name="vectorElementSize">[Out] Size of each vector element.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQueryCallback">
      <summary>Allows remote components to obtain source position information for DPC++ when the symbol provider is on the VS computer. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUSymbolQueryCallback.GetUserCodeSourcePositionCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the source file position (ex: example.cs, line 12) of this instruction symbol. If this instruction symbol is not associated with a source file or not in user code then null is returned (E_INSTRUCTION_NO_SOURCE return code).</summary>
      <returns>[Out,Optional] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUTempBreakStepper">
      <summary>Interface implemented by GPU base debug monitors to enable temporary instruction breakpoints in stepping. The temporary instruction breakpoints are passed to ContinueDebugEvent. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUTempBreakStepper.ClearTempBreak(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest)">
      <summary>Clears temporary breakpoint in stepping on a thread.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGPUTempBreakStepper.EnableTempBreak(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest,System.Int64[])">
      <summary>Enables temporary breakpoint in stepping on a thread. This resembles single step except one or more instructions are advanced. When breakpoint is hit, step complete event is sent.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
      <param name="tempBreakInstructions">[In] The instruction offset of temporary breakpoints to set.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGroupCompiledInspectionQueryProcessor">
      <summary>Used to execute compiled group expression processing. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompiledInspectionQueryKind, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGroupCompiledInspectionQueryProcessor.ExecuteQueryOnThreads(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery,Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection})">
      <summary>Executes a compiled inspection query and returns any results.</summary>
      <returns>[Out] Results of the evaluations.</returns>
      <param name="dkmILQuery">[In] An inspection query compiled to one or more DkmIL instructions.</param>
      <param name="iLContext">[In] The stack frame context we are evaluating on.</param>
      <param name="threads">[In] The compute threads to use when executing the query.</param>
      <param name="parameters">[In,Optional] Parameters to pass to each thread. The collection should be empty if unused, or have exactly as many members as the Threads parameter.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGroupLanguageExpressionEvaluator">
      <summary>This interface allows a language extension to evaluate expressions on a group of threads. It should generally be implemented by all language extensions. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmGroupLanguageExpressionEvaluator.EvaluateExpressionOnThreads(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult})">
      <summary>Bind the input expression and evaluate it. Then format the resulting value for display in the debugger. This is used for data tips, the watch windows, the immediate window, and so on</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="threads">[In] The compute threads to use when executing the query.</param>
      <param name="stackFrame">[In] Stack frame to match on compute threads.</param>
      <param name="expression">[In] Expression to evaluate.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmHeuristicStackWalker">
      <summary>IDkmHeuristicStackWalker is invoked by the stack provider. It is invoked when it tries to walk through frames without symbols. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmHeuristicStackWalker.HeuristicWalkFrames(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32,System.UInt64,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters@,System.Boolean@)">
      <summary>Attempt to walk through a region of the stack using a heuristic stack walk algorithm. This is used in x86 when no symbols are available. It is not implemented on other platforms as PDATA allows for walking of all frames.</summary>
      <returns>[Out] DkmStackWalkFrame[] represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
      <param name="stackWalkContext">[In] DkmStackWalkContext allows the various components which walk, filter, or examine call stacks to store private data which is associated with this call stack.</param>
      <param name="registers">[In] Registers to attempt to walk from.</param>
      <param name="requestSize">[In] RequestSize is the number of frames that the caller wants returned. The implementation of HeuristicWalkFrames may return fewer frames in the case that stack does not contain that many frames.</param>
      <param name="endStackPointer">[In] Stack address to stop the unwinding at. This value is UInt64.MaxValue if the no end stack pointer is present.</param>
      <param name="nextRegisters">[Out,Optional] NextRegisters indicates the registers of the next frame (the caller of 'FrameObject'). This will be null if the stack is complete, or if the EndStackPointer was reached.</param>
      <param name="endOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIISDebuggingServices">
      <summary>Interface to provide IIS debugging facilities to the SDM. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIISDebuggingServices.DiagnoseRemoteWebDebuggingError(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String)">
      <summary>Internal API to diagnose IIS start debugging failures.</summary>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="url">[In] URL that the debug verb was sent to.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIISResolver">
      <summary>Interface to provide URL-&gt;Work process resolution on the Visual Studio computer. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIISResolver.ResolveUrlToProcessIds(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String,System.String,System.String@)">
      <summary>Internal API to determine the IIS processes which the debugger should automatically attach to.</summary>
      <returns>[Out] IIS worker processes to attach to.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="url">[In] URL that the debug verb was sent to.</param>
      <param name="dnsNames">[In] Semi-colon delimitated string of addresses that URL's host name resolves to.</param>
      <param name="exceptionText">[Out,Optional] Exception text for any caught exception. This may be present in the S_FALSE case.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressOperator">
      <summary>Interface to provide runtime-specific operations for instruction addresses. For native and managed instructions, this service is provided by the symbol provider. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressOperator.IsInSameFunction(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Compares two instruction addresses and determines whether they are in the same function.</summary>
      <returns>[Out] True if the two addresses are from the same function.</returns>
      <param name="instructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="other">[In] An address to compare with this address.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressProvider">
      <summary>Interface to provide process-specific instruction addresses. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressProvider.GetInstructionAddress(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmWorkList,System.UInt64,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DkmGetInstructionAddressAsyncResult})">
      <summary>Resolves a CPU InstructionAddress to a DkmInstructionAddress.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="workList">The WorkList that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="instructionPointer">[In] Memory address where the native instruction is located.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressResolver">
      <summary>Interface to provide runtime-specific CPU address resolution. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressResolver.GetCurrentCPUAddress(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Resolves a DkmInstructionAddress to a CPU InstructionAddress. This is the reverse mapping of ResolveCPUInstructionAddress. This API is currently only supported by CLR DkmRuntimeInstance objects.</summary>
      <returns>[Out] An array of the current CPU Instruction Addresses that map to this DkmInstructionAddress.</returns>
      <param name="instructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionAddressResolver.ResolveCPUInstructionAddress(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.UInt64,System.Boolean@)">
      <summary>Resolves a CPU InstructionAddress to a runtime-specific DkmInstructionAddress object. This API is currently only supported by CLR DkmRuntimeInstance objects, and the CLR runtime instance can currently only find instruction addresses which are in a method that is currently on the call stack of one of the threads in the target process.</summary>
      <returns>[Out] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</returns>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="instructionPointer">[In] Memory address where the native instruction is located.</param>
      <param name="firstAddress">[Out] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionPatchNotification">
      <summary>Interface implemented by components that want to receive notification when the base debug monitor performs a memory write to the instruction stream. This interface may only be implemented in the monitor process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionPatchNotification.OnInstructionPatchInserted(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Method called by the base debug monitor to inform other components that the instruction memory of the target process was modified. Currently, this is only used for breakpoint insertion.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to write the target process's memory.</param>
      <param name="originalMemory">[In] The original code bytes which were replaced in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionPatchNotification.OnInstructionPatchRemoved(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Method called by the base debug monitor to inform other components that the instruction memory of the target process was restored to its original state. Currently, this is only used for breakpoint removal.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to write the target process's memory.</param>
      <param name="originalMemory">[In] The original code bytes which were restored in the target process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionStepper">
      <summary>Interface implemented by base debug monitors to provide instruction-level stepping primitives. This interface is consumed by runtime debug monitors to implement user-level execution control. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionStepper.ClearSingleStep(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest)">
      <summary>Disable single step on a thread.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInstructionStepper.EnableSingleStep(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest)">
      <summary>Enable single step on a thread. When then single step is finished, the SingleStepComplete event should be sent. The single step should reset after completion. Implementers should send one single step complete event per instance of DkmSingleStepRequest they receive. Callers must make a new request to single-step after this DkmSingleStepRequest is completed.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInterceptExceptionCompletedNotification">
      <summary>IDkmInterceptExceptionCompletedNotification is implemented by components that want to listen for the InterceptExceptionCompleted event. IDkmInterceptExceptionCompletedNotification is invoked after all implementations of IDkmInterceptExceptionCompletedReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent by a debug monitor after an exception has been unwound to a specified frame. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInterceptExceptionCompletedNotification.OnInterceptExceptionCompleted(Microsoft.VisualStudio.Debugger.DkmThread,System.UInt64,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnInterceptExceptionCompleted is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="cookie">[In] Cookie that was distributed when intercept exception request came in.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInterceptExceptionCompletedReceived">
      <summary>IDkmInterceptExceptionCompletedReceived is implemented by components that want to listen for the InterceptExceptionCompleted event. IDkmInterceptExceptionCompletedReceived is invoked before IDkmInterceptExceptionCompletedNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent by a debug monitor after an exception has been unwound to a specified frame. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmInterceptExceptionCompletedReceived.OnInterceptExceptionCompletedReceived(Microsoft.VisualStudio.Debugger.DkmThread,System.UInt64,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnInterceptExceptionCompletedReceived is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="cookie">[In] Cookie that was distributed when intercept exception request came in.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIntrinsicFunctionEvaluator">
      <summary>This interface allows an expression evaluator to specify intrinsic operations to be invoked through MSIL, which the EE is responsible for implementing. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmIntrinsicFunctionEvaluator.Execute(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic,Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult[],System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery},Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason@)">
      <summary>Executes an intrinsic function.</summary>
      <returns>[Out] The results of the evaluation to be pushed onto the MSIL stack (in order).</returns>
      <param name="executeIntrinsic">[In] Pops the arguments off the MSIL stack in reverse order (before the DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in order). Then executes an EE-defined operation that uses these values.</param>
      <param name="iLContext">[In] The stack frame context we are evaluating on.</param>
      <param name="arguments">[In] The arguments supplied to the intrinsic function.</param>
      <param name="subroutines">[In,Optional] Optional array of MSIL-based subroutines that the intrinsic function may decide to invoke during its operation.</param>
      <param name="failureReason">[Out] If an error occurs, specifies the reason for the error. To indicate an error code whose meaning is specific to the particular intrinsic function being executed, return a value less than zero.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmJustMyCodeEnableNotification">
      <summary>Interface to update components when JustMyCode is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmJustMyCodeEnableNotification.OnJustMyCodeChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'IsJustMyCodeEnabled' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine GUID (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageAsyncStepper">
      <summary>This interface is implemented by languages to enable stepping behavior for async methods. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageAsyncStepper.GetAsyncMethodIdentity(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>This method returns the identity of an async method. This is used to set conditional breakpoints for stepping over an await expression.</summary>
      <returns>[Out] The identity of the async method.</returns>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
      <param name="thread">[In] Stack frame that provides the context of in which to evaluate the expression.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageAsyncStepper.SetStepOutFlag(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>This method asks the language to set or clear a flag on the Task backing the async method. This flag enables stopping during step out of an async method.</summary>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
      <param name="thread">[In] Stack frame that provides the context of in which to evaluate the expression.</param>
      <param name="value">[In] If true set the flag, else clear the flag.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageConditionEvaluator">
      <summary>This interface is implemented by expression evaluators which live or the target computer and want to support conditional breakpoints. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageConditionEvaluator.EvaluateCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.Boolean@,System.String@)">
      <summary>Evaluates a condition to decide whether the debugger should stop.</summary>
      <param name="evaluationCondition">[In] Represents a condition which is evaluated on the target computer. These objects are used for languages where the expression evaluator is implemented on the target.</param>
      <param name="stackFrame">[In] The stack frame to use when you evaluate the condition.</param>
      <param name="stop">[Out] True if the breakpoint condition indicated that the IDE should stop.</param>
      <param name="errorText">[Out,Optional] If the condition could not be evaluated, this indicates the reason why. This value should be null if the compile succeeded.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageConditionEvaluator.ParseCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmEvaluationBreakpointCondition,System.String@)">
      <summary>Parses an input breakpoint condition so that it can later be evaluated. If the breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should require that the specified condition evaluates to a Boolean value. The created query must return only a single result. For BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any non-zero value is considered true.</summary>
      <param name="evaluationCondition">[In] Represents a condition which is evaluated on the target computer. These objects are used for languages where the expression evaluator is implemented on the target.</param>
      <param name="errorText">[Out,Optional] If the condition could not be parsed, this indicates the reason why. This value should be null if the compile succeeded.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionCompiler">
      <summary>This interface allows a language extension to pre-compile an expression so that the same expression may be quickly evaluated in multiple contexts. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionCompiler.Compile(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult@)">
      <summary>Compile the input expression so that it is ready for evaluation. A typical expression evaluator may lex the input string, parse the tokens, bind the tokens to symbols and possibly transform the expression into an intermediate representation for evaluation. However, because this method returns no result on success, all of this processing is optional and an expression evaluator may delay all of this work to the 'EvaluateExpression' method. The advantage of performing this work during 'Compile' is to issue any expression errors back to this user as soon as possible, and to improve the performance of repeated evaluations. Currently, these advantages appear in the user scenario of breakpoint conditions -- 'Compile' errors can be shown to the user before the dialog closes, and as breakpoints may be hit frequently, there may be noticeable performance advantages of moving work from 'Evaluate' to 'Compile'. 'Compile' may also be used in HPC scenarios where an expression is compiled against one input address and then evaluated against the same method in various other processes.</summary>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
      <param name="expression">[In] Expression to compile.</param>
      <param name="error">[Out,Optional] Indicates any error compiling the expression. On successful compilation, this value should be null. In error cases, this value is used to indicate the reason for the compilation failure, and the caller should return S_OK.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionCompiler.CompileCondition(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,System.String@)">
      <summary>Compiles an input breakpoint condition into an inspection query which can be evaluated on the target computer. If the breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should require that the specified condition evaluates to a Boolean value. The created query must return only a single result. For BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any non-zero value is considered true.</summary>
      <returns>[Out,Optional] The result of the compilation. This is null in the case that the compilation failed. In this case, ErrorText should indicate the reason for the failure.</returns>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
      <param name="condition">[In] Breakpoint condition to compile.</param>
      <param name="errorText">[Out,Optional] If the compilation failed, this indicates the reason why. This value should be null if the compile succeeded. If the compile does fail, S_FALSE is returned (native code only).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator">
      <summary>This interface allows a language extension to evaluate expressions in the various data inspection windows of the debugger (Watch, Autos, Immediate, Memory, Disassembly, etc.). It should generally be implemented by all language extensions. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.EvaluateExpression(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult})">
      <summary>Binds the input expression and evaluates it, and then formats the resulting value for display in the debugger. This is used for data tips, the watch windows, the Immediate window, and so on</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="expression">[In] DkmLanguageExpression represents an expression to be parsed and evaluated by an expression evaluator.</param>
      <param name="stackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.GetChildren(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult})">
      <summary>Gets an enumeration context used to obtain the children of this evaluation result. This is used in all expression evaluation windows.</summary>
      <param name="result">[In] The formatted result of an evaluation, ready to be displayed in an expression evaluation window.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="initialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be at first returned. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes, which would cause out-of-memory if all elements were requested.</param>
      <param name="inspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.GetFrameArguments(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult})">
      <summary>Provides information about the arguments of a stack frame. This is currently only exposed through the Visual Studio automation model (EnvDTE.StackFrame.Arguments).</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="frame">[In] Walked frames that the evaluator is requested to describe.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.GetFrameLocals(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult})">
      <summary>Gets an enumeration context used to obtain the local variables of this stack frame. This is used in computing the Locals window.</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="stackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.GetItems(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext,Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult})">
      <summary>Obtains DkmEvaluationResult items from this enumeration context. This is used to obtain local variables of a stack frame or child members from an evaluation result.</summary>
      <param name="enumContext">[In] Context object that is used to enumerate child members of an evaluation result or to enumerate local variables from a stack frame. This is logically similar to an enumerator, except that access to elements is index-based instead of sequential.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="startIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes, which would cause out-of-memory if all elements were requested.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.GetUnderlyingString(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window. (Click the magnifying glass icon.)</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
      <param name="result">[In] The formatted result of an evaluation, ready to be displayed in an expression evaluation window.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageExpressionEvaluator.SetValueAsString(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows.</summary>
      <param name="result">[In] The formatted result of an evaluation, ready to be displayed in an expression evaluation window.</param>
      <param name="value">[In] Textual representation of the value to assign to the evaluation result.</param>
      <param name="timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="errorText">[Out,Optional] If the operation failed, this indicates why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageFrameDecoder">
      <summary>This interface allows a language extension to format the display of function names in the call stack window. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageFrameDecoder.GetFrameName(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult})">
      <summary>Provides a text representation for a stack frame. This is used when it builds the formatted call stack.</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="frame">[In] Walked frames which the evaluator is requested to describe.</param>
      <param name="argumentFlags">[In] Flags to indicate what information about the arguments should be included in the frame name.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageFrameDecoder.GetFrameReturnType(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult})">
      <summary>Provides a text representation of the return type for one or more stack frame. This is currently only exposed through the VS automation model (EnvDTE.StackFrame.ReturnType).</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="frame">[In] Walked frames which the evaluator is requested to describe.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageInstructionDecoder">
      <summary>This interface allows a language extension to format the display of the 'Function' column in the Breakpoints window and other locations that attempt to format an instruction address. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageInstructionDecoder.GetMethodName(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress,Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags)">
      <summary>Provides a text representation for a method symbol. This is used when describing an address in the UI, for example the 'Function' column in the Breakpoints window.</summary>
      <returns>[Out] Language's representation of the name of this method.</returns>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
      <param name="argumentFlags">[In] Flags to indicate what information about the arguments should be included in the method name. As parameter values cannot be obtained without a stack frame and a stack frame is not available here, the "Values" flag will never be present.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageObjectIdProvider">
      <summary>This is an optional interface implemented by expression evaluators. It should be implemented by expression evaluators which return evaluation results with the 'CanHaveObjectId' flag. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageObjectIdProvider.CreateObjectId(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>Creates an object id for this particular expression.</summary>
      <param name="result">[In] The formatted result of an evaluation, ready to be displayed in an expression evaluation window.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageObjectIdProvider.DestroyObjectId(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>Destroys an object id for this particular expression.</summary>
      <param name="result">[In] The formatted result of an evaluation, ready to be displayed in an expression evaluation window.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageReturnValueEvaluator">
      <summary>This interface allows a language extension to evaluate return values as collected by a runtime during stepping. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageReturnValueEvaluator.EvaluateReturnValue(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult})">
      <summary>Evaluates and formats a given DkmRawReturnValue using only the provided data.</summary>
      <param name="inspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="stackFrame">[In] Stack frame that provides the context of in which to evaluate the expression.</param>
      <param name="rawReturnValue">[In] Return value target and cached context.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageStepIntoFilterCallback">
      <summary>This interface allows a language extension to affect the Step-Into behavior of the native runtime. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, EngineId, LanguageId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLanguageStepIntoFilterCallback.GetStepIntoFlags(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress)">
      <summary>Called during a Step-Into to determine special behavior for a particular function.</summary>
      <returns>[Out] Flags that describe how to continue with a Step-Into action.</returns>
      <param name="languageInstructionAddress">[In] Pairing between an instruction address and the language that should be used to decode it.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLaunchResumeProcess">
      <summary>IDkmLaunchResumeProcess is used to start and resume a process. It is called from the debug monitor in F5, and from the transport in Ctrl-F5. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLaunchResumeProcess.LaunchProcess(Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest,System.Int32)">
      <summary>This API is remote-able version of the Win32 CreateProcess API. The implementation will merge the environment block, process command line redirection and start the process. Unless the NoDebug flag is used, CreateProcess will use the DEBUG_PROCESS flag when it creates the Win32 process.</summary>
      <returns>[Out] DkmLaunchedProcessInfo is returned from APIs that start a process.</returns>
      <param name="request">[In] DkmProcessLaunchRequest is used to describe the process that debugger should start.</param>
      <param name="additionalWin32Flags">[In] Win32 process creation flags and also to those found in the DkmProcessLaunchRequest.Win32Flags. This is often used to pass DEBUG_PROCESS (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLaunchResumeProcess.ResumeProcess(Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest)">
      <summary>This API is used to resume a process which was started from CreateProcess with the LaunchSuspended flag set to true.</summary>
      <param name="request">[In] DkmProcessLaunchRequest is used to describe the process that debugger should start.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLoadCompleteNotification">
      <summary>IDkmLoadCompleteNotification is implemented by components that want to listen for the LoadComplete event. When this notification fires, the target process will be suspended and can be examined. LoadComplete is sent by the base debug monitor when starting or attaching to the process has completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmLoadCompleteNotification.OnLoadComplete(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnLoadComplete is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalQuickAbortServices">
      <summary>Interface to support managed func-eval quick abort. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalQuickAbortServices.OnFuncEvalQuickAbortDllLoaded(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Notifies the result of the attempt to load the FEQA DLL.</summary>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="result">[In] Specifies whether the FEQA DLL was successfully loaded.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalQuickAbortServices.PrepareForFuncEvalQuickAbort(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean@,System.UInt64@)">
      <summary>Checks to see whether we should load the FEQA DLL.</summary>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="skipLoad">[Out] Specifies whether the FEQA DLL should be loaded. The hosting process could have loaded it already.</param>
      <param name="memoryAddress">[Out] Specifies the address in debuggee process. Valid only if AlreadyLoaded is false.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalServices">
      <summary>The interface provided by the managed debug monitor to continue the process for a managed function evaluation. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalServices.CanDoFuncEval(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Checks whether the given thread is in a state in which the CLR supports managed func-evals.</summary>
      <returns>[Out] The result of doing the function evaluation. S_OK if all went well. Other possible values include E_EVAL_FUNCEVAL_IN_MINIDUMP or S_EVAL_BAD_THREAD_STATE.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedFuncEvalServices.ContinueForFuncEval(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.CorDebugInterop.ICorDebugEval,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,System.UInt32,System.String)">
      <summary>Continue the process and wait for a func-eval to finish.</summary>
      <returns>[Out] The result of doing the function evaluation. S_OK if all went well. Other possible values include S_EVAL_TIMEDOUT, S_EVAL_ABORTED, or E_PROCESS_DESTROYED.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="thread">[In] The thread for which to do the func-eval.</param>
      <param name="corEval">[In] The object.</param>
      <param name="funcEvalFlags">[In] Function evaluation flags.</param>
      <param name="timeout">[In] The time-out.</param>
      <param name="evaluationString">[In] The text being evaluated. Displayed in the call stack window if the function evaluation re-enters break mode.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedThreadProperties">
      <summary>Exposes properties of a managed thread such as Managed Thread ID. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmManagedThreadProperties.GetManagedThreadProperties(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32@)">
      <summary>Get a managed thread's properties.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="managedThreadId">[Out] The managed thread id of the thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMemoryOperation">
      <summary>Implemented by base debug monitors to provide access to the memory of the target process. This interface is also implemented by higher level components to provide memory caching. Base debug monitors are responsible for performing the memory I/O, maintaining a table of invisible writes, and providing events when the invisible write table is updated (via DkmProcess.OnInstructionPatchInserted/Removed). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMemoryOperation.InvisibleWriteMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Write memory to the target process, but hide the write from calls to ReadMemory. This API may be used to patch instructions or data in the target process to implement debugger features. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size can be accessed for write access, and if it cannot be accessed, the function raises an E_INVALID_MEMORY_ADDRESS error.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to write the target process's memory.</param>
      <param name="data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMemoryOperation.ReadMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Byte[])">
      <summary>Read the memory of the target process.</summary>
      <returns>[Out] Indicates the number of bytes read from the target process. If DkmReadMemoryFlags.AllowPartialRead is clear, on success this value will always be exactly equal to the input size. If DkmReadMemoryFlags.AllowPartialRead is specified, on success, this value will be greater than zero.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to read the target process's memory.</param>
      <param name="flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMemoryOperation.ReadMemoryString(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.UInt16,System.Int32)">
      <summary>Reads a null-terminated string from the target process process's memory. This can be used to read an ANSI or Unicode (UTF-8, UTF-16 or UTF-32) strings.</summary>
      <returns>[Out] The value of the string which was read from the target process. If DkmReadMemoryFlags.AllowPartialRead is clear, this memory will always include the null termination character. If DkmReadMemoryFlags.AllowPartialRead is specified, this buffer will not contain the null termination character if the read was truncated.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to read the target process's memory.</param>
      <param name="flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="characterSize">[In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).</param>
      <param name="maxCharacters">[In] The maximum number of characters to read from the target process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null terminator is not found within this range. This value should be reasonable. The Microsoft implementation will fail any request for more than 128MBs of string memory.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address is not valid. See 'DkmReadMemoryFlags.AllowPartialRead' documentation for more information.-or-E_STRING_TOO_LONG indicates that the string could not be read in the specified maximum number of characters.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMemoryOperation.WriteMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Writes memory to the target process. Before data transfer occurs, the system verifies that all data in the base address and memory of the specified size can be accessed for write access, and if it cannot be accessed, the function raises an E_INVALID_MEMORY_ADDRESS error.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to write the target process's memory.</param>
      <param name="data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMergedMonitorStackWalk">
      <summary>IDkmMergedMonitorStackWalk is invoked by the stack provider. It will arbitrate between the various implementations of IDkmMonitorStackWalk to walk parts of the stack which should be walked inside the monitor (instead of walked inside the engine). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMergedMonitorStackWalk.GetTopStackWalkFrame(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>Return the top stack frame for a thread. This frame can come from a runtime instance, or a monitor unwinder. This can only be called from the server process. To obtain the top frame in the client process, use GetTopStackFrame.</summary>
      <returns>[Out] The top stack frame.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="runtimeInstance">[In] The runtime instance of the frame.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMergedMonitorStackWalk.RuntimeWalkNextFrames(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext,System.UInt32,System.Boolean@)">
      <summary>Attempt to walk the stack without the use of symbols. This will call into various components that know how to walk parts of the stack (ex: CLR frames will be walked by the CLR debug monitor). An 'unresolved' frame will be left for parts of the stack which cannot be walked without information stored in the symbol file. These 'unresolved' frames have no InstructionAddress or Description.</summary>
      <returns>[Out] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</returns>
      <param name="stackWalkContext">[In] DkmStackWalkContext allows the various components which walk, filter, or examine call stacks to store private data which is associated with this call stack.</param>
      <param name="requestSizeHint">[In] RequestSizeHint is a hint as to the number of frame that the caller needs.</param>
      <param name="endOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMergedMonitorStackWalk.RuntimeWalkNextFramesAndCheckCache(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext,System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash,System.Boolean@,Microsoft.VisualStudio.Debugger.CallStack.DkmStackHash@,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkContext@,System.Boolean@)">
      <summary>Version of RuntimeWalkNextFrames() that also checks if a cached copy of the call stack is still valid.</summary>
      <returns>[Out] Array of walked frames. For, unresolved frames, both InstructionAddress and Description will be null.</returns>
      <param name="stackWalkContext">[In] DkmStackWalkContext allows the various components which walk, filter, or examine call stacks to store private data which is associated with this call stack.</param>
      <param name="requestSizeHintIfCacheIsValid">[In] RequestSizeHintIfCacheIsValid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value. A request size hint of 0 means not to do any stack walking at all if the cache is valid.</param>
      <param name="requestSizeHintIfCacheIsInvalid">[In] RequestSizeHintIfCacheIsInvalid is a hint as to the number of frame that the caller needs. This value is treated as a hint because this API can return frames which are not yet walked. Therefore this API may return more or less than the hint value.</param>
      <param name="cachedHash">[In,Optional] Cached call stack hash, will not walk the stack if cache is still valid. This parameter is optional. If null, we will still compute the actual hash and do the stack walk, but will skip the comparing of the actual hash against the cached hash to suppress the stack walk.</param>
      <param name="endOfStack">[Out] Returns true if the monitor reached the end of the stack.</param>
      <param name="actualStackHash">[Out,Optional] The actual hash of the call stack. This may be NULL for runtimes that do not support call stack hashing.</param>
      <param name="actualStackWalkContext">[Out] The DkmStackWalkContext object that can used later to continue the walk. If the cache is valid, this is the original context. If the cache is invalid, this will be a new DkmStackWalkContext object.</param>
      <param name="isCacheValid">[Out] True if the cache was valid, false if not.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleCreateNotification">
      <summary>IDkmModuleCreateNotification is implemented by components that want to listen for the ModuleCreate event. The target process may continue to run during this notification. ModuleCreate is sent by the symbol provider in response to a ModuleLoad for a module that has not yet been seen in this debug session. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleCreateNotification.OnModuleCreate(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnModuleCreate is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceDisabledNotification">
      <summary>Interface implemented by debug monitors to perform any updates when the 'Disabled' property of a module changed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceDisabledNotification.OnDisabledChanged(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Performs any updates needed when the 'Disabled' state changes.</summary>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceLoadNotification">
      <summary>IDkmModuleInstanceLoadNotification is implemented by components that want to listen for the ModuleInstanceLoad event. When this notification fires, the target process will be suspended and can be examined.  Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceLoadNotification.OnModuleInstanceLoad(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>Invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceUnloadNotification">
      <summary>IDkmModuleInstanceUnloadNotification is implemented by components that want to listen for the ModuleInstanceUnload event. When this notification fires, the target process will be suspended and can be examined. ModuleInstanceUnload is sent when the monitor detects that a module has unloaded in the target process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleInstanceUnloadNotification.OnModuleInstanceUnload(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnModuleInstanceUnload is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="moduleInstance">[In] The Module Instance class represent a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="workList">WorkList to append additional event processing work to. This work list will begin execution after all listeners have been notifiied. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleLocator">
      <summary>Interface implemented by debug monitors that support debugging dumps to allow the UI to search for binaries that were not found when the dump originally loaded. The symbol path is updated by the UI if the user chooses a path when they search for the binary. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleLocator.TryLoadBinary(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Attempts to load a binary that previously did not load using updated symbol paths.</summary>
      <param name="moduleInstance">[In] The module instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, module instance objects are 1:1 with base address.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsLoaded">
      <summary>Interface implemented by base debug monitors to fire a symbols loaded event. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsLoaded.RaiseSymbolsLoadedEvent(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Boolean)">
      <summary>After a symbol provided has loaded symbols, this method will be invoked by the dispatcher to cause a ModuleSymbolsLoaded event to be raised. Base debug monitors should implement the interface by transitioning to their event thread and calling DkmModuleInstance.OnSymbolsLoaded.</summary>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="module">[In] The DkmModule that is associated with the DkmModuleInstance.</param>
      <param name="isReload">[In] True if symbols are being reloaded for an existing module; False if this is occurring as part of module load processing.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsLoadedNotification">
      <summary>IDkmModuleSymbolsLoadedNotification is implemented by components that want to listen for the ModuleSymbolsLoaded event. When this notification fires, the target process will be suspended and can be examined. ModuleSymbolsLoaded is sent after symbols have been loaded for a particular module instance. This is sent either when symbols are loaded as a .dll/.exe loads in the target process or after the user asks to reload symbols. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsLoadedNotification.OnModuleSymbolsLoaded(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Boolean,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnModuleSymbolsLoaded is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers all of these to be identical, there will be only one module object.</param>
      <param name="isReload">[In] True if symbols are being reloaded for an existing module; false if this is occurring as part of module load processing.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsUpdatedNotification">
      <summary>IDkmModuleSymbolsUpdatedNotification is implemented by components that want to listen for the ModuleSymbolsUpdated event. When this notification fires, the target process will be suspended and can be examined. ModuleSymbolsUpdated is sent by a debug monitor when dynamic code in the target process updates the symbol state. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmModuleSymbolsUpdatedNotification.OnModuleSymbolsUpdated(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnModuleSymbolsUpdated is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers all of these to be identical, there will be only one module object.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMonitorStackWalk">
      <summary>Examines the part of the stack that is from a particular DkmRuntimeInstance and returns frames from this runtime. IDkmMonitorStackWalk is used to do this walking on the target computer and generally does this walk without symbols. It should be noted that accurate monitor stack walk generally requires one of the following: 1) The runtime monitor to fully understand the calling convention of its underlying runtime and the runtime uses some mechanism so that it does not need code from other runtimes that are on the stack to be walked. For example, the CLR maintains stack ranges so when managed code calls off into native, the CLR can still find the managed code without having to walk through native. 2) A uniform calling convention that all code must follow. For example, all code must follow a uniform calling convention on x64 and IA64 versions of Windows. Microsoft will provide five implementations of IDkmMonitorStackWalk: 1. An implementation for ICorDebug v2. 2. An implementation for ICorDebug v4. 3. An implementation for x64/IA64 PDATA walking. 4. An implementation for ActiveScript. 5. A default implementation that bundles together unknown regions to be walked in the engine process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMonitorStackWalk.Initialize(Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)">
      <summary>Initialize is invoked on each walker exactly one time at the start of the walk process. This gives each walker a chance to initialize any state.</summary>
      <param name="monitorStackWalkContext">[In] DkmMonitorStackWalkContext allows the various components DkmSymbolStackWalkContext with this call stack.</param>
      <param name="registers">[In] Registers to attempt to walk from.</param>
      <param name="stackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMonitorStackWalk.UpdatePosition(Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)">
      <summary>UpdatePosition is invoked by the stack merger after another walker has walked one or more frames, and so this walker must be updated before invoking WalkNextFrame. Runtimes that maintain their own internal stack range state within in the target process will likely have nothing to do within this method.</summary>
      <param name="monitorStackWalkContext">[In] DkmMonitorStackWalkContext allows the various components DkmSymbolStackWalkContext with this call stack.</param>
      <param name="registers">[In] Registers to attempt to walk from.</param>
      <param name="stackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmMonitorStackWalk.WalkNextFrame(Microsoft.VisualStudio.Debugger.CallStack.DkmMonitorStackWalkContext)">
      <summary>Attempt to walk the next stack frame. The DkmMonitorStackWalkResult structure indicates whether this monitor was able to walk the frame.</summary>
      <returns>[Out] Return result from IDkmMonitorStackWalk.</returns>
      <param name="monitorStackWalkContext">[In] DkmMonitorStackWalkContext allows the various components DkmSymbolStackWalkContext with this call stack.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNameUndecorator">
      <summary>This API is used to undecorate symbol names. Microsoft provides an implementation of this to undecorate symbol names in PDBs. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNameUndecorator.UndecorateName(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,System.UInt32)">
      <summary>Undecorates a symbol name.</summary>
      <returns>[Out] The undecorated name.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="decoratedName">[In] The name to be undecorated.</param>
      <param name="options">[In] Options to change the undecorated name. These are specific to the implementation being used. For Microsoft PDB, pass one or more of the values described in the documentation for DbgHelp.dll UnDecorateSymbolName or one of these three extended options: UNDNAME2_STRIP_ILT 0x10000 - to remove the leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to remove leading "const" from the front of the string UNDNAME2_STRINGS 0x30000 - to use pooled strings by name.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeDebuggingEnableNotification">
      <summary>Interface to update components when native debugging is enabled or disabled for a particular process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeDebuggingEnableNotification.OnNativeDebuggingEnabledChanged(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Called when 'IsNativeDebuggingEnabled' is changed.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeExportsEnableNotification">
      <summary>Interface to update components when 'IsNativeExportsEnabled' is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeExportsEnableNotification.OnNativeExportsChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'IsNativeExportsEnabled' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeExportTableDecoder">
      <summary>Provides decoding of export tables in Windows PE files. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeExportTableDecoder.FindExportName(Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance,System.String,System.Boolean)">
      <summary>Finds the address of the specified named exported function (or data export).</summary>
      <returns>[Out,Optional] If the export was found in the specified module, this will contain the target address. Note that this instruction address object may be in a different module than the searched module. This can occur if the export was forwarded and the destination module is already loaded. If the destination module is not loaded, the export will be ignored.</returns>
      <param name="nativeModuleInstance">[In] 'DkmNativeModuleInstance' is used for modules which contain CPU code and are loaded by the Win32 loader.</param>
      <param name="name">[In] The export name to search for in the module's export table.</param>
      <param name="ignoreDataExports">[In] If true, the implementation will ignore any export which is in non-executable memory.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeExportTableDecoder.FindNearestExport(Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress,System.Int32@)">
      <summary>Finds the nearest module export from the specified instruction address. The export could be either a function or data export, although function exports are far more common. Because exports do not have address ranges, the specified address may not actually be associated with the returned export.</summary>
      <returns>[Out,Optional] Name of the export.</returns>
      <param name="nativeAddress">[In] DkmNativeInstructionAddress is used for addresses that resolve to a native module. This is used regardless as to if there are symbols for the module.</param>
      <param name="byteOffset">[Out] Byte offset from the start of the export.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeStackCallback">
      <summary>Provides a mechanism for the Base Debug Monitor and Native Debug Monitor to obtain information about the stack frames that may require symbol support. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeStackCallback.GetCurrentFrameInfo(Microsoft.VisualStudio.Debugger.DkmThread,System.UInt64@,System.UInt64@,System.UInt64@)">
      <summary>Used to obtain the frame base and return address for the current context of the thread. This considers Frame Pointer Omission and whether the current instruction pointer is in a prolog, epilog, etc. Note: In some cases, this will get it wrong if the frame has Frame Pointer Omission and there are no symbols loaded.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="returnAddress">[Out] The return address of the frame.</param>
      <param name="frameBase">[Out] The frame base of the frame.</param>
      <param name="vFrame">[Out] The vframe of the current frame. Only valid on x86.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeSteppingCallSiteProvider">
      <summary>Called by Native IDkmSteppingCodePathDecoder implementer to enumerate Native CodePaths. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeSteppingCallSiteProvider.GetSteppingCallSites(Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress,Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange[])">
      <summary>GetSteppingCallSites is called to obtain call sites reachable from an instruction.</summary>
      <returns>[Out] DkmNativeSteppingCallSite[] specifies a call instruction and its target..</returns>
      <param name="nativeAddress">[In] DkmNativeInstructionAddress is used for addresses that resolve to a native module. This is used regardless as to if there are symbols for the module.</param>
      <param name="steppingRanges">[In] The stepping ranges to evaluate for call sites.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeSymbolProviderCallback">
      <summary>Callback interface that is implemented by the PDB symbol provider for returning information about symbols to the base debug monitor. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeSymbolProviderCallback.GetNativeInstructionMetadataCallback(Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionSymbol,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmNativeSymbolProviderCallback.GetPublicSymbolByNameCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String)">
      <summary>Returns the RVA for an S_PUBLIC32 for a particular name by string.</summary>
      <returns>[Out,Optional] The native instruction symbol for this public symbol.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers of all these to be identical, there will be only one module object.</param>
      <param name="publicName">[In] The name of the public symbol to look up.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmPendingFileLineBreakpointCallback">
      <summary>This interface is implemented by components that want to add DkmPendingFileLineBreakpoint objects to the breakpoint manager. The breakpoint manager will query for the current location on the first bind and during an Edit-and-Continue apply. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmPendingFileLineBreakpointCallback.GetCurrentSourcePosition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint)">
      <summary>Returns the current location of a file/line breakpoint. In edit and continue scenarios, the location of the text marker may change in a debug session.</summary>
      <returns>[Out] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
      <param name="fileLineBreakpoint">[In] Pending breakpoint which is requested to bind against code elements that point back to a text span in a source file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmPendingFileLineBreakpointCallback.GetCurrentSourceText(Microsoft.VisualStudio.Debugger.Breakpoints.DkmPendingFileLineBreakpoint)">
      <summary>Returns the current text at the location of a file/line breakpoint.</summary>
      <returns>[Out,Optional] The current source text.</returns>
      <param name="fileLineBreakpoint">[In] Pending breakpoint which is requested to bind against code elements that point back to a text span in a source file.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessContinueNotification">
      <summary>Provides notification when the target process is about to be resumed. This will be fired after the user hits F5, starts a func-eval, a pausing event is complete (ex: module load) or a stopping event is completed. This primary purpose of this event is to allow for components to flush any caches that they have. This notification may be fired from any thread, but will not be fired reentrantly. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessContinueNotification.OnProcessContinue(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Handler which is notified before the target process is resumed.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessCreateNotification">
      <summary>IDkmProcessCreateNotification is implemented by components that want to listen for the ProcessCreate event. When this notification fires, the target process will be suspended and can be examined. ProcessCreate is fired when a DkmProcess object is created. This indicates that the debugger has started attaching to the specified process. In launch scenarios, this event is fired before any code in the target process can run. Implementations can only crudely filter based on the type of code in the target process, and handlers will also run when the UI thread is blocked waiting for the engine to return. For these reasons, it is often better to listen for the RuntimeInstanceLoad event instead. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessCreateNotification.OnProcessCreate(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnProcessCreate is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="workList">Work list to append additional event processing work to. This work list will begin execution after all listeners have been notified. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessExitNotification">
      <summary>IDkmProcessExitNotification is implemented by components that want to listen for the ProcessExit event. The target process may continue to run during this notification. ProcessExit is fired when the debugger is no longer debugging the specified process. This can be either because the debugger has detached from the specified process or because the process exited. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessExitNotification.OnProcessExit(Microsoft.VisualStudio.Debugger.DkmProcess,System.Int32,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnProcessExit is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="exitCode">[In] 32-bit value that the processed returned on exit. This is the same value that would be reported from the kernel32!GetExitCodeProcess.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessLaunchEnvironmentFilter">
      <summary>Optional interface that can be implemented to customize the environment of the target process before it is started. It is possible to customize the environment from two points. From the IDE side, the caller of LaunchDebugTargets can specify an environment block. From the debug monitor side, this API can be implemented. This API is suggested if either the IDE side does not have enough information to correctly specify the environment, or if the extension does not control the call to LaunchDebugTargets. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small .dll, or that the implementation be configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessLaunchEnvironmentFilter.GetAdditionalEnvironmentVariables(Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings,Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario)">
      <summary>Obtains any environment variables that the extension wants to add.</summary>
      <returns>[Out,Optional] One or more environment variables that should be passed to the target process. Multiple variables are separated with an embedded null ('\0'). For example: "MyVariable1=1\0MyVariable2=12". Null or empty string are returned if the caller does not want to customize the environment block for this launch.</returns>
      <param name="debugLaunchSettings">[In] Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</param>
      <param name="scenario">[In] Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter implementations are invoked.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessQueryOperation">
      <summary>Queries state about the debuggee process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessQueryOperation.GetHandleCount(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Obtains the number of active handles in the process.</summary>
      <returns>[Out] The number of handles in the debuggee process.</returns>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessQueryOperation.GetRunningTime(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Obtains the number of clock cycles that the debuggee has been running since ResetRunningTime() was last called.</summary>
      <returns>[Out] The time the debuggee has been running.</returns>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmProcessQueryOperation.SetRunningTime(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64)">
      <summary>Sets the running time counter to the specified value.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="runningTime">[In] The value to set the clock to.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRegisterWrite">
      <summary>Provides the ability to read or write a register value by CV constant. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRegisterWrite.SetRegisterValue(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Sets the value of the register in the thread's context. Subregisters that consist of larger registers are supported.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="stackWalkFrame">[In] The stack frame the register is being set in. For most runtime instances, this is used to verify that the stack frame is the top of the stack and stop the write if it is not.</param>
      <param name="registerIndex">[In] The CV constant of the register to set.</param>
      <param name="value">[In] The value to set the register to. The size of the byte array must match the width of the register being set.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRequireFullTrustForSourceServerNotification">
      <summary>Interface to update components when RequireFullTrustForSourceServer is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRequireFullTrustForSourceServerNotification.OnRequireFullTrustForSourceServerChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'RequireFullTrustForSourceServer' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmReturnValuesNotification">
      <summary>IDkmReturnValuesNotification is implemented by components that want to listen for the ReturnValues event. The target process may continue to run during this notification. The ReturnValues event is sent during a step, when one or more DkmRawReturnValues have been collected. The actual evaluation will be performed on the StepComplete event on the thread where the return values were recorded. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmReturnValuesNotification.OnReturnValues(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue},System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnReturnValues is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="returnValues">[In,Optional] DkmRawReturnValues recorded.</param>
      <param name="lastValueInCurrentContext">[In] If true, it is valid to use the current thread context to evaluate the last return value. This is true only in the case immediately after it processes the return instruction, and so should only be set if raising this event immediately before, and on the same thread, as the StepComplete event.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider">
      <summary>Interface implemented by the base DM services to provide a process listing, and provide basic information about running processes without attaching a debugger to the process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.EnumRunningProcesses(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Boolean,Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask)">
      <summary>Provides a listing of all the processes running on the target computer (including processes not being debugged).</summary>
      <returns>[Out] Array of processes running on the target computer.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="includeFromAllUsers">[In] If true, processes from all users should be included.</param>
      <param name="requestedPropertyMask">[In] Flags indicating which properties of DkmRunningProcessInfo should be computed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.GetClrVersionOfExecutable(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String)">
      <summary>Provides the version string for the CLR that the debugger expects a given executable to load. The return value is based on the content of the executable's PE header (if the exe is managed), the executable's config file, CLR environment variables, and loader policy in the registry. The return value may be incorrect, especially for a native executable.</summary>
      <returns>[Out] Version string of the CLR. Ex:'v4.0.30319'.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="exePath">[In] Path to the executable file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.GetDefaultClrVersion(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection)">
      <summary>Returns the version of the CLR which is loaded in the monitor process.</summary>
      <returns>[Out] Version string of the CLR. Ex:'v4.0.30319'.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.GetRunningProcessInfo(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Int32,System.Int64,System.Boolean,Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask)">
      <summary>Obtain information about a process that is running on the target computer.</summary>
      <returns>[Out] Information about the requested process.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="startTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process. '0' can be passed if the start time is unknown.</param>
      <param name="isDebuggee">[In] When true, the request will fail if the debugger has insufficient permissions to complete the request. If false, the implementation should calculate what it can.</param>
      <param name="requestedPropertyMask">[In] Flags indicating which properties of DkmRunningProcessInfo should be computed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.GetSystemInformation(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Boolean)">
      <summary>Provides information about the computer where the debug monitor is running.</summary>
      <returns>[Out] Object describing the system where the debugger is running.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="nativeSystemInfo">[In] If true and if the debug monitor is running under WOW64, this function will return information about the native subsystem instead of WOW. If the debug monitor is not running under WOW, this function is ignored.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.PrepareForDebuggingProcess(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Int32,System.Int64,Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask)">
      <summary>Called by the SDM before start debugging. It is used to obtain current information about the process, make sure that the process can be debugged, and to make any operating system configuration changes (ex: enabling enhanced error reporting) to improve debugging.</summary>
      <returns>[Out] Information about the requested process.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="startTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process. '0' can be passed if the start time is unknown.</param>
      <param name="requestedPropertyMask">[In] Flags indicating which properties of DkmRunningProcessInfo should be computed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.QueryIsWOW64Executable(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String)">
      <summary>Determines if the given executable file will execute within WOW64 (Windows On Windows), which is used to execute 32-bit processes on a 64-bit OS.</summary>
      <returns>[Out] true if the specified executable file will execute under WOW.</returns>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="exePath">[In] Path to the executable file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRunningProcessInfoProvider.TerminateRunningProcess(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Int32,System.Int64,System.Int32)">
      <summary>Terminates a process that is running on target computer which is not being debugged.</summary>
      <param name="connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="startTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process. '0' can be passed if the start time is unknown.</param>
      <param name="exitCode">[In] The exit code that will be used by the process and threads terminated because of this call. Use the GetExitCodeProcess function to retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a thread's exit value.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeBreakpointNotification">
      <summary>IDkmRuntimeBreakpointNotification is implemented by components that want to listen for the RuntimeBreakpoint event. IDkmRuntimeBreakpointNotification is invoked after all implementations of IDkmRuntimeBreakpointReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit. Runtime breakpoints are the low-level breakpoint objects. Notification for the higher level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the BoundBreakpointHit event. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeBreakpointNotification.OnRuntimeBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnRuntimeBreakpoint is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread that hit the breakpoint. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeBreakpointReceived">
      <summary>IDkmRuntimeBreakpointReceived is implemented by components that want to listen for the RuntimeBreakpoint event. IDkmRuntimeBreakpointReceived is invoked before IDkmRuntimeBreakpointNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Provides notification that a runtime breakpoint (DkmRuntimeBreakpoint) has been hit. Runtime breakpoints are the low-level breakpoint objects. Notification for the higher level breakpoints (DkmPendingBreakpoint/DkmBoundBreakpoint) is obtained through the BoundBreakpointHit event. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeBreakpointReceived.OnRuntimeBreakpointReceived(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnRuntimeBreakpointReceived is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the thread that hit the breakpoint. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeFunctionResolver">
      <summary>This interface is implemented by expression evaluators that are loaded on the target computer to map between a function/address expression and the instructions that are represented by it. This is used to bind function breakpoints. In addition to expression evaluators, this interface may also be implemented by other components that might want to bind function breakpoints using data from the target process (ex: native export function breakpoints). Components filtering based on LanguageId and VendorId should make sure that Guid.Empty is one of the accepted values in their filter. See DkmRuntimeFunctionResolutionRequest.CompilerId for more information. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeFunctionResolver.EnableResolution(Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest,Microsoft.VisualStudio.Debugger.DkmWorkList)">
      <summary>Called by the breakpoint manager to add a pending resolve request. Expression evaluators or other components will immediately try to bind the breakpoint against current modules, and will bind the breakpoint to additional locations as modules load. The caller of this interface should implement IDkmRuntimeFunctionResolverClient to obtain the results of the resolution. Implementations of this interface should stop trying to bind the breakpoint when the DkmRuntimeFunctionResolutionRequest object is closed.</summary>
      <param name="runtimeFunctionResolutionRequest">[In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and evaluated by a runtime-based expression evaluator and is bound to a particular process. Resolutions will send DkmModuleInstance::FunctionResolved events.</param>
      <param name="workList">Work list that is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeFunctionResolverClient">
      <summary>This interface is implemented by the breakpoint manager so that it can receive notification that a runtime function resolution request has resolved into a new function. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeFunctionResolverClient.OnFunctionResolved(Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Called by runtime function resolvers when a new resolution has been discovered for a DkmRuntimeFunctionResolutionRequest instance.</summary>
      <param name="runtimeFunctionResolutionRequest">[In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and evaluated by a runtime based expression evaluator and is bound to a particular process. Resolutions will send DkmModuleInstance::FunctionResolved events.</param>
      <param name="address">[In] The address the request bound to. Multiple addresses will cause multiple calls to this function.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeFunctionResolverClient.OnResolverMessage(Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel,System.String)">
      <summary>Called by runtime function resolvers when the resolver wishes to notify its client an error/warning occurred while it tries to resolve the breakpoint.</summary>
      <param name="runtimeFunctionResolutionRequest">[In] DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and evaluated by a runtime based expression evaluator and is bound to a particular process. Resolutions will send DkmModuleInstance::FunctionResolved events.</param>
      <param name="level">[In] Describes the severity of a message sent from a breakpoint manager back to the source component. This list is sorted in order of priority, as the UI will only display the most important warning. All warnings are ignored if the breakpoint is bound.</param>
      <param name="message">[In] Message string to display to the user.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeHandleComparer">
      <summary>This interface allows for Concord components to compare two ICorDebugHandleValue objects' values by routing the calls to GetValue through the shim EE in order to have the correct LocalContext set up. Calling GetValue directly on an ICorDebugHandleValue object from Concord will give you an exception thrown from the VIL host. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeHandleComparer.CompareHandleValuesThroughVil(Microsoft.VisualStudio.Debugger.Clr.DkmClrRuntimeInstance,Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue,Microsoft.VisualStudio.CorDebugInterop.ICorDebugHandleValue)">
      <summary>Takes two ICorDebugHandleValues, calls GetValue on each, and compares the resulting values to determine whether they are equal. If necessary, it will set up a LocalContext for the VIL interpreter.</summary>
      <returns>[Out] Set to true if the two given ICorDebugHandleValue objects have the same value, false otherwise.</returns>
      <param name="clrRuntimeInstance">[In] Represents a CLR instance running in a target process.</param>
      <param name="handleValue1">[In] The first ICorDebugHandleValue object.</param>
      <param name="handleValue2">[In] The second ICorDebugHandleValue object.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeInstanceLoadNotification">
      <summary>IDkmRuntimeInstanceLoadNotification is implemented by components that want to listen for the RuntimeInstanceLoad event. The target process may continue to run during this notification. RuntimeInstanceLoad is fired when a DkmRuntimeInstance object is created. This event can be used to detect that a particular type of code (ex: native) is being debugged in this target process. In launch scenarios, the RuntimeInstanceLoad event will be fired before any code of the specified type has a chance to run in the target process. When debugging native code, this includes all code in the target process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeInstanceLoadNotification.OnRuntimeInstanceLoad(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnRuntimeInstanceLoad is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeInstanceUnloadNotification">
      <summary>IDkmRuntimeInstanceUnloadNotification is implemented by components that want to listen for the RuntimeInstanceUnload event. The target process may continue to run during this notification. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeInstanceUnloadNotification.OnRuntimeInstanceUnload(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnRuntimeInstanceUnload is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeMonitorBreakpointHandler">
      <summary>Provides services to set and remove breakpoints. This interface is implemented by the Debug Monitor for most runtimes. The implementation must use a data item to track the lifetime of each enabled DkmRuntimeBreakpoint so that it can implicitly disable the breakpoint when the DkmRuntimeBreakpoint is closed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeMonitorBreakpointHandler.DisableRuntimeBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint)">
      <summary>Disables a breakpoint. Disabling a breakpoint is typically implemented by modifying the state of the target process so the breakpoint will no longer fire. For example, removing a previously inserted 'int3' from the instruction stream. If the breakpoint is already disabled, this operation has no effect. In addition to this method, a breakpoint is implicitly disabled when it is closed. If multiple breakpoints are set on the same instruction, disabling one breakpoint does not affect the other breakpoints set on this instruction.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeMonitorBreakpointHandler.EnableRuntimeBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint)">
      <summary>Enables a breakpoint. Breakpoints start off disabled, so this method must be called before the breakpoint can be set. Enabling a breakpoint is typically implemented in the debug monitor by modifying the state of the target process. For example, inserting an 'int3' instruction into the code stream. If the breakpoint is already enabled, this operation has no effect. Once a breakpoint has been enabled, the debug monitor will raise a RuntimeBreakpoint event for this DkmRuntimeBreakpoint object whenever the trigger condition (ex: target instruction is executed) is met. Multiple DkmRuntimeBreakpoints may be set on the same instruction. In this case, the debug monitor will raise a different RuntimeBreakpoint event for each breakpoint object. Similarly, if a step complete and a breakpoint both complete on the same instruction, the debug monitor will raise both events.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded.-or-E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeMonitorBreakpointHandler.TestRuntimeBreakpoint(Microsoft.VisualStudio.Debugger.Breakpoints.DkmRuntimeBreakpoint)">
      <summary>Determines whether the given DkmRuntimeBreakpoint could be enabled. This is used in the breakpoints dialog box to validate breakpoints before the dialog box is closed.</summary>
      <param name="runtimeBreakpoint">[In] Low-level breakpoint object that is supported by debug monitors.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_BP_MODULE_UNLOADED indicates that the module instance specified by the breakpoint is no longer loaded.-or-E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.</exception>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeSetNextStatement">
      <summary>IDkmRuntimeSetNextStatement is the interface runtime monitors implement to support set next statement. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeSetNextStatement.SetNextStatement(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>SetNextStatement moves the IP of a stack frame. The stack frame is always the leaf stack frame on a particular thread.</summary>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="newStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper">
      <summary>IDkmRuntimeStepper is the interface runtime monitors implement to support stepping. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.AfterSteppingArbitration(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>AfterSteppingArbitration is called by the stepping manager on the old controlling runtime instance after stepping arbitration is complete but before the next runtime instance starts stepping. This enables runtimes to clear any stepping state if another runtime took control. If no other runtime monitor claimed the current location, the original monitor should finish the step. This is indicated by NewControllingRuntimeInstance being null. For instance, a runtime instance may decide to step back out if a step-in landed in a location without symbols and no other runtime took control.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="newControllingRuntimeInstance">[In,Optional] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.BeforeEnableNewStepper(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)">
      <summary>BeforeEnableNewStepper is called by the stepping manager before a new stepper is enabled. This gives runtimes the ability to do any initialization that might be required such as performing pre-step function evaluations.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.NotifyStepComplete(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)">
      <summary>NotifyStepComplete is called by the stepping manager on all non-controlling runtime instances when a step is completed.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.OnNewControllingRuntimeInstance(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>OnNewControllingRuntimeInstance is called by the stepping manager on all non-controlling runtime instances after step arbitration has selected a new controlling runtime instance.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="controllingRuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.OwnsCurrentExecutionLocation(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason)">
      <summary>OwnsCurrentExecutionLocation is called by the stepping manager when it is searching for monitors to perform a step. If the current location in the debuggee is understood by this monitor it can return true here to take control of the step.</summary>
      <returns>[Out] If the runtime instance wants control of the step, it should set this to true. It should be set to false not to take control.</returns>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.Step(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason)">
      <summary>Step is called by the stepping manager after it determines this monitor is the correct monitor to perform the step.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.StepControlRequested(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>StepControlRequested is called by the stepping manager when a non-controlling runtime instance detects that the thread has hit a transition into its runtime. If the current controlling runtime instance can stop stepping, it should set Granted to true. Actual control is not given until the requesting runtime calls DkmStepper.TakeStepControl. This two part process enables callers to request control of multiple steppers at the same time.</summary>
      <returns>[Out] The controlling runtime can stop the step and give control to the caller, and then it should set this to true.</returns>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="callingRuntimeInstance">[In] The calling runtime instance that wishes to take control of the step.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.StopStep(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)">
      <summary>StopStep is called by the stepping manager when the process is being continued to clear out any remaining stepping state for a stepper.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmRuntimeStepper.TakeStepControl(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,System.Boolean,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>TakeStepControl is called by the stepping manager when a non-controlling runtime instance detects that the thread has hit a transition into its runtime. The stepping manager will forward the call to the current controlling runtime instance. The runtime instance requesting control should first call StepControlRequested on all steppers it wants control of. If they all set Granted to true, the runtime instance should then call this method on each stepper it is taking control of.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="leaveGuardsInPlace">[In] Set to true by the caller if it wants the current controlling runtime instance to leave guards in place to stop the step if it is required. For instance, this can be used to leave guard breakpoints after a call instruction so another runtime can step back out if the target of the call does not have source. However, any stepping state that affects the immediate step, such as trap flags, should be removed by the controlling runtime instance.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="callingRuntimeInstance">[In] The calling runtime instance that wishes to take control of the step.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentContentInsertNotification">
      <summary>IDkmScriptDocumentContentInsertNotification is implemented by components that want to listen for the ScriptDocumentContentInsert event. The target process may continue to run during this notification. Notification that new content has been added to the target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this is a new document section. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentContentInsertNotification.OnScriptDocumentContentInsert(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.String,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnScriptDocumentContentInsert is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
      <param name="span">[In] The text span of the inserted text. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line, and at at the end of a line immediately before a new section would begin.</param>
      <param name="newText">[In] The new text content which is inserted into the document.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentContentRemoveNotification">
      <summary>IDkmScriptDocumentContentRemoveNotification is implemented by components that want to listen for the ScriptDocumentContentRemove event. The target process may continue to run during this notification. Notification that content has been removed from the target process. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this will correspond to a deleted text section. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentContentRemoveNotification.OnScriptDocumentContentRemove(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.Int32,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnScriptDocumentContentRemove is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
      <param name="span">[In] The text span of the removed text. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging of a line, and correspond to a previously added section.</param>
      <param name="charsToRemove">[In] Number of characters in the section to remove.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentProvider">
      <summary>Implemented by components which create DkmScriptDocument objects in order to provide document content and notifications when the content changes. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentProvider.GetContent(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,System.Boolean,System.UInt32[]@)">
      <summary>Provides the current content of the specified document object.</summary>
      <returns>[Out] The current content of this document.</returns>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
      <param name="enableContentEvents">[In] If true, the script document provider should raise events when the content of this document changes. Passing true is equivalent to calling SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains the same.</param>
      <param name="sectionDividers">[Out] For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this is the 1-based line numbers for where the section dividers should be drawn.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentProvider.SetRaiseContentEvents(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,System.Boolean)">
      <summary>Enables or disables raising events when the content of the document is changed. By default, documents do not generate content events. So this method should be called by any component that wishes to receive content events. The script document manager maintains a count of the number of calls to enable content events, and will raise events whenever this count is greater than 0. Callers should make sure that SetRaiseContentEvents(false) is called ONLY after a successful call to SetRaiseContentEvents(true). Content events are automatically disabled when the document is unloaded.</summary>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
      <param name="enable">[In] If true, content events should be enabled for this document. If false, the count of content event listeners is decremented. When the count reaches zero, no additional events will be sent.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentQuery">
      <summary>API implemented by the script local agent to match script documents against breakpoint requests. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentQuery.TryResolve(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId)">
      <summary>This method is called when a script document is created or when the project item path is set to try to bind breakpoints against the given script document.</summary>
      <returns>[Out,Optional] If the given script document matches the given source file id, this returns a DkmResolvedDocument for the match. Otherwise, null is returned.</returns>
      <param name="scriptDocument">[In] Represents a document that is executing in a script runtime environment.</param>
      <param name="sourceFileId">[In] Identifies a source file and provides the information that a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentSourceProjectItemChanged">
      <summary>Interface to update components when the project item path is set for a script document. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentSourceProjectItemChanged.OnSourceProjectItemChanged(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument)">
      <summary>Called when 'SourceProjectItem' is changed.</summary>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentSymbolProvider">
      <summary>Implemented by components which create DkmScriptDocument objects, and use them as the basis of symbol resolution. This interface does not have to be implemented by script document system which leave DkmResolvedDocument.ScriptDocument as null. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentSymbolProvider.SetRaiseSymbolEvents(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,System.Boolean)">
      <summary>Enables or disables raising ScriptSymbolsUpdated when symbols in the document are changed. By default, documents do not generate symbol events. So this method should be called by any component that wishes to receive symbol events. The script document manager maintains a count of the number of calls to enable symbol events, and will raise events whenever this count is greater than 0. Callers should make sure that SetRaiseSymbolEvents(false) is called ONLY after a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when the document is unloaded.</summary>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
      <param name="enable">[In] If true, symbol events should be enabled for this document. If false, the count of symbol event listeners is decremented. When the count reaches zero, no additional events will be sent.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentTreeNodeCreateNotification">
      <summary>IDkmScriptDocumentTreeNodeCreateNotification is implemented by components that want to listen for the ScriptDocumentTreeNodeCreate event. When this notification fires, the target process will be suspended and can be examined. Notification when a new DkmScriptDocumentTreeNode object is created. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentTreeNodeCreateNotification.OnScriptDocumentTreeNodeCreate(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnScriptDocumentTreeNodeCreate is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="scriptDocumentTreeNode">[In] Represents a node in the 'Script Documents' virtual tree within solution explorer. Nodes may be either a virtual container, or they can be a document. In the latter case, they will be a DkmScriptDocument.</param>
      <param name="workList">WorkList to append additional event processing work to. This work list will begin execution after all listeners have been notifiied. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentTreeNodeUnloadNotification">
      <summary>IDkmScriptDocumentTreeNodeUnloadNotification is implemented by components that want to listen for the ScriptDocumentTreeNodeUnload event. The target process may continue to run during this notification. Notification that a DkmScriptDocumentTreeNode has been unloaded from the target process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptDocumentTreeNodeUnloadNotification.OnScriptDocumentTreeNodeUnload(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnScriptDocumentTreeNodeUnload is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="scriptDocumentTreeNode">[In] Represents a node in the 'Script Documents' virtual tree within Solution Explorer. Nodes can be a virtual container or a document. In the latter case, they will be a DkmScriptDocument.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptSymbolCallback">
      <summary>Callback interface implemented by script symbol providers in order to support stepping customizations for languages that compile to JavaScript (or possibly other script languages also). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptSymbolCallback.GetNextSteppingAction(Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol,Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol,System.Boolean)">
      <summary>Call back implemented by the script symbol provider to tell the script debug monitor what to do next when stepping.</summary>
      <returns>[Out] Enum value indicating the next action that the script dm should perform.</returns>
      <param name="scriptInstruction">[In] DkmScriptInstructionSymbol is used to represent an executable statement in a script-based runtime environment such the Microsoft JavaScript engine.</param>
      <param name="startingInstruction">[In,Optional] The instruction symbol of the process at the time this step started. This will be NULL if the step originated on a thread without frames.</param>
      <param name="isSteppingByLine">[In] true if the step is by line (instead of by statement).</param>
      <exception cref="T:System.NotImplementedException">NotImplementedException/E_NOTIMPL indicates that no symbol provider is available for the script symbol.</exception>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptSymbolsUpdatedNotification">
      <summary>IDkmScriptSymbolsUpdatedNotification is implemented by components that want to listen for the ScriptSymbolsUpdated event. When this notification fires, the target process will be suspended and can be examined. Notification that symbol state for one or more script documents have been updated. This is used to rebind breakpoints in script-based modules. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmScriptSymbolsUpdatedNotification.OnScriptSymbolsUpdated(Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument[],Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnScriptSymbolsUpdated is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="scriptRuntimeInstance">[In] Represents a script-based execution environment executing in a target process.</param>
      <param name="documents">[In] Set of documents which have been updated.</param>
      <param name="workList">WorkList to append additional event processing work to. This work list will begin execution after all listeners have been notifiied. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSetNextStatementQuery">
      <summary>Allows the UI to query if the current instruction can be set to an address. Must be implemented on the Client side as it can be called in scenarios that require a fast result such as dragging the IP in the debugger editor. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSetNextStatementQuery.CanSetNextStatement(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>CanSetNextStatement determines whether it is possible to move the IP of a stack frame. The stack frame is always the leaf stack frame on a particular thread. This API may only be implemented in the engine process. The Result out parameter should be S_OK or the value of a failed HRESULT that the UI can map to an error message.</summary>
      <returns>[Out] The error code to return to the UI. This should be S_OK or the value of a failed HRESULT that the UI can map to an error message.</returns>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="newStatement">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSingleStepCompleteNotification">
      <summary>IDkmSingleStepCompleteNotification is implemented by components that want to listen for the SingleStepComplete event. IDkmSingleStepCompleteNotification is invoked after all implementations of IDkmSingleStepCompleteReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent when single stepping a thread is completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSingleStepCompleteNotification.OnSingleStepComplete(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnSingleStepComplete is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSingleStepCompleteReceived">
      <summary>IDkmSingleStepCompleteReceived is implemented by components that want to listen for the SingleStepComplete event. IDkmSingleStepCompleteReceived is invoked before IDkmSingleStepCompleteNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent when single stepping a thread is completed. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSingleStepCompleteReceived.OnSingleStepCompleteReceived(Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnSingleStepCompleteReceived is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="singleStepRequest">[In] DkmSingleStepRequest represents a request to single step a thread.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSourceServerSymbolQuery">
      <summary>This API is used to read information about source server data from a symbol provider. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSourceServerSymbolQuery.GetSourceServerData(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Returns the contents of the source server stream data for a module if the stream exists.</summary>
      <returns>[Out] True if this address is the first address in the line's range. False otherwise.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="moduleInstance">[In] The module instance for which symbol server data is being requested.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackProvider">
      <summary>Provides the stack for view by the user. This stack has been filtered, annotated, and mixed together. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackProvider.Format(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameFormatOptions)">
      <summary>Format a DkmStackWalkFrame into a DkmStackFrame. Formatting a frame is one step of what the stack provider does during GetNextFrames. This method can be used to format a frame in a different way than was originally performed by the stack provider in GetNextFrames.</summary>
      <returns>[Out] DkmStackFrame represents a frame on the call stack after filtering and translation.</returns>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="inspectionSession">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="options">[In] Collection of settings that affect how the stack provider formats a DkmStackFrame.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackProvider.GetNextFrames(Microsoft.VisualStudio.Debugger.CallStack.DkmStackContext,Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmGetNextFramesAsyncResult})">
      <summary>Obtain the next frames from the call stack. If this is the first call on a particular DkmStackContext then this will return the first frames. This method is the recommended way to obtain the call stack because the stack provider maintains a cache of the physical cache.</summary>
      <param name="stackContext">[In] DkmStackContext objects are created by components that want to request the stack from the stack provider. A component must close the context after they have completed the stack walk. To obtain the stack a component should create this object and then call GetNextFrames.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="requestSize">[In] RequestSize is the number of frames that the caller wants returned. The implementation of GetNextFrames may return fewer frames in the case that stack does not contain that many frames. Negative values, or request to read more than MaxFrames (currently 5,000) will be capped to MaxFrames.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackProvider.GetTopStackFrame(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Returns the top call stack frame for a thread. This value is ordinarily cached after the first stack walk and cleared on continue. This is only callable above the stack provider in the client process. To obtain the top frame in the server process, call GetTopStackWalkFrame.</summary>
      <returns>[Out] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackWalkFrameInterfaceProvider">
      <summary>This interface is implemented by components that contribute stack frames, and want to provide an additional inspection interface for expression evaluators and other components that must inspect the stack frame. NOTE: The data container API should not be used from the implementation of the returned custom interface. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStackWalkFrameInterfaceProvider.GetFrameInspectionInterface(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Guid)">
      <summary>GetFrameInspectionInterface is used to obtain a ICorDebugFrame or other implementation-specific interfaces which a component can use to deeply inspect the stack frame. The returned interface may ONLY be used to inspect the target process, and should NEVER be used to control execution (no stepping, no breakpoints, no continue, etc). Doing so is unsupported and will give you undefined behavior.</summary>
      <returns>[Out] Returned frame interface. This may be cast to the interface pointer corresponding to 'InterfaceID'.</returns>
      <param name="frame">[In] DkmStackWalkFrame represents a frame on a call stack which has been walked, but may not have been formatted or filtered. Formatted frames are represented by DkmStackFrame instead.</param>
      <param name="session">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="interfaceID">[In] The GUID of the desired interface. IID_ICorDebugFrame can be used to obtain the CorDebug frame interface for a managed frame. Other debug monitors or stack walkers may provide their own interface.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStartDebuggingOperations">
      <summary>This interface contains the API for starting a new process under the debugger or attaching the debugger to an existing process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStartDebuggingOperations.AttachToProcess(Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest)">
      <summary>Causes the debug monitor to attach to the process. Before this method returns, the debug monitor must start an event thread (or reuse an existing event thread) and create the DkmProcess object on the event thread. Creating the DkmProcess object will send a process create event. Note that this method may only be called in response to the Visual Studio debugger package requesting an attach. Components that want to attach to another process should send a custom event to a Visual Studio package. From a package, an attach can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</returns>
      <param name="request">[In] DkmProcessAttachRequest is used to describe the process that the debugger should attach to.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_ATTACH_USER_CANCELED indicates that the attach to process operation was canceled. Returning this error will suppress most error messages, so it can be used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService as a way to provide custom failure messages to the user.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStartDebuggingOperations.LaunchDebuggedProcess(Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest)">
      <summary>Causes the debug monitor to create a new process under the debugger. The process should be left suspended until ResumeDebuggedProcess is called. The debug monitor must wait for ResumeDebuggedProcess before creating the DkmProcess object because it needs the UniqueProcessId value from the AD7 Layer. Note that this method may only be called in response to the Visual Studio debugger package requesting a launch. Components that want to launch another process under the debugger should send a custom event to a Visual Studio package. From a package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.</returns>
      <param name="request">[In] DkmProcessLaunchRequest is used to describe the process that the debugger should launch.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStartDebuggingOperations.ResumeDebuggedProcess(Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest,System.Guid)">
      <summary>Causes the debug monitor to resume a launched process and create the DkmProcess object. The DkmProcess object will be created on the event thread, and creating the object will send a process create event. Note that this method may only be called in response to the Visual Studio debugger package requesting a launch. Components that want to launch another process under the debugger should send a custom event to a Visual Studio package. From a package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</returns>
      <param name="request">[In] DkmProcessLaunchRequest is used to describe the process that the debugger should launch.</param>
      <param name="uniqueProcessId">[In] Value to assign to the 'DkmProcess.UniqueId' field. This GUID is generated by the port and is used to uniquely identify the process object.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepCompleteNotification">
      <summary>IDkmStepCompleteNotification is implemented by components that want to listen for the StepComplete event. IDkmStepCompleteNotification is invoked after all implementations of IDkmStepCompleteReceived. When this notification is called, the target process is stopped and implementers can either inspect the process or cause it to execute in a controlled manner (slip, func-eval). Sent by a runtime monitor when a step has completed successfully. Note that the step might actually finish on a different thread than it was started on. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepCompleteNotification.OnStepComplete(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnStepComplete is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="thread">[In] The thread the step actually finished on. Normally, this is the same as the thread in DkmStepper, but in some scenarios, it could be different.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the stepping thread. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepCompleteReceived">
      <summary>IDkmStepCompleteReceived is implemented by components that want to listen for the StepComplete event. IDkmStepCompleteReceived is invoked before IDkmStepCompleteNotification. From within this notification, you cannot cause the target process to execute (no func-eval, no slipping). Sent by a runtime monitor when a step has completed successfully. Note that the step might actually finish on a different thread than it was started on. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepCompleteReceived.OnStepCompleteReceived(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnStepCompleteReceived is invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="thread">[In] The thread the step actually finished on. Normally, this is the same as the thread in DkmStepper, but in some scenarios, it could be different.</param>
      <param name="hasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the stepping thread. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepOverPropertiesAndOperatorsEnableNotification">
      <summary>Interface to update components when 'IsStepOverPropertiesAndOperatorsEnabled' is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStepOverPropertiesAndOperatorsEnableNotification.OnStepOverPropertiesAndOperatorsChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'IsStepOverPropertiesAndOperatorsEnabled' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingCodePathProvider">
      <summary>Used by Active Debugging 7 to obtain step into specific options. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingCodePathProvider.GetCodePaths(Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit)">
      <summary>GetCodePaths is called to obtain step into specific targets.</summary>
      <returns>[Out] DkmSteppingCodePath[] represents a location that user can step to from current location.</returns>
      <param name="steppingCodePathSource">[In] Object used for filtering for step into specific.</param>
      <param name="stackFrame">[In] Specifies the current frame.</param>
      <param name="stepUnit">[In] Specifies whether code paths are for current statement or line.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManager">
      <summary>Interface of the stepping manager. This component is implemented by Microsoft and it provides stepping arbitration between the various debug monitors active in the process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManager.BeforeEnableNewStepper(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)">
      <summary>Called by the stopping event manager before a step operation actually starts The stopping event manager will notify all runtime instances so that they can set up any necessary state before the stopping event manager starts blocking function evaluations.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManager.CancelStepper(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>Allows a stepper to be canceled after creation by the controlling runtime instance. The calling runtime instance must match the current controlling runtime instance. This is generally used in cross thread stepping scenarios where the original stepper may be reactivated. The stepping manager will close the stepper and not send step complete.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="callingRuntimeInstance">[In] The calling runtime instance that wishes to take control of the step.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManager.ClearSteppers(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Called by the stopping manager before resuming execution in order to clear all steppers from a given thread. The stepping manager will call StopStep on the controlling runtime instance and then close the stepper objects.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManager.EnableStepper(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,System.Boolean)">
      <summary>Used to initialize a stepper object so that the step will be performed when execution is next resumed. This method is implemented by the stepping manager by finding an appropriate runtime debug monitor, and asking this runtime debug monitor to set up a step. This method should only be called one time for a given stepper object.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="removeOtherSteppers">[In] Set to true if other steppers are to be removed. This is ordinarily only set in response to user initiated step requests.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback">
      <summary>Allows runtime monitors to obtain information from the stepping manager. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SourceId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback.GetControllingRuntimeInstance(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper)">
      <summary>Returns the runtime instance currently in-control of this DkmStepper.</summary>
      <returns>[Out] The runtime instance currently in control of this stepper.</returns>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback.OnCrossThreadStepArbitration(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper@)">
      <summary>Called by a runtime monitor when a step is continuing on a different thread. The stepping manager will create a new DkmStepper that will be used on the new thread and initiate stepping arbitration to determine which runtime should complete the step just as OnStepArbitration does. The new stepper uses the same step kind and step unit as the original stepper. A new starting instruction address must be given and is set as the stepper's starting address. The original stepper remains alive and when the new stepper finishes the stepping manager will suppress the event and notify the original stepper of the completion.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="currentControllingRuntimeInstance">[In] The runtime instance requesting arbitration.</param>
      <param name="newThread">[In] The thread on which to create the new stepper.</param>
      <param name="newStartingInstructionAddress">[In] Starting address of the new stepper.</param>
      <param name="newStepper">[Out,Optional] The new stepper.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback.OnStepArbitration(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>Called by a runtime monitor when a step has left the confines of what the runtime monitor understands or a potential transition into another runtime has been encountered during a step. The stepping manager will initiate stepping arbitration to give each runtime monitor a chance to inspect the process and determine which runtime should complete the step. The runtimes are called in priority order. After this process is complete, the stepping manager will call AfterSteppingArbitration on the monitor that requested arbitration so that it can respond to the new controlling monitor if one was found, or finish the step if one was not found.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="currentControllingRuntimeInstance">[In] The runtime instance requesting arbitration.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback.StepControlRequested(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>StepControlRequested is called when a non-controlling runtime instance detects that the thread has hit a transition into its runtime. The stepping manager will forward the call to the current controlling runtime instance. If the current controlling runtime instance can stop stepping, it should set Granted to true. Actual control is not given until the requesting runtime calls DkmStepper.TakeStepControl. This two part process allows for callers to request control of multiple steppers at the same time.</summary>
      <returns>[Out] The controlling runtime can stop the step and give control to the caller, and then it should set this to true.</returns>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="callingRuntimeInstance">[In] The calling runtime instance that wishes to take control of the step.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSteppingManagerCallback.TakeStepControl(Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,System.Boolean,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <summary>TakeStepControl is called when a non-controlling runtime instance detects that the thread has hit a transition into its runtime. The stepping manager will forward the call to the current controlling runtime instance. The runtime instance requesting control should first call StepControlRequested on all steppers it wants control of. If they all set Granted to true, the runtime instance should then call this method on each stepper it is taking control of.</summary>
      <param name="stepper">[In] DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</param>
      <param name="leaveGuardsInPlace">[In] Set to true by the caller if it wants the current controlling runtime instance to leave guards in place to stop the step if it is required. For instance, this can be used to leave guard breakpoints after a call instruction so another runtime can step back out if the target of the call does not have source. However, any stepping state that affects the immediate step, such as trap flags, should be removed by the controlling runtime instance.</param>
      <param name="reason">[In] DkmStepArbitrationReason the reason step arbitration is occurring.</param>
      <param name="callingRuntimeInstance">[In] The calling runtime instance that wishes to take control of the step.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStopDebuggingOperations">
      <summary>This interface contains the API for stop debugging. This interface must be implemented by base debug monitors. It is also possible to implement this interface in order to customize the stop debugging experience for a particular application. For example, a component could re-implement Terminate so that the debugger would gracefully shut down the application instead of using the TerminateProcess Win32 API. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStopDebuggingOperations.Detach(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>This method is called to tell the monitor to detach from the target process. This will trigger a ProcessExit event to be sent on the event thread.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmStopDebuggingOperations.Terminate(Microsoft.VisualStudio.Debugger.DkmProcess,System.Int32)">
      <summary>This method is called to tell the monitor to terminate the target process. This will trigger a ProcessExit event to be sent on the event thread.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="exitCode">[In] The exit code that will be used by the process and threads terminated because of this call. Use the GetExitCodeProcess function to retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a thread's exit value.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSuppressOptimizationsEnableNotification">
      <summary>Interface to update components when 'IsSuppressOptimizationsEnabled' is enabled or disabled. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSuppressOptimizationsEnableNotification.OnSuppressOptimizationsChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when 'IsSuppressOptimizationsEnabled' is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolCompilerIdQuery">
      <summary>This API is used to fetch the compiler id for a given symbol. It is implemented by symbol providers that support symbol stores where the binary may contain multiple languages. In other words, this interface only has to be implemented when DkmModule.CompilerId is Guid.Empty/Guid.Empty. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolCompilerIdQuery.GetCompilerId(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the compiler id (LanguageId/VendorId) of a given symbol. See DkmSymbol.GetCompilerId for more information.</summary>
      <returns>[Out] LanguageId/VendorId for the compiler which produced the code for this symbol. If this is unknown (ex: no symbols information for this block), both values will be Guid.Empty. Otherwise, both values should be non-zero.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolCompilerIdQueryCallback">
      <summary>This API is used to fetch the compiler id for a given symbol. It is implemented by symbol providers that support symbol stores where the binary may contain multiple languages. In other words, this interface only has to be implemented when DkmModule.CompilerId is Guid.Empty/Guid.Empty. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolCompilerIdQueryCallback.GetCompilerIdCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the compiler id (LanguageId/VendorId) of a given symbol. See DkmSymbol.GetCompilerId for more information.</summary>
      <returns>[Out] LanguageId/VendorId for the compiler which produced the code for this symbol. If this is unknown (ex: no symbols information for this block), both values will be Guid.Empty. Otherwise, both values should be non-zero.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDisassemblyQuery">
      <summary>This API is used to resolve symbols in the disassembly window. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDisassemblyQuery.GetDisassemblyLabel(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the name of the symbol as it appears in the disassembly window. For C++ code, this is based on the public symbol name.</summary>
      <returns>[Out,Optional] The label to use for this instruction.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDocumentCollectionQuery">
      <summary>API implemented by symbol providers to allow the breakpoints manager and other components to query the collection of documents inside a symbol store. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: CompilerVendorId, LanguageId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDocumentCollectionQuery.FindDocuments(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId)">
      <summary>Returns document objects from search parameters that are contained in the document query. If the symbol file does not contain a reference to this document the returned document object will be NULL (S_FALSE return code in native). The returned document objects must be explicitly closed by the caller when the caller has finished with the document.</summary>
      <returns>[Out] A collection of the documents that matched the query.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="sourceFileId">[In] Identifies a source file and provides the information which a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDocumentSpanQuery">
      <summary>The API implemented by symbol providers to allow the breakpoints manager and other components to query the 'document text span-&gt;symbol' map that is inside a symbol store. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolDocumentSpanQuery.FindSymbols(Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition[]@)">
      <summary>Finds the symbols in the document that best match the input text span. For MSIL-based languages, the symbol handler always returns the DkmInstructionSymbol for sequence points. It will prefer sequence points that exactly match the text span followed by the sequence point or points that are left-most and that are inside the input span. For languages that emit a native PDB, TODO.</summary>
      <returns>[Out] The found instruction symbols that are in the specified text span.</returns>
      <param name="resolvedDocument">[In] Object that represents the result of a source file query against a symbol file (PDB). The resolved document object might encapsulate multiple document records with the symbol file. For example, in C++ compilation, every time a header file is included there is another reference in the PDB. However, there is only one DkmResolvedDocument object for the header file.</param>
      <param name="textSpan">[In] The text range (lines/column) to search for.</param>
      <param name="text">[In,Optional] The text to search for. When available, this will be provided if ResolvedDocument.TextRequested is set.</param>
      <param name="symbolLocation">[Out] The source location of each returned instruction symbol. The length of this array should be the same as the returned instruction symbol array.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_TEXT_SPAN_NOT_LOADED indicates that <paramref name="textSpan" /> is not currently loaded in the specified script document.-or-E_SCRIPT_SPAN_MAPPING_FAILED indicates that <paramref name="textSpan" /> could not be mapped to a location in the specified script document.-or-E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file loaded by the target process does not match the provided text.</exception>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolFunctionResolver">
      <summary>This interface is implemented by symbol based expression evaluators to map between a function/address expression and the instructions which are represented by it. This is used to bind function breakpoints. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, CompilerVendorId, EngineId, LanguageId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolFunctionResolver.Resolve(Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest)">
      <summary>Resolve an address string to zero or more address symbols. This is used to bind function breakpoints.</summary>
      <returns>[Out] DkmInstructionSymbol[] represents a method in the target process.</returns>
      <param name="symbolFunctionResolutionRequest">[In] DkmSymbolFunctionResolutionRequest represents an expression to be parsed and evaluated by a symbol based expression evaluator and is not bound to a particular process. Used to perform function breakpoint binds.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolHiddenAttributeQuery">
      <summary>This API is used to read information about a symbol. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolHiddenAttributeQuery.IsHiddenCode(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult})">
      <summary>Returns if this instruction symbol is in hidden code. For instance, in managed code, the line number 0xfeefee marks a source line as hidden.</summary>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="inspectionSession">[In] DkmInspectionSession allows the various components which inspect data to store private data which is associated with a group of evaluations.</param>
      <param name="instructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolLocator">
      <summary>Interface implemented by symbol providers which deal with symbol search. In other words, this interface would not be implemented by symbol providers which deal only with symbol formats which are inside the debugged binary. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolLocator.GetSymbolFilePath(Microsoft.VisualStudio.Debugger.Symbols.DkmModule)">
      <summary>Returns the path of the symbol file which backs a DkmModule object.</summary>
      <returns>[Out] Full path of the symbol file (ex: c:\myproj\bin\debug\myproj.pdb).</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolLocator.GetSymbolLoadInformation(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Returns a string that describes the various locations in which symbols were searched for, and the result of checking that location. This information is used to populate the 'Symbol Load Information' in the modules window.</summary>
      <returns>[Out] String that contains information about the symbol search. The typical format is 'location1:result1\r\nlocation2:result2...'.</returns>
      <param name="moduleInstance">[In] The Module Instance class represent a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolLocator.GetSymbolStatusMessage(Microsoft.VisualStudio.Debugger.DkmModuleInstance,System.Boolean)">
      <summary>Obtain a localized a string description of the current symbol status.</summary>
      <returns>[Out] Localized status string (ex: 'Symbols Loaded', 'No symbols loaded', etc.).</returns>
      <param name="moduleInstance">[In] The Module Instance class represent a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
      <param name="excludeCommonErrors">[In] This value will be true for creating the initial load output message, and false for obtaining the output window text.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolLocator.TryLoadSymbols(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Called to initiate loading of symbols for DkmModuleInstances whose symbols were not found when the module loaded.</summary>
      <param name="moduleInstance">[In] The Module Instance class represent a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolMemoryReader">
      <summary>Interface implemented by base debug monitors that read symbols from debuggee's memory at runtime. This interface would be implemented by base debug monitors to deal with symbol formats that are generated or loaded at runtime in the debuggee's memory. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, SymbolProviderId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolMemoryReader.ReadSymbols(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>This method is invoked by symbol handlers to read symbols for DkmModuleInstances whose symbols reside in the debuggee's memory.</summary>
      <returns>[Out,Optional] The symbol buffer that is read from the debuggee's memory at runtime.</returns>
      <param name="moduleInstance">[In] The Module Instance class represents a code bundle (ex: .dll or .exe) that is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolPathChangeNotification">
      <summary>Interface to update components when symbol settings change. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolPathChangeNotification.OnSymbolPathChanged(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Called when the symbol path is changed.</summary>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback">
      <summary>Callback interface which is implemented by symbol providers to provide information from the symbol store to base debug monitors. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback.GetCurrentStatementRange(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>This method returns the IL offset range that contains the current IL offset as specified in the instruction address.</summary>
      <returns>[Out] A offset/size pair which is returned from the symbol provider to a debug monitor to indicate a range of instructions which the debugger should not stop at.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback.GetEntryPointSymbols(Microsoft.VisualStudio.Debugger.Symbols.DkmModule)">
      <summary>GetEntryPointSymbols is used by the breakpoint manager to find the entry point symbol(s) in the launching executable. For managed code, this symbol is defined by using ISymUnmanagedWriter::SetUserEntryPoint. For native code, this symbol is found by looking for the various 'main' function (main, WinMain, etc). A third can override the entry point either by implementing their own symbol provider or by implementing IDkmEntryPointQuery.</summary>
      <returns>[Out] DkmInstructionSymbol[] represents a method in the target process.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback.GetFunctionInfo(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String)">
      <summary>Search a module's symbols for a function that has the specified name. Returns the RVA and size if it is found.</summary>
      <returns>[Out] The RVA / size pairs from the query.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or one time was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different app domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="functionName">[In] The name of the function to search for.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback.GetSteppingRanges(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary,System.Boolean)">
      <summary>Queries the symbol provider to determine the ranges of instructions which the base debug monitor should step through to implement a step.</summary>
      <returns>[Out] Array of ranges to step through. This array will be empty if there is no source information for the given instruction.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="rangeBoundary">[In] Indicates to the symbol provider the type of instructions to include in the 'no-step' regions.</param>
      <param name="includeInline">[In] True if the symbol provider should stop the stepping range when it encounters an inline functions. False otherwise. The Native DM will pass true for a step in so steps will stop in inline functions. It will pass false when doing a step-over so the stepper will not stop in inline functions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolProviderCallback.HasLineInfo(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>Queries the symbol provider to determine whether we have line information. Used by debug monitor to decide whether location can be considered user code.</summary>
      <returns>[Out] True if there is line information for this location.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolQuery">
      <summary>This API is used to read information about a symbol. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolQuery.GetSourcePosition(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Boolean@)">
      <summary>Returns the source file position (ex: example.cs, line 12) of this instruction symbol. If this instruction symbol is not associated with a source file then null is returned (S_FALSE return code in native).</summary>
      <returns>[Out,Optional] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="flags">[In] Flags which affect the behavior of 'GetSourcePosition'.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
      <param name="startOfLine">[Out] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolQuery.GetSymbolInterface(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Guid)">
      <summary>GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This is useful to either callers that find the symbol abstraction presented by the debugger to be either too restrictive for their needs, or just undesirable because of how their component is implemented.</summary>
      <returns>[Out] Returned symbol interface. This may be cast to the interface pointer corresponding to 'InterfaceID'.</returns>
      <param name="module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="interfaceID">[In] The GUID of the desired interface. Microsoft supports IID_IDiaSession for Native DkmModule's, and IID_ISymUnmanagedReader for Managed modules.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolQueryCallback">
      <summary>Allows remote components to obtain source position information when the symbol provider is on the Visual Studio computer. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: RuntimeId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolQueryCallback.GetSourcePositionCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Boolean@)">
      <summary>Returns the source file position (ex: example.cs, line 12) of this instruction symbol. If this instruction symbol is not associated with a source file, null is returned (S_FALSE return code in native).</summary>
      <returns>[Out,Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
      <param name="instruction">[In] DkmInstructionSymbol represents a method in the target process.</param>
      <param name="flags">[In] Flags that affect the behavior of 'GetSourcePosition'.</param>
      <param name="inspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
      <param name="startOfLine">[Out] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolStackWalk">
      <summary>Provides a mechanism for walking native stack frames using information from symbol files. This mechanism is used to walk any stack frames that could not be resolved on the target computer. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, SymbolProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolStackWalk.Initialize(Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32)">
      <summary>Initialize is invoked on each walker exactly one time at the start of the walk process. This gives each walker a chance to initialize any state.</summary>
      <param name="symbolStackWalkContext">[In] DkmSymbolStackWalkContext allows the various symbol providers that walk the call stack to store private data that is associated with this call stack.</param>
      <param name="registers">[In] Registers to attempt to walk from.</param>
      <param name="stackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolStackWalk.UpdatePosition(Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters,System.UInt32,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>UpdatePosition is invoked by the stack provider after another walker has walked one or more frames, so this walker must be updated before invoking WalkNextFrame.</summary>
      <param name="symbolStackWalkContext">[In] DkmSymbolStackWalkContext allows the various symbol providers that walk the call stack to store private data that is associated with this call stack.</param>
      <param name="registers">[In] Registers to attempt to walk from.</param>
      <param name="stackRangeSize">[In] Size of the stack range that the debugger will attempt to walk through.</param>
      <param name="instructionAddress">[In] Address from the instruction pointer in the registers. This will be either a 'Native' or 'Unresolved' address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmSymbolStackWalk.WalkNextFrame(Microsoft.VisualStudio.Debugger.CallStack.DkmSymbolStackWalkContext,Microsoft.VisualStudio.Debugger.CallStack.DkmFrameRegisters@)">
      <summary>Walks the next stack frame from the call stack.</summary>
      <returns>[Out,Optional] Created frame object for the current registers.</returns>
      <param name="symbolStackWalkContext">[In] DkmSymbolStackWalkContext allows the various symbol providers that walk the call stack to store private data that is associated with this call stack.</param>
      <param name="nextRegisters">[Out,Optional] Indicates the registers of the next frame (the caller of 'FrameObject'). It is used to invoke UpdatePosition if the next frame is owned by a different symbol provider. A null NextRegisters value indicates that the returned frame is the last frame of the call stack. Therefore, the stack walk will end here.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProvider">
      <summary>Interface implemented by the task provider component to obtain information about tasks. This interface is subject to change in future versions of Visual Studio. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TaskProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProvider.GetChildTasks(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask)">
      <summary>Returns children tasks.</summary>
      <returns>[Out] TODO.</returns>
      <param name="task">[In] Represents either a managed TPL task or a native Concurrency Runtime task.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProvider.GetPropertyNames(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider)">
      <summary>TODO.</summary>
      <returns>[Out] TODO.</returns>
      <param name="taskProvider">[In] Represents a task provider which is loaded into the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProvider.GetTaskProperties(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask,System.UInt32,System.Int32,Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties@)">
      <summary>Returns task properties.</summary>
      <param name="task">[In] Represents either a managed TPL task or a native Concurrency Runtime task.</param>
      <param name="radix">[In] TODO.</param>
      <param name="fields">[In] TODO.</param>
      <param name="properties">[Out] TODO.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProvider.GetTasks(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider,System.Boolean,System.UInt32,System.UInt32@,Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask[]@,System.UInt32@)">
      <summary>TODO.</summary>
      <param name="taskProvider">[In] Represents a task provider which is loaded into the target process.</param>
      <param name="isRoot">[In] TODO.</param>
      <param name="requestCount">[In] Count of tasks requested.</param>
      <param name="scheduledTaskCount">[Out] Number of scheduled tasks.</param>
      <param name="items">[Out] TODO.</param>
      <param name="taskEnumFlags">[Out] TODO.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProviderCreateNotification">
      <summary>IDkmTaskProviderCreateNotification is implemented by components that want to listen for the TaskProviderCreate event. The target process may continue to run during this notification. Indicates that a task provider object has been created. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TaskProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProviderCreateNotification.OnTaskProviderCreate(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>Invoked as part of event processing. See the interface definition for more information.</summary>
      <param name="taskProvider">[In] Represents a task provider that is loaded into the target process.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProviderInitialize">
      <summary>Optional interface implemented by task providers to receive a notification when task providers are first requested for a particular process. This interface is subject to change in future versions of Visual Studio. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskProviderInitialize.InitializeTaskProviders(Microsoft.VisualStudio.Debugger.DkmProcess)">
      <summary>Invoked by the AD7 AL to provide a notification when task providers are first requested from the UI for a particular process. This allows for implementations to delay initialization to when the task UI if first shown.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskSynchronizationObjectProvider">
      <summary>Interface implemented by task provider components to provide the set of synchronization objects owned by a task. This interface is subject to change in future versions of Visual Studio. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TaskProviderId.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTaskSynchronizationObjectProvider.GetSynchronizationObjects(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask)">
      <summary>TODO.</summary>
      <returns>[Out] TODO.</returns>
      <param name="task">[In] Represents either a managed TPL task or a native Concurrency Runtime task.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadContextOperation">
      <summary>Operations provided by a base debug monitor to obtain and update a thread's context (register values). Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadContextOperation.GetContext(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32,System.Byte[])">
      <summary>Obtains the current context (register values) of a thread.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="contextFlags">[In] Win32 flags indicating which part of the CONTEXT object to obtain (ex: CONTEXT_FULL, CONTEXT_CONTROL, CONTEXT_INTEGER).</param>
      <param name="context">[In,Out] A Win32 CONTEXT structure that contains the context of the specified thread. The value of the ContextFlags member of this structure specifies which parts of a thread's context to obtain.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadContextOperation.SetContext(Microsoft.VisualStudio.Debugger.DkmThread,System.Byte[])">
      <summary>Updates the context (register values) of a thread.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="context">[In] A CONTEXT structure that contains the context to be set in the specified thread. The value of the ContextFlags member of this structure specifies which parts of a thread's context to set. Some values in the CONTEXT structure that cannot be specified are silently set to the correct value. This includes bits in the CPU status register that specify the privileged processor mode, global enabling bits in the debugging register, and other states that must be controlled by the operating system.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadCreateNotification">
      <summary>IDkmThreadCreateNotification is implemented by components that want to listen for the ThreadCreate event. When this notification fires, the target process will be suspended and can be examined. TODO. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadCreateNotification.OnThreadCreate(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmEventDescriptorS)">
      <summary>OnThreadCreate is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="workList">WorkList to append additional event processing work to. This work list will begin execution after all listeners have been notifiied. The event will not finish until after the work list fully executes.</param>
      <param name="eventDescriptor">[In] Describes the event being processed and provides the ability for a component to suppress this event.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadDisplayPropertiesQuery">
      <summary>Used to determine a thread's category. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadDisplayPropertiesQuery.GetThreadDisplayProperties(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult})">
      <summary>Gets the Display Properties of the Thread including the Display Name and Thread Category.</summary>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="thread">[In] The Thread.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadExitNotification">
      <summary>IDkmThreadExitNotification is implemented by components that want to listen for the ThreadExit event. The target process may continue to run during this notification. TODO. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadExitNotification.OnThreadExit(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32,Microsoft.VisualStudio.Debugger.DkmEventDescriptor)">
      <summary>OnThreadExit is invoked as part of event processing. See interface definition for more information.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="exitCode">[In] 32-bit value that the process returned on exit. This is the same value that would be reported from the kernel32!GetExitCodeThread.</param>
      <param name="eventDescriptor">[In] Describes the event being processed.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadLocationProvider">
      <summary>Provides the location of a thread, as visible in the threads window, or threads drop down in the debug location toolbar. This is implemented by the Microsoft stack provider component. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadLocationProvider.GetCurrentLocation(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.CallStack.DkmGetCurrentLocationAsyncResult})">
      <summary>Provides the location of a thread, as visible in the threads window, or threads drop down in the debug location toolbar.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="workList">WorkList which is currently being processed. This value can be used to check for cancelation or to append additional work. New work items will not begin executing until after this function returns.</param>
      <param name="completionRoutine">Routine to fire when the request is completed. This will be implicitly fired if the implementation returns failure from this interface method. The implementation must fire this method in all other scenarios.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadNameQuery">
      <summary>Used to determine a thread's name. Does not return the thread's display name. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, RuntimeId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadNameQuery.GetThreadName(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Computes the name of a thread.</summary>
      <returns>[Out,Optional] The thread name.</returns>
      <param name="runtimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="thread">[In] The thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadStackRangeProvider">
      <summary>Returns the stack base and limit of a thread. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadStackRangeProvider.GetStackAddressRange(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Retrieves the stack limit/stack base of the given thread. Note that its possible for this value to change over time, for example, with fibers.</summary>
      <returns>[Out] The limit/base address for the memory that contains a thread's stack.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that the address that contains the TEB structure could not be read from the target process. This may be returned for minidumps without heap.</exception>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadSuspension">
      <summary>Called to suspend or resume a thread and to obtain the current thread suspension count. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadSuspension.GetDebuggerSuspensionCount(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Returns the total number of suspensions caused by the debugger (that is, calls to DkmThread::Suspend without a call to DkmThread::Resume). This excludes any suspensions external to the debugger.</summary>
      <returns>[Out] The total number of suspensions caused by the debugger (that is, calls to DkmThread::Suspend without a call to DkmThread::Resume). This excludes any suspensions external to the debugger.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadSuspension.GetSuspensionCount(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Returns the current suspension count of this thread.</summary>
      <returns>[Out] The suspension count of thread. The internal thread suspension count is subtracted from this value if ShowInternal is false.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="showInternal">[In] Pass true to return the true suspension count for the thread. Return false to only see the suspensions that occurred in the debuggee process or the ones that passed true for InternalSuspension to Suspend.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadSuspension.Resume(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Resume this thread.</summary>
      <returns>[Out,Optional] The previous number of suspensions for this thread minus the ones internal to the debugger before this resume is applied.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="internalSuspension">[In] Pass true if this suspension should be hidden in calls to GetSuspensionCount. This is useful for internal suspensions that should not be reported to the user, such as thread slippage suspensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmThreadSuspension.Suspend(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Suspend this thread.</summary>
      <returns>[Out,Optional] The previous number of suspensions for this thread minus the ones internal to the debugger.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="internalSuspension">[In] Pass true if this suspension should be hidden in calls to GetSuspensionCount. This is useful for internal suspensions that should not be reported to the user, such as thread slippage suspensions.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTlsReadWrite">
      <summary>Provides the ability to read and write from Win32 TLS slots in the target process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTlsReadWrite.GetTlsValue(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32)">
      <summary>Retrieves the value in the debuggee thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
      <returns>[Out] The pointer-sized value which was stored in the thread's TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be zero.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="tlsIndex">[In] The TLS index that was allocated when the target process called the TlsAlloc function.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmTlsReadWrite.SetTlsValue(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32,System.UInt64)">
      <summary>Stores a value in the debuggee thread's thread local storage (TLS) slot for the specified TLS index. Each thread of a process has its own slot for each TLS index.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="tlsIndex">[In] The TLS index that was allocated when the target process called the TlsAlloc function.</param>
      <param name="value">[In] The pointer-sized value to store in the thread's TLS slot. If the target thread is 32-bit, the upper 32-bits of this value will be ignored.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVirtualMemoryAllocator">
      <summary>Implemented by base debug monitors to allow for allocation/free of virtual memory in the target process. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVirtualMemoryAllocator.AllocateVirtualMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Int32,System.Int32,System.Int32)">
      <summary>Reserves and commits a region of memory in the virtual address space of the target process. The function initializes the memory it allocates to zero, unless MEM_RESET is used. For additional information, see the VirtualAlloc Win32 API in MSDN.</summary>
      <returns>[Out] Base address of the allocated region of pages.</returns>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] Address in the target process where the memory should be committed or reserved. This value is typically zero, in which case the system chooses an address.</param>
      <param name="size">[In] The size of the region of memory to allocate, in bytes. The system will automatically round up to the next page boundary.</param>
      <param name="allocationType">[In] Indicates the type of allocation to perform. This is typically MEM_COMMIT | MEM_RESERVE (0x3000) which reserves and commits an allocation in one step.</param>
      <param name="pageProtection">[In] The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants (ex: PAGE_READWRITE, PAGE_EXECUTE).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVirtualMemoryAllocator.FreeVirtualMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Int32,System.Int32)">
      <summary>Releases and decommits a region of memory in the virtual address space of the target process. For additional information, see the VirtualFree Win32 API in MSDN.</summary>
      <param name="process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] Address in the target process where the memory should be freed.</param>
      <param name="size">[In] Number of bytes to decommit. To release a region of memory, this value must be zero.</param>
      <param name="freeType">[In] Indicates the type of free operation to perform. This is typically MEM_RELEASE (0x8000), which releases the specified region of pages. After the operation, the pages are in the free state. MEM_DECOMMIT (0x4000) can be used instead to decommit the pages without releasing them.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices">
      <summary>Interface implemented by the AD7AL as a gateway to services provided by the rest of Visual Studio. Implementations of this interface are always called (no filtering is supported). To reduce memory impact, we recommend that this interface be implemented in a small dll, or that the implementation is configured by using 'CallOnlyWhenLoaded="true"'.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.DisplayUserMessagePrompt(Microsoft.VisualStudio.Debugger.DkmUserMessage)">
      <summary>Displays a message to the user inside the Visual Studio debugger IDE. This function waits for the Visual Studio IDE to complete processing this message. This method may not be called from code that runs as part of UI event processing. Doing so will cause a deadlock. This method requires DkmUserMessage.Process to be non-null.</summary>
      <returns>[Out] Win32 'ID' code from displaying the message box (ex: IDYES). These codes are defined in winuser.h from the Windows SDK.</returns>
      <param name="userMessage">[In] Contains information about a message that is to be displayed to the user.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.GetCodeViewCompilers(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Returns the enumeration of DkmCodeViewCompilerId values. This enumeration may then be used by a symbol provider to map the information in a code view record to the DkmCompilerId structure.</summary>
      <returns>[Out] DkmCodeViewCompilerId[] is used to translate information that is in the S_COMPILE* code view records into a DkmCompilerId. This allows the debugger to load an appropriate expression evaluator for a stack frame. Symbol providers may obtain this collection through DkmEngineSettings. Expression evaluators may add more entries to this collection by having their setup add sub key(s) to the '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.</returns>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.GetLanguageSettings(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting[]@)">
      <summary>Reads language-specific from the registry. The settings are stored under HKLM\Software\Microsoft\VisualStudio\11.0\AD7Metrics\ExpressionEvaluator\[Languag Guid]\[Vendor Guid].</summary>
      <param name="language">[In] Describes a programming language.</param>
      <param name="settings">[Out] Pairing between the name of a setting and its value.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.GetProjectItemScriptBlocks(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument)">
      <summary>Queries the language service (IVsLanguageDebugInfoScript) to obtain script block information from the associated project item of the specified script document.</summary>
      <returns>[Out] Set of script blocks returned from the language service.</returns>
      <param name="scriptDocument">[In] Represents a document which is executing in a script runtime environment.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.GetUserDocumentPath(Microsoft.VisualStudio.Debugger.DkmEngineSettings)">
      <summary>Get the user document Visual Studio folder path.</summary>
      <returns>[Out] Returns the user document Visual Studio path.</returns>
      <param name="settings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.PostUserMessage(Microsoft.VisualStudio.Debugger.DkmUserMessage)">
      <summary>Displays a message to the user inside the Visual Studio debugger IDE. This function does not block waiting for the user to dismiss the error message.</summary>
      <param name="userMessage">[In] Contains information about a message that is to be displayed to the user.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVisualStudioServices.SendToVsService(Microsoft.VisualStudio.Debugger.DkmCustomMessage,System.Guid,System.Boolean)">
      <summary>Sends a custom message to a Visual Studio package. This can be used, for example, to drive a custom UI or make a custom UI visible by enabling a command context (IVsMonitorSelection.SetCmdUIContext). For local 32-bit debugging, the custom message parameters (DkmCustomMessage.Parameter1/2), may contain any value (ex: object/IUnknown, string, etc), however, values are transferred between threads without . Therefore, when this will not work, the sender is responsible for converting the parameter into a form which can be used from the VS service (ex: calling ole32!CoMarshalInterThreadInterfaceInStream). For remote debugging, and 64-bit debugging, the custom message parameters are marshalled across computers, and so the restrictions describe in the DkmCustomMessage.Parameter1 documentation applies.</summary>
      <param name="customMessage">[In] Message structure used to pass information between custom debugger backend components and custom Visual Studio UI components (packages, add-ins, etc).</param>
      <param name="vsService">[In] Visual Studio service that this event should be sent to. A VS package must register this service id. The service class must implement the IVsCustomDebuggerEventHandler110 interface. Services can be registered in the registry ($RootKey$\Services\{VsService}), or through the VS shell IProfferService interface. Registry keys may be set through .pkgdef files. If the service should be called even if it is not already loaded, then the registry approach should be used. If the service should only be called if it has already been started, then IProfferService should be used.</param>
      <param name="isBlocking">[In] True if SendToPackage should block waiting for the package to finish processing this message. When true, DkmCustomMessage.Process must be non-null.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileMemoryOperation">
      <summary>Provides support for reading and writing memory. Unlike IDkmMemoryOperation, this Interface can be used when the process is running, and it will never cache results. Therefore, it should be used with care. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileMemoryOperation.VolatileReadMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Reads memory from the target process. This method differs from 'ReadMemory' in that this method can be called at any time (not just when the target is stopped) and the debugger will not try to cache the result of this operation.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to read the target process's memory.</param>
      <param name="buffer">[In,Out] A buffer that receives the contents from the address space of the target process. On failure, the content of this buffer is unspecified.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_INVALID_MEMORY_ADDRESS indicates that one or more bytes of the request could not be read.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileMemoryOperation.VolatileWriteMemory(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Byte[])">
      <summary>Writes to the memory of the target process. This method differs from 'WriteMemory' in that this method can be called at any time (not just when the target is stopped) and the debugger will not try to cache the result of this operation. If any memory cannot be written to, an E_INVALID_MEMORY_ADDRESS error will be raised. Because the memory write might occur from run mode, this failure might occur after the copy operation has already begun, and therefore could lead to memory corruption in the target process. For this reason, this function must be used with care, and failures may be fatal.</summary>
      <param name="process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="address">[In] The base address from which to write the target process's memory.</param>
      <param name="data">[In] Data to be written in the address space of the specified process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileThreadProperties">
      <summary>Exposes volatile properties of a thread, such as priority and affinity mask. These values are expected to change over time and should not be cached by callers. Implementations of this interface may restrict when they are called using a filter defined in their component configuration. The following properties may be used: BaseDebugMonitorId, EngineId, TransportKind.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileThreadProperties.GetVolatileFlags(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Gets volatile flags about a thread. For instance, returns if a thread is a user-mode scheduled thread.</summary>
      <returns>[Out] Volatile flags that apply to a thread. These values are expected to change over time and should not be cached by callers.</returns>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ComponentInterfaces.IDkmVolatileThreadProperties.GetVolatileProperties(Microsoft.VisualStudio.Debugger.DkmThread,System.Int32@,System.UInt64@)">
      <summary>Gets a thread's dynamic properties.</summary>
      <param name="thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="priority">[Out] The priority of the thread. The values returned correspond to the values defined for kernel32!GetThreadPriority.</param>
      <param name="affinityMask">[Out] The affinity mask of the thread. The values returned correspond to the values defined for kernel32!SetThreadAffinityMask.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomExceptionInformation">
      <summary>Provides information about an exception which was raised in the target process. Custom exceptions are used for C++ Runtime checks, Managed Debugging Assistant failures, and exceptions from third-party runtimes.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomExceptionInformation.AdditionalInformation">
      <summary>[Optional] Additional data about this custom exception. Format is defined by the custom exception type.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomExceptionInformation.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.Guid,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.String,System.UInt32,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmCustomExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="ExceptionCategory">[In] Indicates the type of exception.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="InstructionAddress">[In,Optional] Address where the exception occurred. This will always be present for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these may originate from inside the runtime.</param>
      <param name="Name">[In,Optional] Name of the exception. For C++ or CLR exceptions, this is the type name. This value will be null for exception categories that identify exceptions by code (ex: Win32).</param>
      <param name="Code">[In] 32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</param>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="ImplementationException">[In,Optional] Information about the underlying exception used to implement a higher level exception. For example, CLR and C++ exceptions may be implemented in addition to Win32 exceptions. So this may store the DkmWin32ExceptionInformation for CLR or C++ exceptions.</param>
      <param name="AdditionalInformation">[In,Optional] Additional data about this custom exception. Format is defined by the custom exception type.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress">
      <summary>DkmCustomInstructionAddress is used for addresses from a custom runtime environment (not native or CLR-based). For example, this could be used in a custom interpreter or Just-In-Time compiler.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress.AdditionalData">
      <summary>[Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomModuleInstance,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},System.UInt64,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction)">
      <summary>Create a new DkmCustomInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="ModuleInstance">[In] The module that contains the InstructionPointer.</param>
      <param name="EntityId">[In,Optional] This is a runtime-specific data structure which custom runtimes may use to store the location of this instruction. Along with 'offset', this field will used to compare two instructions from the same module.</param>
      <param name="Offset">[In] Along with 'EntityId' the 'Offset' field is used to uniquely identity an instruction. This could hold a pointer value (such as a pointer to the instruction) or an offset from the start of the function/module.</param>
      <param name="AdditionalData">[In,Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</param>
      <param name="CPUInstruction">[In,Optional] CPUInstruction provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress.EntityId">
      <summary>[Optional] This is a runtime-specific data structure which custom runtimes may use to store the location of this instruction. Along with 'offset', this field will used to compare two instructions from the same module.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress.ModuleInstance">
      <summary>The module that contains the InstructionPointer.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomModuleInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionAddress.Offset">
      <summary>Along with 'EntityId' the 'Offset' field is used to uniquely identity an instruction. This could hold a pointer value (such as a pointer to the instruction) or an offset from the start of the function/module.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionSymbol">
      <summary>TODO.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionSymbol.AdditionalData">
      <summary>[Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionSymbol.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Guid,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},System.UInt64,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmCustomInstructionSymbol object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or at one time was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="RuntimeType">[In] The Runtime Id identifies the execution environment for a particular segment of code. Runtime Ids are used by the dispatcher to decide which monitor to dispatch to. Note that the ordering of the runtime ID Guids is somewhat significant as this dictates which runtime receives the first shot during arbitration. Thus, if one wants to declare a new runtime instance which is built on the CLR, the runtime id should be less than DkmRuntimeId.Clr.</param>
      <param name="EntityId">[In,Optional] This is a runtime-specific data structure which custom runtimes may use to store the location of this instruction. Along with 'offset', this field will used to compare two instructions from the same module.</param>
      <param name="Offset">[In] Along with 'EntityId' the 'Offset' field is used to uniquely identity an instruction. This could hold a pointer value (such as a pointer to the instruction) or an offset from the start of the function/module.</param>
      <param name="AdditionalData">[In,Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionSymbol.EntityId">
      <summary>[Optional] This is a runtime-specific data structure which custom runtimes may use to store the location of this instruction. Along with 'offset', this field will used to compare two instructions from the same module.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomInstructionSymbol.Offset">
      <summary>Along with 'EntityId' the 'Offset' field is used to uniquely identity an instruction. This could hold a pointer value (such as a pointer to the instruction) or an offset from the start of the function/module.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomModuleInstance">
      <summary>Used for modules from a custom runtime environment (not native or CLR-based). For example, this could be used in a custom interpreter or Just-In-Time compiler.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomModuleInstance.Create(System.String,System.String,System.UInt64,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmModuleVersion,Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId,Microsoft.VisualStudio.Debugger.DkmModuleFlags,Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout,System.UInt64,System.UInt32,System.UInt32,System.String,System.Boolean,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmCustomModuleInstance object instance. This method will send a ModuleInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] Short representation of the module name. For file-based modules, this is the file name and extension (ex: kernel32.dll).</param>
      <param name="FullName">[In] Fully qualified module name. For file-based modules, this is the full path of the module (ex: c:\windows\system32\kernel32.dll).</param>
      <param name="TimeDateStamp">[In] Date/time of when the loaded module was built. This value is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a FILETIME value, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="Version">[In,Optional] File version information.</param>
      <param name="SymbolFileId">[In,Optional] Contains information that is required to locate symbols for this module. On Win32, this information is contained in the IMAGE_DEBUG_DIRECTORY.</param>
      <param name="Flags">[In] Flags that indicate traits of a DkmModuleInstance.</param>
      <param name="MemoryLayout">[In] Enumeration that indicates how a module is laid out in memory.</param>
      <param name="BaseAddress">[In,Optional] The starting memory address of where the module loaded. This value will be zero if the module did not load in a contiguous block of memory.</param>
      <param name="LoadOrder">[In] The integer count of the number of module instances that have loaded, up to and including this module. Each runtime instance keeps track of its own load order count.</param>
      <param name="Size">[In,Optional] The number of bytes in the module's memory region. This value will be zero if the module did not load in a contiguous block of memory.</param>
      <param name="LoadContext">[In] String description of the context under which this module has been loaded.</param>
      <param name="IsDisabled">[In] Indicates whether this module instance has been disabled. Disabled modules are largely ignored by the debugger. For native modules, the address range of the disabled module is treated as if it were unmapped. For CLR modules, any frames from these modules is hidden from the call stack.</param>
      <param name="Module">[In,Optional] The symbol handler's representation of a module (DkmModule) that is associated with this module instance. This value is at first null, and is assigned if symbols are associated with this module instance.</param>
      <param name="MinidumpInfo">[In,Optional] MinidumpInfo is used to convey additional information about modules in a DkmProcess for a minidump.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmCustomModuleInstance instance.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomRuntimeInstance">
      <summary>Represents the custom execution environment executing in the target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.CustomRuntimes.DkmCustomRuntimeInstance.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new runtime instance object from a debug monitor. This method must be called from the event thread when a debug monitor detects that a new runtime instance has loaded (for example, when the corresponding runtime .dll loads in the target process). This method will send a RuntimeInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="Id">[In] Identifies a DkmRuntimeInstance object in a process.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmCustomRuntimeInstance instance.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmActivateBackgroundTaskAsyncResult">
      <summary>Result of an asynchronous DkmTransportConnection.ActivateBackgroundTask call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmActivateBackgroundTaskAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmTransportConnection.ActivateBackgroundTask.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmActivateBackgroundTaskAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmActivateBackgroundTaskAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId">
      <summary>Identifies a Windows app package or a Windows Phone app package.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId.AppPlatform">
      <summary>Indicates if the specified app package is a Windows Phone app or a Windows app.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform,System.String)">
      <summary>Create a new DkmAppPackageId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="AppPlatform">[In] Indicates if the specified app package is a Windows Phone app or a Windows app.</param>
      <param name="FullName">[In] The full name of the application. For DkmApplicationPlatform.WindowsAppx, this is the package full name.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId.FullName">
      <summary>The full name of the application. For DkmApplicationPlatform.WindowsAppx, this is the package full name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand">
      <summary>Object representing an arbitrary executable which is executed on the target computer.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Abort">
      <summary>Abort execution of the command by terminating the launched process. If successful, this will cause IDkmDeploymentCommandCallback.OnProcessExit to be called.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Arguments">
      <summary>[Optional] Arguments to pass to the remote command. This value may be null to pass no arguments.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Close">
      <summary>Closes the deployment command object. This should be called by the creator of the DkmDeploymentCommand object after execution has completed (IDkmDeploymentCommandCallback.OnProcessExit is called). DkmDeploymentCommand objects are automatically closed when their associated DkmTransportConnection object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Connection">
      <summary>Transport connection to the target where the command should execute.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.Guid,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmDeploymentCommand object. The command will not begin executing until Start is called. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] Transport connection to the target where the command should execute.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="RemoteExecutable">[In] Path to the remote executable. Environment variables will be expanded (ex: %TMP%\mycommand.exe). If this is not a full path, the remote debugger will look next to itself, and then search the PATH environment variable.</param>
      <param name="Arguments">[In,Optional] Arguments to pass to the remote command. This value may be null to pass no arguments.</param>
      <param name="CurrentDirectory">[In,Optional] Initial current directory for the target process. This value may be null to use the directory of the remote debugger.</param>
      <param name="Flags">[In] Flags effecting the processing of deployment commands.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmDeploymentCommand instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.CurrentDirectory">
      <summary>[Optional] Initial current directory for the target process. This value may be null to use the directory of the remote debugger.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Flags">
      <summary>Flags effecting the processing of deployment commands.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.OnProcessExit(System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.OnStdErr(System.String)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.OnStdOut(System.String)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.RemoteExecutable">
      <summary>Path to the remote executable. Environment variables will be expanded (ex: %TMP%\mycommand.exe). If this is not a full path, the remote debugger will look next to itself, and then search the PATH environment variable.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.Start">
      <summary>Start execution of the deployment command. This method will return after the deployed command has begun execution. Callers of this method would typically implement IDkmDeploymentCommandCallback with a SourceId filter to receive information about the command.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommand.UniqueId">
      <summary>Guid which uniquely identifies this object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags">
      <summary>Flags affecting the processing of deployment commands.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags.Default">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags.ConsoleCodePage">
      <summary>Launched program writes to StdOut/StdErr with the target computer's console code page instead of Unicode (UTF-16).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags.CombineStdErr">
      <summary>Combine StdErr with StdOut. When this flag is set, IDkmDeploymentCommandCallback.OnStdErr will not be called. This is helpful to synchronize StdErr/StdOut content.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmDeploymentCommandFlags.ShowUI">
      <summary>Show the UI for the executed command instead of running hidden.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult">
      <summary>Result of an asynchronous DkmTransportConnection.EnumerateBackgroundTasks call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult.#ctor(System.Guid[],System.String[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmTransportConnection.EnumerateBackgroundTasks.</summary>
      <param name="TaskIds">[In] Background task ids (GUIDs).</param>
      <param name="TaskNames">[In] Background task names.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmTransportConnection.EnumerateBackgroundTasks.</summary>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult.TaskIds">
      <summary>Background task ids (GUIDs).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult.TaskNames">
      <summary>Background task names.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo">
      <summary>Contains basic information about a file which is returned from DefaultPort.DkmTransportConnection.GetFileListing.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.Attributes">
      <summary>Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY (0x10)).</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.Create(System.String,System.String,System.Int32,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Create a new DkmFileInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FileName">[In] Name of the file or sub directory. This name does not contain the directory (ex: example.txt instead of c:\folder\example.txt).</param>
      <param name="FilePath">[In] Full path of the file or sub directory (ex: c:\folder\example.txt).</param>
      <param name="Attributes">[In] Win32 File attribute values (ex: FILE_ATTRIBUTE_DIRECTORY (0x10)).</param>
      <param name="CreationTime">[In] Time the file was created in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</param>
      <param name="LastAccessTime">[In] Time the file was accessed in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</param>
      <param name="LastWriteTime">[In] Time the file was written to in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</param>
      <param name="FileSize">[In] Size of the file in bytes.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.CreationTime">
      <summary>Time the file was created in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.FileName">
      <summary>Name of the file or sub directory. This name does not contain the directory (ex: example.txt instead of c:\folder\example.txt).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.FilePath">
      <summary>Full path of the file or sub directory (ex: c:\folder\example.txt).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.FileSize">
      <summary>Size of the file in bytes.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.LastAccessTime">
      <summary>Time the file was accessed in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileInfo.LastWriteTime">
      <summary>Time the file was written to in FILETIME units (number of 100-nanosecond intervals since January 1, 1601 (UTC)).</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream">
      <summary>Represents a file stream which can be used to transfer a large file over the remote debugger connection.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.Close">
      <summary>Closes the file transfer object. This will close the underlying file handle if it is not already closed because all the bytes have been transferred. This method must be called by the component which created the file transfer object. DkmFileTransferStream objects are automatically closed when their associated DkmTransportConnection object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.Connection">
      <summary>Transport connection over which the file will be transferred.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new file transfer stream object which is used to represent a file which is being streamed over the network. Note that the file is not immediately opened when the object is created. The caller should close the file transfer object when done. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] Transport connection over which the file will be transferred.</param>
      <param name="RemoteFilePath">[In] Path to the file being transferred. Environment variables will be expanded (ex: %TMP%\deploy.txt). The path must be a full path of the file.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmFileTransferStream instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.ReadFirst(System.Byte[],System.Int32@,System.UInt64@,System.UInt64@)">
      <summary>Begins a remote file read operation. The remote file will be opened and the first bytes will be transferred from it.</summary>
      <param name="ContentBuffer">[In,Out] Buffer which receives the starting bytes of the file.</param>
      <param name="BytesRead">[Out] Indicates the number of bytes read into the content buffer.</param>
      <param name="LastWriteTime">[Out] The date/time to set for when this file was last modified. The format of this is the same as a Win32 FILETIME structure, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601.</param>
      <param name="TotalFileSize">[Out] Indicates the size of the file on disk.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.ReadFirst(System.Void*,System.Int32,System.Int32@,System.UInt64@,System.UInt64@)">
      <summary>Begins a remote file read operation. The remote file will be opened and the first bytes will be transferred from it.</summary>
      <param name="ContentBuffer">[In,Out] Buffer which receives the starting bytes of the file.</param>
      <param name="BufferSize">[In] Indicates the size of the content buffer.</param>
      <param name="BytesRead">[Out] Indicates the number of bytes read into the content buffer.</param>
      <param name="LastWriteTime">[Out] The date/time to set for when this file was last modified. The format of this is the same as a Win32 FILETIME structure, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601.</param>
      <param name="TotalFileSize">[Out] Indicates the size of the file on disk.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.ReadNext(System.Byte[],System.Int32@)">
      <summary>Reads the next set of bytes from the remote file. This API will fail if ReadFirst has not already been called on the DkmFileTransferStream.</summary>
      <param name="ContentBuffer">[In,Out] Buffer which receives the next bytes of the file.</param>
      <param name="BytesRead">[Out] Indicates the number of bytes read into the content buffer. This value is the smaller of the number of bytes left in the file (TotalFileSize returned from ReadFirst minus bytes already returned), and the size of the input buffer. In pseudo-code: min(TotalFileSize-BytesAlreadyReturned, BufferSize).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.ReadNext(System.Void*,System.Int32,System.Int32@)">
      <summary>Reads the next set of bytes from the remote file. This API will fail if ReadFirst has not already been called on the DkmFileTransferStream.</summary>
      <param name="ContentBuffer">[In,Out] Buffer which receives the next bytes of the file.</param>
      <param name="BufferSize">[In] Indicates the size of the content buffer.</param>
      <param name="BytesRead">[Out] Indicates the number of bytes read into the content buffer. This value is the smaller of the number of bytes left in the file (TotalFileSize returned from ReadFirst minus bytes already returned), and the size of the input buffer. In pseudo-code: min(TotalFileSize-BytesAlreadyReturned, BufferSize).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.RemoteFilePath">
      <summary>Path to the file being transferred. Environment variables will be expanded (ex: %TMP%\deploy.txt). The path must be a full path of the file.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.UniqueId">
      <summary>Guid which uniquely identifies this object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.WriteFirst(System.Byte[],System.UInt64,System.UInt64,System.Boolean)">
      <summary>Begins a remote file write operation. The remote file will be opened and the first bytes will be written to it. If the directory of this file does not exist, the debugger will attempt to create it.</summary>
      <param name="Content">[In] The initial set of bytes to write to the file.</param>
      <param name="TotalFileSize">[In] Indicates the number of bytes which will be written to the file. The file system handle will automatically be closed as soon as this number of bytes has been received. Attempts to write past this number of bytes will fail. If the DkmFileTransferStream is closed before this number of bytes is transferred, the file will be deleted.</param>
      <param name="LastWriteTime">[In] The date/time to set for when this file was last modified. The format of this is the same as a Win32 FILETIME structure, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601. The value 0xffffffffffffffff may be used to specify that the current time should be used.</param>
      <param name="OverwriteExisting">[In] true if the debugger should attempt to overwrite any existing file. This will fail if the existing file is read-only.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmFileTransferStream.WriteNext(System.Byte[])">
      <summary>Writes the next set of bytes to the remote file. This API will fail if WriteFirst has not already been called on the DkmFileTransferStream.</summary>
      <param name="Content">[In] The next set of bytes to write to the file.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo">
      <summary>Identifies an installed Windows app.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.AppUserModelId">
      <summary>The application user model id.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.BackgroundColor">
      <summary>[Optional] The application background color.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.Create(System.String,System.String,System.String,System.String,System.String,System.String,System.Guid)">
      <summary>Create a new DkmInstalledApplicationInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="AppUserModelId">[In] The application user model id.</param>
      <param name="DisplayName">[In] The application display name.</param>
      <param name="Executable">[In,Optional] The executable name.</param>
      <param name="SmallLogoPath">[In,Optional] The application small logo path. For remote this will be the path on the remote system.</param>
      <param name="BackgroundColor">[In,Optional] The application background color.</param>
      <param name="Description">[In] The application description name.</param>
      <param name="DefaultDebugEngine">[In] The default debug engine to use for debugging this application. If unable to determine, the default is native.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.DefaultDebugEngine">
      <summary>The default debug engine to use for debugging this application. If unable to determine, the default is native.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.Description">
      <summary>The application description name.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.DisplayName">
      <summary>The application display name.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.Executable">
      <summary>[Optional] The executable name.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo.SmallLogoPath">
      <summary>[Optional] The application small logo path. For remote this will be the path on the remote system.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo">
      <summary>Identifies an installed Windows app package.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.Applications">
      <summary>[Optional] Array of applications found in the App Package.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.AppPackageId">
      <summary>Identifies a Windows app package or a Windows Phone app package.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.String,System.String,System.String,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledApplicationInfo})">
      <summary>Create a new DkmInstalledAppPackageInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="DisplayName">[In] The App Package display name.</param>
      <param name="Version">[In] The App Package version.</param>
      <param name="LogoPath">[In,Optional] The App Package logo path. For remote this will be the path on the remote system.</param>
      <param name="Applications">[In,Optional] Array of applications found in the App Package.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.DisplayName">
      <summary>The App Package display name.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.LogoPath">
      <summary>[Optional] The App Package logo path. For remote this will be the path on the remote system.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmInstalledAppPackageInfo.Version">
      <summary>The App Package version.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform">
      <summary>Indicates whether the specified app package is a Windows Phone app or a Windows app.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform.WindowsAppx">
      <summary>Used for Windows apps.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform.WindowsPhoneXAP">
      <summary>Used for Windows Phone XAP applications.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState">
      <summary>Describes the app package's current execution state. For Windows apps, the values match the values in PACKAGE_EXECUTION_STATE.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState.Unknown">
      <summary>The application's state is unknown.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState.Running">
      <summary>The application is running.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState.Suspending">
      <summary>The application is being suspended.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState.Suspended">
      <summary>The application is suspended.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackageExecutionState.Terminated">
      <summary>The application is ended.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures">
      <summary>Flags indicating features that are available in the processor on which this system/process/thread is running. These generally deal with register set availability.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.None">
      <summary>Processor does not support any additional features.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.MMX">
      <summary>On x86, used to indicate that the CPU supports MMX registers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.SSE">
      <summary>On x86, used to indicate that the CPU supports SSE registers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.SSE2">
      <summary>On x86, used to indicate that the CPU supports SSE2 registers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.AMD3DNow">
      <summary>On x86, used to indicate that the CPU supports 3DNow! registers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.AVX">
      <summary>On x86/x64, used to indicate that the CPU supports AVX registers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures.VFP32">
      <summary>On ARM, used to indicate that the CPU supports the full set of floating-point registers (Q0-Q15, D0-D31, and S0-S63). On ARM, when this flag is cleared, the only supported floating-point registers include Q0-Q3, D0-D7, and S0-S15.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPublishedProgramInfo">
      <summary>Contains information about active script code running in the target process, or other information published through CLSID_ProgramPublisher (IDebugProgramPublisher2.PublishProgram/PublishProgramNode).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPublishedProgramInfo.Create(System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.Guid})">
      <summary>Creates a new DkmPublishedProgramInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FriendlyName">[In,Optional] A friendly name for the program. This may be displayed in the Attach to Processes window. This is exposed to the AD7 API via IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).</param>
      <param name="EngineIds">[In] The collection of engines that can debug this code.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPublishedProgramInfo.EngineIds">
      <summary>The collection of engines that can debug this code. Generally, this collection only has one entry. For script, this value is DkmEngineId.Script.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmPublishedProgramInfo.FriendlyName">
      <summary>[Optional] A friendly name for the program. This may be displayed in the Attach to Processes window. This is exposed to the AD7 API via IDebugProgramNode2.GetHostName(GHN_FRIENDLY_NAME).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode">
      <summary>Authentication mode to use when it connects over a standard remote connection.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode.WindowsNegotiate">
      <summary>Use built-in Windows authentication. Client and server will negotiate either Kerberos or NTLM. This is the default value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode.Kerberos">
      <summary>Use built-in Windows Kerberos Authentication.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode.NTLM">
      <summary>Use built-in NTLM authentication. This option can be used when Kerberos is malfunctioning.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode.None">
      <summary>Disable authentication. This value can only be used on trusted networks.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode.Custom">
      <summary />
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags">
      <summary>Flags that contain Boolean properties of the running process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.None">
      <summary>Default value for DkmRunningProcessFlags.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.Wow64">
      <summary>Process is a 32-bit process that is running on a 64-bit computer. This is computed when DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.DebuggerAttached">
      <summary>There is a Win32 debugger attached to the process. This is computed when DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.OtherUser">
      <summary>Process is running under a different user account than the debug monitor.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.SecurityWarningOnAttach">
      <summary>A security warning should be displayed before attaching to this process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.AppContainer">
      <summary>Process is running in AppContainer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags.HideFromDefaultProcessList">
      <summary>Process should be hidden in the process listing unless the user wants all processes to be shown. This is computed when DkmRunningProcessInfoPropertyMask.FilterFlags is set.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo">
      <summary>Snapshot of basic information about a running process. Unlike DkmProcess, this information is for a process which is not necessarily being debugged. This can be either returned as part of a task list, or information can be returned for a single process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.AppPackageId">
      <summary>[Optional] The id of the app package for this process. Null if the process is not part of a Windows app or a Windows Phone app. This is computed when DkmRunningProcessInfoPropertyMask.AppPackageId is set.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.ClrVersions">
      <summary>[Optional] Version number for all the CLR instances loaded into the debugged process.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.CommandLine">
      <summary>[Optional] Command line used to start the process.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.Create(System.Int32,System.Int64,System.Int32,System.String,System.String,System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.String,System.String,System.String,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.DefaultPort.DkmPublishedProgramInfo},Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags,System.UInt16,Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId)">
      <summary>Create a new DkmRunningProcessInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="StartTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process.</param>
      <param name="SessionId">[In] Terminal server session id for the process (-1 if not obtained).</param>
      <param name="Name">[In,Optional] Full path of the starting executable of the process. If the full path cannot be obtained, this may only contain the base executable name.</param>
      <param name="Title">[In,Optional] Title of the process's main window (if any).</param>
      <param name="UserName">[In,Optional] User name that the process is running under (ex: MyCompany\MyAlias).</param>
      <param name="ClrVersions">[In,Optional] Version number for all the CLR instances loaded into the debugged process.</param>
      <param name="CommandLine">[In,Optional] Command line used to start the process.</param>
      <param name="CurrentDirectory">[In,Optional] Current directory of the process.</param>
      <param name="EnvironmentBlock">[In,Optional] Environment block of the process.</param>
      <param name="IntegrityLevel">[In] SECURITY_MANDATORY_*_RID value that is used to indicate the integrity level of this process. -1/MAXDWORD is used if the integrity level is unknown/invalid such as on pre-Vista operating systems where integrity levels do not exist, or if the user identity of process could not be obtained.</param>
      <param name="PublishedPrograms">[In,Optional] The set of programs which have been published for this process through pdm.dll. This is primarily used to determine script debugging information but may also be used for other runtimes that notify the debugger of their existence through CLSID_ProgramPublisher.</param>
      <param name="Flags">[In] Flags that contain Boolean properties of the running process.</param>
      <param name="ProcessorArchitecture">[In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9). This is computed when DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.</param>
      <param name="AppPackageId">[In,Optional] The id of the app package for this process. Null if the process is not part of a Windows app or a Windows Phone app. This is computed when DkmRunningProcessInfoPropertyMask.AppPackageId is set.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.CurrentDirectory">
      <summary>[Optional] Current directory of the process.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.EnvironmentBlock">
      <summary>[Optional] Environment block of the process.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.Flags">
      <summary>Flags that contain Boolean properties of the running process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.Id">
      <summary>Process Id (PID) assigned by the operating system.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.IntegrityLevel">
      <summary>SECURITY_MANDATORY_*_RID value that is used to indicate the integrity level of this process. -1/MAXDWORD is used if the integrity level is unknown/invalid such as on pre-Vista operating systems where integrity levels do not exist, or if the user identity of process could not be obtained.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.Name">
      <summary>[Optional] Full path of the starting executable of the process. If the full path cannot be obtained, this may only contain the base executable name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.ProcessorArchitecture">
      <summary>Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9). This is computed when DkmRunningProcessInfoPropertyMask.BasicInfoFlags is set.</summary>
      <returns>Returns <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.PublishedPrograms">
      <summary>[Optional] The set of programs which have been published for this process through pdm.dll. This is primarily used to determine script debugging information but may also be used for other runtimes that notify the debugger of their existence through CLSID_ProgramPublisher.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.SessionId">
      <summary>Terminal server session id for the process (-1 if not obtained).</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.StartTime">
      <summary>64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.Title">
      <summary>[Optional] Title of the process's main window (if any).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfo.UserName">
      <summary>[Optional] User name that the process is running under (ex: MyCompany\MyAlias).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask">
      <summary>Flags indicating which properties of DkmRunningProcessInfo should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.Empty">
      <summary>No information should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.StartTime">
      <summary>'StartTime' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.SessionId">
      <summary>'SessionId' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.Name">
      <summary>'Name' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.Title">
      <summary>'Title' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.UserName">
      <summary>'UserName' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.ClrVersions">
      <summary>'ClrVersions' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.CommandLine">
      <summary>'CommandLine' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.CurrentDirectory">
      <summary>'CurrentDirectory' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.EnvironmentBlock">
      <summary>'EnvironmentBlock' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.IntegrityLevel">
      <summary>'IntegrityLevel' field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.BasicInfoFlags">
      <summary>'DkmRunningProcessFlags.Wow64' and 'DkmRunningProcessFlags.DebuggerAttached' should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.UserIdentityFlags">
      <summary>'DkmRunningProcessFlags.OtherUser' and 'DkmRunningProcessFlags.SecurityWarningOnAttach' should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.FilterFlags">
      <summary>'DkmRunningProcessFlags.HideFromDefaultProcessList' should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.PublishedPrograms">
      <summary>PublishedPrograms field should be computed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask.AppPackageId">
      <summary>'AppPackageId' field should be computed.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmShutDownAppPackageAsyncResult">
      <summary>Result of an asynchronous DkmTransportConnection.ShutDownAppPackage call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmShutDownAppPackageAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmTransportConnection.ShutDownAppPackage.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmShutDownAppPackageAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmShutDownAppPackageAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmStandardRemoteTransportConnection">
      <summary>This represents a remote connection between the monitor and the IDE over the standard transport. This class derives from DkmTransportConnection and defines options that are used to connect to the target computer.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmStandardRemoteTransportConnection.AuthenticationMode">
      <summary>Authentication mode to use when it connects over a standard remote connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmRemoteAuthenticationMode" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmStandardRemoteTransportConnection.ProxyServer">
      <summary>[Optional] Proxy server that is used when it connects to this computer. This is null if the debugger is directly connected to the computer.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSuspendAppPackageAsyncResult">
      <summary>Result of an asynchronous DkmTransportConnection.SuspendAppPackage call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSuspendAppPackageAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmTransportConnection.SuspendAppPackage.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSuspendAppPackageAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSuspendAppPackageAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation">
      <summary>Contains information about the computer system that a process or connection is using. It can be obtained through the 'SystemInformation' property of a process, or from DefaultPort.DkmTransportConnection.GetSystemInformation.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.Create(Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture,System.Int32,System.Int32,System.UInt16,Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags,Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures)">
      <summary>Creates a new DkmSystemInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ProcessorArchitecture">[In] Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9).</param>
      <param name="PageSize">[In] Minimum size for a virtual memory page. This value may be zero in remote device scenarios where the page size is unknown.</param>
      <param name="OperatingSystemVersion">[In] 4-byte value that contains the operating system version packed as {platform id, major version, minor version, service pack major version}. The platform id from the OSVERSIONINFO structure and is currently always defined to VER_PLATFORM_WIN32_NT (2).</param>
      <param name="SuiteMask">[In] VER_SUITE_* flags from the OSVERSIONINFOEX structure.</param>
      <param name="Flags">[In] Flags that provide information about the system that a computer system that a process/thread/connection is using.</param>
      <param name="ProcessorFeatures">[In] Flags indicating features that are available in the processor on which this system/process/thread is running. These generally deal with register set availability.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.Flags">
      <summary>Flags that provide information about the system that a computer system that a process/thread/connection is using.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.OperatingSystemVersion">
      <summary>4-byte value that contains the operating system version packed as {platform id, major version, minor version, service pack major version}. The platform id from the OSVERSIONINFO structure and is currently always defined to VER_PLATFORM_WIN32_NT (2).</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.PageSize">
      <summary>Minimum size for a virtual memory page. This value may be zero in remote device scenarios where the page size is unknown.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.ProcessorArchitecture">
      <summary>Example: PROCESSOR_ARCHITECTURE_INTEL (0), PROCESSOR_ARCHITECTURE_ARM (5), or PROCESSOR_ARCHITECTURE_AMD64 (9).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcessorArchitecture" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.ProcessorFeatures">
      <summary>Flags indicating features which are available in the processor on which this system/process/thread is running. These generally deal with register set availability.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmProcessorFeatures" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformation.SuiteMask">
      <summary>VER_SUITE_* flags from the OSVERSIONINFOEX structure.</summary>
      <returns>Returns <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags">
      <summary>Flags which provide information about the system that a computer system that a process/thread/connection is using.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags.Default">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags.Is64Bit">
      <summary>The process/OS is 64-bit.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmSystemInformationFlags.DumpFile">
      <summary>Indicates that the process/OS is from a .dmp file or other snapshot of a single point in time.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection">
      <summary>Represents a connection between the monitor and the IDE. It can be a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection. Derived classes: DkmStandardRemoteTransportConnection</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ActivateAppPackage(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DefaultPort.DkmPackagedAppPlatform,System.String,System.Boolean,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Start.DkmActivateAppPackageAsyncResult})">
      <summary>Activates the specified packaged application. This will cause the application to start if it has not already started, and will bring it back as the active application if it is already running. When launching under the debugger, IDkmProcessLaunchNotifyListener.StartListener will be called before this API. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="AppPlatform">[In] Indicates whether the specified app package is a Windows Phone app or a Windows app.</param>
      <param name="ActivationName">[In] Identifier for the application to launch.</param>
      <param name="LaunchForDebugging">[In] If true, the application is being debugged.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ActivateBackgroundTask(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32,System.Guid,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DefaultPort.DkmActivateBackgroundTaskAsyncResult})">
      <summary>Activates a background task. This is used by developers to test an app's activate handler. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="SessionId">[In] The id of the session where the application is running.</param>
      <param name="TaskId">[In] Activating task id (GUID).</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.CreateDirectory(System.String)">
      <summary>Creates a directory on the target computer. Note that directories are implicitly created when you deploy files, so this API does not have to be used in that scenario.</summary>
      <param name="RemoteDirectoryPath">[In] Path to the remote directory that will be created. Environment variables will be expanded (ex: %TMP%\MyDirectory). The directory cannot be a relative path.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.DeleteFile(System.String)">
      <summary>Deletes a file on the target computer.</summary>
      <param name="RemoteFilePath">[In] Path to the remote file that will be deleted. Environment variables will be expanded (ex: %TMP%\deploy.txt).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.DeployFile(System.String,System.String,System.Boolean)">
      <summary>Deploys a file to the target computer. Note that this will copy the file content and last write time but not attributes. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="LocalFilePath">[In] Path to the local file that will be copied. The path must be a full path.</param>
      <param name="RemoteFilePath">[In] Path to the remote file that will be written. Environment variables will be expanded (ex: %TMP%\deploy.txt). This must be a full path. If the directory of this file does not exist, the debugger will attempt to create it.</param>
      <param name="OverwriteExisting">[In] true if the debugger should attempt to overwrite any existing file. This will fail if the existing file is read-only.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.DownloadFile(System.String,System.String,System.Boolean)">
      <summary>Downloads a file from the target computer. Note that this will copy the file content and last write time but not attributes. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="RemoteFilePath">[In] Path to the remote file that will be written. Environment variables will be expanded (ex: %TMP%\deploy.txt).</param>
      <param name="LocalFilePath">[In] Local path where the download file will be put. The path must be a full path, and the directory must already exist.</param>
      <param name="OverwriteExisting">[In] True if the debugger should attempt to overwrite any existing file. This will fail if the existing file is read-only.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.EnumerateBackgroundTasks(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DefaultPort.DkmEnumerateBackgroundTasksAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.EnumPackages"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.EnumRunningProcesses(System.Boolean,Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask)">
      <summary>Provides a listing of all the processes running on the target computer (including processes not being debugged).</summary>
      <returns>[Out] Array of processes running on the target computer.</returns>
      <param name="IncludeFromAllUsers">[In] If true, processes from all users should be included.</param>
      <param name="RequestedPropertyMask">[In] Flags indicating which properties of DkmRunningProcessInfo should be computed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ExtractFromDeployConnection(Microsoft.VisualStudio.Debugger.Interop.IVsDebuggerDeployConnection)">
      <summary>Obtains the DkmTransportConnection object that backs the deploy connection.  This can be used to bridge from the debugger deploy API to the debugger engine (Dkm) APIs. As an example, this can be used to send DkmCustomMessages. The caller must still hold onto deployConnection to avoid the underlying DkmTransportConnection from being disposed.</summary>
      <returns>DkmTransportConnection that backs the AD7 object.</returns>
      <param name="deployConnection">AD7 default port object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ExtractFromPort(Microsoft.VisualStudio.Debugger.Interop.IDebugPort2)">
      <summary>Obtains the DkmTransportConnection object that backs the port object. This will fail in remote debugging scenarios if the port is not currently connected and reconnect is unsuccessful. This API will only function correctly from the main thread of Visual Studio.</summary>
      <returns>DkmTransportConnection that backs the AD7 object.</returns>
      <param name="portObject">AD7 default port object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.FindConnection(System.Guid)">
      <summary>Finds a DkmTransportConnection object. If no object that has the given input key is present, FindConnection will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="UniqueId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.FindLiveProcess(System.Int32)">
      <summary>Finds a DkmProcess element within the DkmTransportConnection. If no element that has the given input key is present, FindLiveProcess will fail. If an object is found, it will always contain the 'Live' Part.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Id">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.FindProcess(System.Guid)">
      <summary>Finds a DkmProcess element within the DkmTransportConnection. If no element that has the given input key is present, FindProcess will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="UniqueId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.Flags">
      <summary>Flags indicating traits of the underlying connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnectionFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.FlushClosedObjectQueue">
      <summary>This function is used to force all object close notifications to be immediately exchanged with the monitor process. Like 'GC.Collect' in managed code, this function is typically unnecessary, as the system automatically flushes the queue. However, this method can be used if it is important that all updates are immediately exchanged. An object close notification is created (and queued) when a component calls 'Close' on a given object. Both the monitor process and the engine process maintain a queue of closed objects. This method may only be called from the engine process, but it is used to flush both queues. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetAppPackageExecutionState(Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32)">
      <summary>Gets the execution state of the Windows app. The values in this field are specified in PACKAGE_EXECUTION_STATE.</summary>
      <returns>[Out] The execution state of the application.</returns>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="SessionId">[In] The id of the session where the application is running.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetClrVersionOfExecutable(System.String)">
      <summary>Provides the version string for the CLR that the debugger expects a given executable to load. The return value is based on the content of the executable's PE header (if the .exe is managed), the executable's config file, CLR environment variables, and loader policy in the registry. The return value may be incorrect, especially with a native executable.</summary>
      <returns>[Out] Version string of the CLR. Ex: 'v4.0.30319'.</returns>
      <param name="ExePath">[In] Path to the executable file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetConnections">
      <summary>Enumerates all the created DkmTransportConnection objects.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetDefaultClrVersion">
      <summary>Returns the version of the CLR that is loaded in the monitor process.</summary>
      <returns>[Out] Version string of the CLR. Ex: 'v4.0.30319'.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetDNSName">
      <summary>Provides the physical DNS host name that the target computer uses.</summary>
      <returns>[Out] Computer name. For more information, see ComputerNamePhysicalDnsHostname in the Win32 documentation for GetComputerNameEx.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetFileListing(System.String,System.String,System.Boolean)">
      <summary>Obtains a listing of files and subdirectories that exist on the target computer.</summary>
      <returns>[Out] File information for all found files and subdirectories.</returns>
      <param name="RootDirectoryPath">[In] Path to a remote directory under which the search will be performed.</param>
      <param name="SearchWildcard">[In] Wildcard search string to use when matching files. For example, '*' to obtain all files and directories, or 'example.txt' to obtain information about just 'example.txt'.</param>
      <param name="Recursive">[In] True if all subdirectories under <paramref name="RootDirectoryPath" /> should be checked for files. This option excludes reparse points like mounted drives and symbolic links.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetIsolatedStorageRootForApplication(Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId)">
      <summary>Obtains the full path of the isolated storage root directory for the specified application. This API is not yet implemented for Windows apps, but it is reserved for future use.</summary>
      <returns>[Out,Optional] Full path of the directory on the target system. Null if the application has no isolated storage directory.</returns>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetLiveProcesses">
      <summary>Enumerates the DkmProcess elements of the DkmTransportConnectionobject. All objects contain the 'Live' Part.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetProcesses">
      <summary>Enumerates the DkmProcess elements of the DkmTransportConnection object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetRequests">
      <summary>Enumerates the DkmProcessLaunchRequest elements of the DkmTransportConnection object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetRunningProcessInfo(System.Int32,System.Int64,System.Boolean,Microsoft.VisualStudio.Debugger.DefaultPort.DkmRunningProcessInfoPropertyMask)">
      <summary>Obtains information about a process that is running on the target computer.</summary>
      <returns>[Out] Information about the requested process.</returns>
      <param name="Id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="StartTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process. '0' can be passed if the start time is unknown.</param>
      <param name="IsDebuggee">[In] When true, the request will fail if the debugger has insufficient permissions to complete the request. If false, the implementation should calculate what it can.</param>
      <param name="RequestedPropertyMask">[In] Flags indicating which properties of DkmRunningProcessInfo should be computed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.GetSystemInformation(System.Boolean)">
      <summary>Provides information about the computer where the debug monitor is running.</summary>
      <returns>[Out] Object describing the system where the debugger is running.</returns>
      <param name="NativeSystemInfo">[In] If true and if the debug monitor is running under WOW64, this function will return information about the native subsystem instead of WOW. If the debug monitor is not running under WOW, this function is ignored.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.Kind">
      <summary>Indicates the type of transport being used to debug.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.Qualifier">
      <summary>[Optional] String indicating the connection destination. This will be null for the local connection. For default remote debugging, this is the computer name and port number that you are trying to connect to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.QueryIsWOW64Executable(System.String)">
      <summary>Determines whether the given executable file will execute within WOW64 (Windows-32-bit-On-Windows-64-bit), which is used to execute 32-bit processes on a 64-bit operating system.</summary>
      <returns>[Out] True if the specified executable file will execute under WOW.</returns>
      <param name="ExePath">[In] Path to the executable file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.RemoveDirectory(System.String,System.Boolean)">
      <summary>Removes a directory on the target computer.</summary>
      <param name="RemoteDirectoryPath">[In] Path to the remote directory that will be removed. Environment variables will be expanded (ex: %TMP%\MyDirectory). The directory cannot be a relative path.</param>
      <param name="Recursive">[In] True if all files and subdirectories under 'RootDirectoryPath' should be removed. If false, this operation will fail unless the directory is empty.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ResumeAppPackage(Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32)">
      <summary>Performs a simulated process lifetime management-based resume on the specified application. This is used by developers to test an app's resume handler.</summary>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="SessionId">[In] The id of the session where the application is running.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.ShutDownAppPackage(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DefaultPort.DkmShutDownAppPackageAsyncResult})">
      <summary>Suspends and then shuts down the specified application by using the process lifetime management services. Using this followed by a second application launch, developers can test an app's ability to restart from suspended state. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="SessionId">[In] The id of the session where the application is running.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.SuspendAppPackage(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DefaultPort.DkmAppPackageId,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.DefaultPort.DkmSuspendAppPackageAsyncResult})">
      <summary>Performs a simulated process lifetime management-based suspend on the specified application. This is used by developers to test an app's suspend handler. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="AppPackageId">[In] Identifies a Windows app package or a Windows Phone app package.</param>
      <param name="SessionId">[In] The id of the session where the application is running.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.TerminateRunningProcess(System.Int32,System.Int64,System.Int32)">
      <summary>Terminates a process that is running on target computer that is not being debugged.</summary>
      <param name="Id">[In] Process Id (PID) assigned by the operating system.</param>
      <param name="StartTime">[In] 64-bit date time value indicating when the process was started. The start time together with the id and the computer where the process was started can uniquely identify a process. '0' can be passed if the start time is unknown.</param>
      <param name="ExitCode">[In] The exit code that will be used by the process and threads ended because of this call. Use the GetExitCodeProcess function to retrieve a process's exit value. Use the GetExitCodeThread function to retrieve a thread's exit value.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection.UniqueId">
      <summary>GUID that uniquely identifies the connection. The local connection will use the value 'DkmTransportKind.Local'. The value for other connections will be randomly generated.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnectionFlags">
      <summary>Flags indicating traits of the underlying connection.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnectionFlags.LocalComputer">
      <summary>Connection is to the local computer. This is used for both the 'pseudo-remote' connection and the local connection.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnectionFlags.MarshallingRequired">
      <summary>Requests that cross from the higher level debugger components (ex: AD7 AL, symbol handler, etc) to the low-level debugger components (ex: debug monitor) require marshaling.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnectionFlags.DefaultConnectionToTarget">
      <summary>This connection is considered the default way to connect to the destination computer. This flag will be used for the local connection, and for connections running on the default port of remote computers.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportKind">
      <summary>Indicates the type of transport being used to debug.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportKind.Local">
      <summary>Used when the monitor and engine are in the same process. This is used to debug local 32-bit processes.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportKind.PseudoRemote">
      <summary>Used when the monitor and engine are in separate processes on the same computer. This is used for debugging 64-bit processes.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportKind.StandardRemote">
      <summary>Used for remote debugging over the standard remoting infrastructure.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction">
      <summary>Contains information about a disassembled instruction in the debuggee. Objects are returned from DkmProcess.Disassemble.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.Address">
      <summary>The formatted address of this instruction in the debuggee address space.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.AddressOffset">
      <summary>The address as an offset from some starting point, usually the start of the associated function.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.ByteOffset">
      <summary>The number of bytes from the start of the corresponding source statement.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.CodeBytes">
      <summary>The code bytes for this instruction.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.UInt32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition,System.UInt32,System.Collections.ObjectModel.ReadOnlyCollection{System.Int32},System.Boolean)">
      <summary>Create a new DkmDisassembledInstruction object instance. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="InstructionPointer">[In] The address of this instruction in the debuggee address space.</param>
      <param name="InstructionLength">[In] The length of the instruction in bytes.</param>
      <param name="Address">[In] The formatted address of this instruction in the debuggee address space.</param>
      <param name="AddressOffset">[In] The address as an offset from some starting point, usually the start of the associated function.</param>
      <param name="CodeBytes">[In] The code bytes for this instruction.</param>
      <param name="RawOpcode">[In] The raw opcode for this instruction without symbolic lookups.</param>
      <param name="RawOperands">[In] The raw operands for this instruction without symbolic lookups.</param>
      <param name="FormattedOpcode">[In] The opcode for this instruction including resolved symbol names. If nothing is resolved, this is the same as RawOpcode.</param>
      <param name="FormattedOperands">[In] The operands for this instruction including resolved symbol names. If nothing is resolved, this is the same as RawOperands.</param>
      <param name="Symbol">[In,Optional] The symbol name, if any, associated with the address (public symbol, label, and so on).</param>
      <param name="DocumentPosition">[In,Optional] An optional reference to the document and text position this instruction belongs to in the source document.</param>
      <param name="ByteOffset">[In] The number of bytes from the start of the corresponding source statement.</param>
      <param name="RegisterOperands">[In] A read only collection of CV constants representing any register arguments in the disassembled instruction.</param>
      <param name="ValidInstruction">[In] True if this instruction was successfully disassembled. False if it is a filler instruction used by heuristic unwinders when an invalid op code is encountered. Most disassembly providers will fill the op code with question marks when this is set to true to indicate a bogus instruction.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.DocumentPosition">
      <summary>[Optional] An optional reference to the document and text position this instruction belongs to in the source document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.FormattedOpcode">
      <summary>The opcode for this instruction including resolved symbol names. If nothing is resolved, this is the same as RawOpcode.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.FormattedOperands">
      <summary>The operands for this instruction including resolved symbol names. If nothing is resolved, this is the same as RawOperands.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.InstructionLength">
      <summary>The length of the instruction in bytes.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.InstructionPointer">
      <summary>The address of this instruction in the debuggee address space.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.RawOpcode">
      <summary>The raw opcode for this instruction without symbolic lookups.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.RawOperands">
      <summary>The raw operands for this instruction without symbolic lookups.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.RegisterOperands">
      <summary>A read only collection of CV constants representing any register arguments in the disassembled instruction.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.Symbol">
      <summary>[Optional] The symbol name, if any, associated with the address (public symbol, label, and so on).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Disassembly.DkmDisassembledInstruction.ValidInstruction">
      <summary>True if this instruction was successfully disassembled. False if it is a filler instruction used by heuristic unwinders when an invalid op code is encountered. Most disassembly providers will fill the op code with question marks when this is set to true to indicate a bogus instruction.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddress">
      <summary>An effective address for an instruction. The effective address is the calculated address that an instruction operand represents. For instance, on x86, an instruction may be of the form dwordptr [esp-12]. The effective address of this operand will be the result of subtracting 12 from esp. The number of operands and effective addresses are architecture specific.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddress.#ctor(System.UInt64,System.UInt32,Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddressFlags)">
      <summary>Initialize a new DkmEffectiveAddress value.</summary>
      <param name="EffectiveAddress">[In] The effective address for the operand.</param>
      <param name="OperandSize">[In] The size of the operand this address applies to.</param>
      <param name="Flags">[In] Set if the segment register is FS. Only used on x86.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddress.EffectiveAddress">
      <summary>The effective address for the operand.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddress.Flags">
      <summary>Set if the segment register is FS. Only used on x86.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddress.OperandSize">
      <summary>The size of the operand this address applies to.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddressFlags">
      <summary>Flags that affect the effective address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddressFlags.None">
      <summary>No flags applied.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Disassembly.DkmEffectiveAddressFlags.SegmentIsFS">
      <summary>Indicates that the segment register is FS. Used only on x86.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression">
      <summary>Dispatcher object that represents a child node of a visualized expression. Each node returned from GetChildren/GetItems should be an instance of this object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,System.Guid,System.Guid,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression,System.UInt32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmChildVisualizedExpression object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionContext">[In] Options and target context to use while it is performing the inspection operation.</param>
      <param name="VisualizerId">[In] GUID that ties together the addin and the expressions that call that addin.</param>
      <param name="SourceId">[In] GUID that ties together the expression evaluator that created this object and the object itself. Generally used by expression evaluators to filter their implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression they created.</param>
      <param name="StackFrame">[In] Stack frame the expression is being evaluated in expression in.</param>
      <param name="ValueHome">[In] Base class for all expression value homes.</param>
      <param name="EvaluationResult">[In] The result of evaluating this visualized child. The expression evaluator can override this instance, so do not rely on storing data items in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data container instead.</param>
      <param name="Parent">[In] The Parent of this visualized child.</param>
      <param name="Index">[In] The index of this child in the parent object's child collection. The expression evaluator will use this when it processes the full name of a child item.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmChildVisualizedExpression instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression.EvaluationResult">
      <summary>The result of evaluating this visualized child. The expression evaluator can override this instance, so do not rely on storing data items in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data container instead.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression.Index">
      <summary>The index of this child in the parent object's child collection. The expression evaluator will use this when it processes the full name of a child item. The full name is used when the user clicks an item and says Add To Watch or when the user types something in the Watch window directly. If the visualizer does not provide a full name, then callback to the expression evaluator to construct a default expand expression. The value of the index field will be used to obtain the correct expand expression.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression.Parent">
      <summary>The Parent of this visualized child.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledCustomInspectionQuery">
      <summary>An inspection query compiled to a custom format. The RuntimeType indicates the format of the query.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledCustomInspectionQuery.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.Guid,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmCompiledCustomInspectionQuery object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="QueryKind">[In] Indicates the type of inspection query. This is used to select a component to process the query.</param>
      <param name="Instructions">[In] Body of the query.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledCustomInspectionQuery.Instructions">
      <summary>Body of the query.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery">
      <summary>Represents a query which is produced by an expression evaluator or similar component and set to the target computer to obtain information about the dynamic state of the program (ex: the current value of a register). Derived classes: DkmCompiledCustomInspectionQuery, DkmCompiledILInspectionQuery</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Execute(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue},Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult})">
      <summary>Executes a compiled inspection query and returns any results. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Parameters">[In,Optional] Optional array of parameter values to pass to the IL stream.</param>
      <param name="ILContext">[In] The stack frame context we are evaluating on.</param>
      <param name="Timeout">[In] This is the time-out that will be used for potentially slow operations such as a function evaluation. This value is in milliseconds.</param>
      <param name="FuncEvalFlags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Execute(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue},Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason@)">
      <summary>Executes a compiled inspection query and returns any results.</summary>
      <returns>[Out] Results of the evaluations. Each ILEvaluationResult object contains an index that indicates which DkmILInstruction in the instructions parameter this result came from. NOTE: some instructions will not return a result.</returns>
      <param name="Parameters">[In,Optional] Optional array of parameter values to pass to the IL stream.</param>
      <param name="ILContext">[In] The stack frame context we are evaluating on.</param>
      <param name="Timeout">[In] This is the time-out that will be used for potentially slow operations such as a function evaluation. This value is in milliseconds.</param>
      <param name="FuncEvalFlags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="FailureReason">[Out] If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.QueryKind">
      <summary>Indicates the type of inspection query. This is used to select a component to process the query.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.TagValue">
      <summary>DkmCompiledInspectionQuery is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Tag">
      <summary>DkmCompiledInspectionQuery is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Tag.DkmILQuery">
      <summary>The object is an instance of 'DkmCompiledILInspectionQuery'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery.Tag.CustomQuery">
      <summary>The object is an instance of 'DkmCompiledCustomInspectionQuery'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQueryKind">
      <summary>Indicates the type of inspection query. This is used to select a component to process the query.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQueryKind.DkmIL">
      <summary>Query is a DkmCompiledILInspectionQuery object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId">
      <summary>Identifies the compiler (language and vendor) that a method comes from. This is used to select an expression evaluator.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.#ctor(System.Guid,System.Guid)">
      <summary>Initialize a new DkmCompilerId value.</summary>
      <param name="VendorId">[In] Vendor for the compiler. In some contexts this may be Guid.Empty to indicate that the vendor is unknown.</param>
      <param name="LanguageId">[In] Language that the code was written in. In some contexts, this may be Guid.Empty to indicate that the language is unknown.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.CompareTo(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.Equals(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId structure.</summary>
      <returns>'true' if the two elements are equal.</returns>
      <param name="other">Value to comare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.LanguageId">
      <summary>Language that the code was written in. In some contexts, this may be Guid.Empty to indicate that the language is unknown.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_Equality(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_GreaterThan(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_Inequality(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_LessThan(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Compare two elements of the DkmCompilerId sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId.VendorId">
      <summary>Vendor for the compiler. In some contexts this may be Guid.Empty to indicate that the vendor is unknown.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomRawReturnValue">
      <summary>DkmCustomRawReturnValue carries sufficient context that can be used to partially reconstruct and visualize a function call's return value in a custom runtime environment.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomRawReturnValue.Create(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmCustomRawReturnValue object instance.</summary>
      <returns>[Out] The result of this method call.</returns>
      <param name="ReturnFrom">[In] The IP address in the symbol that was returned called and from. Note that there is no guarantee where in the function this address will be.</param>
      <param name="Value">[In] Custom raw return value.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomRawReturnValue.Value">
      <summary>Custom raw return value.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo">
      <summary>Contains information about a custom UI visualizer which can be displayed for an evaluation result.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo.Create(System.UInt32,System.String,System.String,System.String)">
      <summary>Create a new DkmCustomUIVisualizerInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In] Unique id for this viewer.</param>
      <param name="MenuName">[In] The text that will appear in the drop-down menu.</param>
      <param name="Description">[In,Optional] The description of the custom viewer.</param>
      <param name="Metric">[In] The name of the EE metric under which viewer CLSID is stored.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo.Description">
      <summary>[Optional] The description of the custom viewer.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo.Id">
      <summary>Unique id for this viewer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo.MenuName">
      <summary>The text that will appear in the drop-down menu.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo.Metric">
      <summary>The name of the EE metric under which viewer CLSID is stored.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress">
      <summary>Represents an address in data. Derived classes: DkmGPUDataAddress</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.UInt64,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Created a new DkmDataAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="Value">[In] Data address.</param>
      <param name="InstructionAddress">[In,Optional] Set when the data address is an instruction address.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress.InstructionAddress">
      <summary>[Optional] Set when the data address is an instruction address.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress.Value">
      <summary>Data address.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.EvaluateExpression call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.EvaluateExpression.</summary>
      <param name="ResultObject">[In] Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.EvaluateExpression.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_PROCESS_DESTROYED indicates that the process exited while it tries to evaluate.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult.ResultObject">
      <summary>Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.EvaluateReturnValue call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.EvaluateReturnValue.</summary>
      <param name="ResultObject">[In,Optional] Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object. If not present, the function had no return value.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.EvaluateReturnValue.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_PROCESS_DESTROYED indicates that the process exited while it tries to evaluate.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult.ResultObject">
      <summary>[Optional] Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object. If not present, the function had no return value.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult">
      <summary>Result of an asynchronous DkmEvaluationResultEnumContext.GetItems call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmEvaluationResultEnumContext.GetItems.</summary>
      <param name="Items">[In] The DkmEvaluationResult items to return. Each item must be closed by the caller when the caller has finished.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmEvaluationResultEnumContext.GetItems.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult.Items">
      <summary>The DkmEvaluationResult items to return. Each item must be closed by the caller when the caller has finished.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags">
      <summary>Flags which effect how an input expression should be parsed, compiled or displayed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.None">
      <summary>Input expression should be treated with the default semantics.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.TreatAsExpression">
      <summary>The text is an expression (not a statement).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.TreatFunctionAsAddress">
      <summary>The text might contain function name/parameter signatures, and the expression is to be parsed [and later evaluated] as an address.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.NoSideEffects">
      <summary>The expression evaluator should not evaluate expressions which have side effects, such as assignment statements. The debugger UI will use this flag when the expression must be treated with care, such as in data tips. It is up to the expression evaluator to decide what is considered a side effect for their language.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.NoFuncEval">
      <summary>Expression evaluators should not try a func-eval. If a component mistakenly issues a func-eval with this flag set then the func-eval will not be honored.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.DesignTime">
      <summary>The expression evaluation is occurring in the context of design-time expression evaluation (DTEE). In this scenario, the user enters text in the immediate window in design mode.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.AllowImplicitVariables">
      <summary>Allow the variables to be declared as part of the expression.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.ForceEvaluationNow">
      <summary>Force evaluation to occur now. Somebody is requesting it (such as the user). Since this flag only affects the display of the expression, it may be varied between compile and display.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.ShowValueRaw">
      <summary>Display the type members as is without the aid of a native visualizer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.ForceRealFuncEval">
      <summary>If the runtime in question supports interpreted func-evaluation, this flag means to perform real func-evaluations instead of interpreting any function calls in the process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.HideNonPublicMembers">
      <summary>Expression evaluators should hide non-public members.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags.NoToString">
      <summary>Expression evaluators should call ToString method if flag is not present.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult">
      <summary>The formatted result of an evaluation, ready to be displayed in an expression evaluation window. Derived classes: DkmFailedEvaluationResult, DkmSuccessEvaluationResult</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Close">
      <summary>Closes the evaluation result object to release the resources associated with it. This method must be invoked by the component which initiated the enumeration (ex: called DkmInspectionContext.EvaluateExpression, DkmEvaluationResultEnumContext.GetItems, etc). DkmEvaluationResult objects are automatically closed when their associated DkmInspectionSession object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.CreateObjectId">
      <summary>Creates an object id for this particular expression. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.DestroyObjectId">
      <summary>Destroys an object id for this particular expression. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.FullName">
      <summary>[Optional] The full name of the expression this result applies to. This value is used to enable child elements to be added to the watch window (Add Watch from the context menu), and to refresh parts of the evaluation tree. As an example of how FullName differs from name, the name of the 0th element of an array in C++ is '[0]' whereas the full name would by 'myArrayVariable[0]'.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.GetChildren(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult})">
      <summary>Gets an enumeration context used to obtain the children of this evaluation result. This is used in all expression evaluation windows. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="InitialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be returned. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="InspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.GetUnderlyingString">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window (click the magnifying glass icon). Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.InspectionContext">
      <summary>Inspection context used to create this evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.InspectionSession">
      <summary>The InspectionSession allows the various components which examine data in the target process to store private data with the same lifetime. Inspection sessions are closed when the user attempts to continue the process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Language">
      <summary>Language used to perform inspections.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Name">
      <summary>The name of the expression this result applies to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.RuntimeInstance">
      <summary>Indicates which runtime monitor will be used to perform this evaluation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.SetValueAsString(System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
      <param name="Value">[In] Textual representation of value to assign to the evaluation result.</param>
      <param name="Timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="ErrorText">[Out,Optional] If the operation failed, this indicates the reason why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.StackFrame">
      <summary>The stack frame this expression result was created on.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.TagValue">
      <summary>DkmEvaluationResult is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.UniqueId">
      <summary>Guid which uniquely identifies this evaluation result.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Tag">
      <summary>DkmEvaluationResult is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Tag.SuccessResult">
      <summary>Object is an instance of 'DkmSuccessEvaluationResult'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult.Tag.FailedResult">
      <summary>Object is an instance of 'DkmFailedEvaluationResult'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType">
      <summary>Specifies the access control level (public, private, etc) of the represented field/method/property. This is principally used by the debugger UI to select icons in the watch and other expression evaluation windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType.None">
      <summary>Not applicable (the result of the expression is not a field of a class).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType.Public">
      <summary>Indicates that the result of the expression is a public field.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType.Private">
      <summary>Indicates that the result of the expression is a private field.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType.Protected">
      <summary>Indicates that the result of the expression is a protected field.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType.Final">
      <summary>Indicates that the result of the expression is a final field.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory">
      <summary>The category (ex: Data, Method, etc.) of the underlying value represented by this evaluation result. This is principally used by the debugger UI to select icons in the Watch and other expression evaluation windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Other">
      <summary>Indicates that the evaluation result does not belong to a category listed in this enumeration.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Data">
      <summary>Indicates that the evaluation result represents data.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Method">
      <summary>Indicates that the evaluation result represents a method.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Event">
      <summary>Indicates that the evaluation result represents an event.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Property">
      <summary>Indicates that the evaluation result represents a property.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Class">
      <summary>Indicates that the evaluation result represents a class.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.Interface">
      <summary>Indicates that the evaluation result represents an interface.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.BaseClass">
      <summary>Node in the evaluation result tree to access fields/properties/etc. of a base class.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.InnerClass">
      <summary>Node in the evaluation result tree to access fields/properties/etc. of an inner class.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory.MostDerivedClass">
      <summary>Node in the evaluation result tree to access fields/properties/etc. of the most derived class.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext">
      <summary>Context object that is used to enumerate child members of an evaluation result, or to enumerate local variables from a stack frame. This is logically similar to an enumerator, except that access to elements is index-based instead of sequential.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.Close">
      <summary>Closes the enum context object to release the resources associated with it. This method must be invoked by the component which initiated the enumeration (ex: called DkmEvaluationResult.GetChildren or DkmInspectionContext.GetFrameLocals). DkmEvaluationResultEnumContext objects are automatically closed when their associated DkmInspectionSession object is closed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.Count">
      <summary>The number of items (DkmEvaluationResults) which can be obtained through this DkmEvaluationResultEnumContext.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.Create(System.Int32,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmEvaluationResultEnumContext object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Count">[In] The number of items (DkmEvaluationResults) which can be obtained through this DkmEvaluationResultEnumContext.</param>
      <param name="StackFrame">[In] The stack frame this expression result was created on.</param>
      <param name="InspectionContext">[In] Inspection context used to create this enumeration context.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmEvaluationResultEnumContext instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.GetItems(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationEnumAsyncResult})">
      <summary>Obtain DkmEvaluationResult items from this enumeration context. This is used to obtain local variables of a stack frame or child members from an evaluation result. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="StartIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="Count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.InspectionContext">
      <summary>Inspection context used to create this enumeration context.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.InspectionSession">
      <summary>The InspectionSession allows the various components which examine data in the target process to store private data with the same lifetime. Inspection sessions are closed when the user attempts to continue the process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.Language">
      <summary>Language used to perform inspections.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.RuntimeInstance">
      <summary>Indicates which runtime monitor will be used to perform this evaluation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.StackFrame">
      <summary>The stack frame this expression result was created on.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext.UniqueId">
      <summary>Guid which uniquely identifies this enumeration context.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags">
      <summary>Flags which indicate attributes of an expression evaluation result.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.None">
      <summary>No attribute flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.SideEffect">
      <summary>Indicates that the evaluation caused a side effect.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.Expandable">
      <summary>Indicates that the result of this evaluation has children which can be accessed through IDkmLanguageExpressionEvaluator.GetChildrenEnumContext.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.Boolean">
      <summary>Indicates that the result of the evaluation is a Boolean value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.BooleanTrue">
      <summary>If the Boolean flag is set, indicates that the result of the evaluation is "true", instead of "false".</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.RawString">
      <summary>Indicates that the result of the expression represents a conceptual string that can be displayed in the string viewer. The EE should be prepared to provide the raw string via IDkmLanguageExpressionEvaluator::GetUnderlyingString().</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.Address">
      <summary>Indicates that the result of the expression evaluation is an address that can be navigated to in the memory window.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.ReadOnly">
      <summary>Indicates that the result of the expression evaluation is read-only. If false, the user will be able to modify the value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.ILInterpreter">
      <summary>Indicates that the IL interpreter was used to get the result of the expression evaluation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.UnflushedSideEffects">
      <summary>Indicates that the expression contains side effects that were discarded by the IL interpreter. To flush the side effects, the user should re-evaluate the expression with real func-evals turned on.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.HasObjectId">
      <summary>Indicates that the expression has an object id associated with it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.CanHaveObjectId">
      <summary>Indicates that the expression can have an object id assigned to it.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.CrossThreadDependency">
      <summary>Indicates that the expression was rejected because it has a cross thread dependency.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags.Invalid">
      <summary>Indicates that the value is invalid.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType">
      <summary>If the result of an expression evaluation is data, indicates where the data is stored. This is principally used by the debugger UI to select icons in the watch and other expression evaluation windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType.None">
      <summary>Indicates that the evaluation result does not have a storage type.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType.Global">
      <summary>Indicates that the evaluation result represents a global variable.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType.Static">
      <summary>Indicates that the evaluation result represents a static variable.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType.Register">
      <summary>Indicates that the evaluation result represents a register.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags">
      <summary>Type modifier flags (ex: const). These are principally used by the debugger UI to select icons in the watch and other expression evaluation windows.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags.None">
      <summary>None.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags.Virtual">
      <summary>Indicates that the represented method/property is virtual.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags.Constant">
      <summary>Indicates that the represented value is a constant.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags.Synchronized">
      <summary>Indicates that the represented method/class is synchronized.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags.Volatile">
      <summary>Indicates that the represented field is volatile.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult">
      <summary>Result of an asynchronous DkmCompiledInspectionQuery.Execute call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult[],Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmCompiledInspectionQuery.Execute.</summary>
      <param name="Results">[In] Results of the evaluations. Each ILEvaluationResult object contains an index that indicates which DkmILInstruction in the instructions parameter this result came from. Note: some instructions will not return a result.</param>
      <param name="FailureReason">[In] If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmCompiledInspectionQuery.Execute.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult" />.</returns>
      <param name="exception">[In] Exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult.FailureReason">
      <summary>If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmExecuteQueryAsyncResult.Results">
      <summary>Results of the evaluations. Each ILEvaluationResult object contains an index that indicates which DkmILInstruction in the instructions parameter this result came from. Note: some instructions will not return a result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome">
      <summary>Base class for all expression value homes. Derived classes: DkmFakeValueHome, DkmPointerValueHome</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome.TagValue">
      <summary>DkmExpressionValueHome is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome.Tag">
      <summary>DkmExpressionValueHome is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome.Tag.PointerValueHome">
      <summary>Object is an instance of DkmPointerValueHome.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome.Tag.FakeValueHome">
      <summary>Object is an instance of DkmFakeValueHome.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult">
      <summary>The formatted result of a failed evaluation, ready to be displayed in an expression evaluation window.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmFailedEvaluationResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionContext">[In] Inspection context used to create this evaluation result.</param>
      <param name="StackFrame">[In] The stack frame this expression result was created on.</param>
      <param name="Name">[In] The name of the expression this result applies to.</param>
      <param name="FullName">[In,Optional] The full name of the expression this result applies to. This value is used to allow for child elements to be added to the watch window (Add Watch from the context menu), and to refresh parts of the evaluation tree. As an example of how FullName differs from name, the name of the 0th element of an array in C++ is '[0]' whereas the full name would by 'myArrayVariable[0]'.</param>
      <param name="ErrorMessage">[In] Specifies the error message to display to the user.</param>
      <param name="Flags">[In] Flags which indicate attributes of an expression evaluation result.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmFailedEvaluationResult instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult.ErrorMessage">
      <summary>Specifies the error message to display to the user.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult.Flags">
      <summary>Flags which indicate attributes of an expression evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmFakeValueHome">
      <summary>An instance of DkmExpressionValueHome that does not represent anything real. Normally used to represent values that do not actually occur in the debuggee.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmFakeValueHome.Address">
      <summary>A straight linear address in the debuggee process.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmFakeValueHome.Create(System.UInt64)">
      <summary>Creates a new DkmFakeValueHome object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Address">[In] A straight linear address in the debuggee process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags">
      <summary>Flags affecting how function evaluation requests are performed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags.None">
      <summary>The function evaluation will continue past stopping events (ex: breakpoints will be skipped) and will execute on a single thread (all other threads will be left suspended).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags.AllowStoppingEvents">
      <summary>Indicates that stopping events should be processed ordinarily during the function evaluation. This option is used for function evaluation requests from the immediate window. When this flag is missing, most stopping events are immediately suppressed. This flag should only be enabled by the AD7 AL.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags.RunAllThreads">
      <summary>All threads should run during the function evaluation. If this flag is missing, all threads other than the evaluating thread are suspended during the evaluation. A component may use this flag together with the thread suspension API in order to suspend a subset of the threads in the application. This flag may not be used with function evaluation requests from the event thread.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult">
      <summary>Result of an asynchronous DkmEvaluationResult.GetChildren call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[],Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmEvaluationResult.GetChildren.</summary>
      <param name="InitialChildren">[In] The initial children to return. Each child must be closed by the caller when the caller has finished.</param>
      <param name="EnumContext">[In] Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmEvaluationResult.GetChildren.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult.EnumContext">
      <summary>Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetChildrenAsyncResult.InitialChildren">
      <summary>The initial children to return. Each child must be closed by the caller when the caller has finished.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.GetFrameArguments call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.GetFrameArguments.</summary>
      <param name="Arguments">[In] DkmEvaluationResult for each argument. Each DkmEvaluationResult must be closed by the caller when done with the object.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult.Arguments">
      <summary>DkmEvaluationResult for each argument. Each DkmEvaluationResult must be closed by the caller when done with the object.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.GetFrameArguments.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.GetFrameLocals call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.GetFrameLocals.</summary>
      <param name="EnumContext">[In] Context object that is used to enumerate child members of an evaluation result, or to enumerate local variables from a stack frame. This is logically similar to an enumerator, except that access to elements is index-based instead of sequential.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.GetFrameLocals.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult.EnumContext">
      <summary>Context object that is used to enumerate child members of an evaluation result, or to enumerate local variables from a stack frame. This is logically similar to an enumerator, except that access to elements is index-based instead of sequential.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.GetFrameName call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult.#ctor(System.String)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.GetFrameName.</summary>
      <param name="FrameName">[In] Language's representation of the name of this frame.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.GetFrameName.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult.FrameName">
      <summary>Language's representation of the name of this frame.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.GetFrameReturnType call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult.#ctor(System.String)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.GetFrameReturnType.</summary>
      <param name="ReturnType">[In,Optional] Language's representation of the return type for this frame.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.GetFrameReturnType.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult.ReturnType">
      <summary>[Optional] Language's representation of the return type for this frame.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult">
      <summary>Result of an asynchronous DkmLanguage.GetLanguageSettings call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmLanguage.GetLanguageSettings.</summary>
      <param name="Settings">[In] Pairing between the name of a setting and its value.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmLanguage.GetLanguageSettings.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult.Settings">
      <summary>Pairing between the name of a setting and its value.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext">
      <summary>Context to use for IL evaluation.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.Create(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverride)">
      <summary>Create a new DkmILContext object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="StackFrame">[In] Stack frame to use for evaluation. The specific thread to use may be overridden using the optional ThreadOverride part.</param>
      <param name="ThreadOverride">[In,Optional] Optional section that describes an alternative thread to use for evaluation.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.StackFrame">
      <summary>Stack frame to use for evaluation. The specific thread to use may be overridden using the optional ThreadOverride part.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverridePart">
      <summary>[Optional] Optional section that describes an alternative thread to use for evaluation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverride" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverride">
      <summary>Optional section that describes an alternative thread to use for evaluation.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverride.#ctor(System.UInt64)">
      <summary>Initialize a new ThreadOverride value.</summary>
      <param name="ThreadId">[In] Global-to-kernel thread ID to use for evaluation.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext.ThreadOverride.ThreadId">
      <summary>Global-to-kernel thread ID to use for evaluation.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext">
      <summary>Options and target context to use when it performs the inspection operation.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue)">
      <summary>Creates a new DkmInspectionContext object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionSession">[In] Allows the various components that examine data in the target process to store private data with the same lifetime. Inspection sessions are closed when the user attempts to continue the process.</param>
      <param name="RuntimeInstance">[In] Indicates which runtime monitor will be used to perform this evaluation.</param>
      <param name="Thread">[In] The thread being examined.</param>
      <param name="Timeout">[In] This is the time-out that will be used for potentially slow operations, such as a function evaluation. This value is in milliseconds.</param>
      <param name="EvaluationFlags">[In] Flags that effect how an input expression should be parsed, compiled, or displayed.</param>
      <param name="FuncEvalFlags">[In] Flags affecting how function evaluation requests are performed.</param>
      <param name="Radix">[In] The radix to use when formatting integer data. Currently supported values are '16' and '10'.</param>
      <param name="Language">[In] Language used to perform inspections.</param>
      <param name="ReturnValue">[In,Optional] The last ReturnValue on the thread. It's valid in the current thread context and be used to evaluate $ReturnValue.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.EvaluateExpression(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateExpressionAsyncResult})">
      <summary>Binds the input expression and evaluates it, and then formats the resulting value for display in the debugger. This is used for data tips, the watch windows, the Immediate window, and so on. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components when you debug code running under the CLR, but this functionality might be removed in a future version.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Expression">[In] DkmLanguageExpression represents an expression to be parsed and evaluated by an expression evaluator.</param>
      <param name="StackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.EvaluateExpressionOnThreads(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult})">
      <summary>Binds the input expression and evaluates it, and then formats the resulting value for display in the debugger. This is used for data tips, the watch windows, the Immediate window, and so on This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Threads">[In] The compute threads to use when executing the query.</param>
      <param name="StackFrame">[In] Stack frame to match on compute threads.</param>
      <param name="Expression">[In] Expression to evaluate.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.EvaluateReturnValue(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluateReturnValueAsyncResult})">
      <summary>Evaluates and formats a given DkmRawReturnValue, using only the provided data. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="StackFrame">[In] Stack frame that provides the context in which to evaluate the expression.</param>
      <param name="RawReturnValue">[In] Return value target and cached context.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.EvaluationFlags">
      <summary>Flags that affect how an input expression should be parsed, compiled, or displayed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.FuncEvalFlags">
      <summary>Flags affecting how function evaluation requests are performed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmFuncEvalFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.GetFrameArguments(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameArgumentsAsyncResult})">
      <summary>Provides information about the arguments of a stack frame. This is currently only exposed through the Visual Studio automation model (EnvDTE.StackFrame.Arguments). This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components when you debug code running under the CLR, but this functionality might be removed in a future version.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Frame">[In] Walked frames that the evaluator is requested to describe.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.GetFrameLocals(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameLocalsAsyncResult})">
      <summary>Gets an enumeration context used to obtain the local variables of this stack frame. This is used in computing the Locals window. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components when you debug code running under the CLR, but this functionality might be removed in a future version.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="StackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.GetFrameName(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameNameAsyncResult})">
      <summary>Provides a text representation for a stack frame. This is used when it builds the formatted call stack. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components when you debug code running under the CLR, but this functionality might be removed in a future version.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Frame">[In] Walked frames that the evaluator is requested to describe.</param>
      <param name="ArgumentFlags">[In] Flags to indicate what information about the arguments should be included in the frame name.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.GetFrameReturnType(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetFrameReturnTypeAsyncResult})">
      <summary>Provides a text representation of the return type for one or more stack frames. This is currently only exposed through the Visual Studio automation model (EnvDTE.StackFrame.ReturnType). This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Frame">[In] Walked frames that the evaluator is requested to describe.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.InspectionSession">
      <summary>Allows the various components that examine data in the target process to store private data with the same lifetime. Inspection sessions are closed when the user attempts to continue the process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.Language">
      <summary>Language used to perform inspections.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.Radix">
      <summary>The radix to use when formatting integer data. Currently supported values are '16' and '10'.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.ReturnValue">
      <summary>[Optional] The last ReturnValue on the thread. It's valid in the current thread context and be used to evaluate $ReturnValue.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.RuntimeInstance">
      <summary>Indicates which runtime monitor will be used to perform this evaluation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.Thread">
      <summary>The thread being examined.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext.Timeout">
      <summary>The time-out that will be used for potentially slow operations, such as a function evaluation. This value is in milliseconds.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession">
      <summary>Allows the various components which inspect data to store private data that is associated with a group of evaluations.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession.Close">
      <summary>Closes a DkmInspectionSession object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmInspectionSession objects are automatically closed when their associated DkmProcess object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmInspectionSession object instance. The caller is responsible for closing the created object after finishing.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmInspectionSession instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession.UniqueId">
      <summary>GUID that uniquely identifies this inspection session.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage">
      <summary>Describes a programming language.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage.Create(System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Create a new DkmLanguage object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] Name of the programming language (ex: C++). This string will appear in the call stack window.</param>
      <param name="Id">[In] LanguageId/VendorId pair for this DkmLanguage object. For the default language, both of these values will be Guid.Empty. For all other languages, both of these values are non-zero.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage.GetLanguageSettings(Microsoft.VisualStudio.Debugger.DkmLanguageRegistrySetting[]@)">
      <summary>Reads language-specific from the registry. The settings are stored under HKLM\Software\Microsoft\VisualStudio\11.0\AD7Metrics\ExpressionEvaluator\[Languag Guid]\[Vendor Guid].</summary>
      <param name="Settings">[Out] Pairing between the name of a setting and its value.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage.GetLanguageSettings(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.DkmGetLanguageSettingsAsyncResult})">
      <summary>Reads language-specific from the registry. The settings are stored under HKLM\Software\Microsoft\VisualStudio\11.0\AD7Metrics\ExpressionEvaluator\[Languag Guid]\[Vendor Guid]. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage.Id">
      <summary>LanguageId/VendorId pair for this DkmLanguage object. For the default language, both of these values will be Guid.Empty. For all other languages, both of these values are non-zero.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage.Name">
      <summary>Name of the programming language (ex: C++). This string will appear in the call stack window.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression">
      <summary>Represents an expression to be parsed and evaluated by an expression evaluator.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.Close">
      <summary>Closes a DkmLanguageExpression object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. This method may only be called by the component that created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.CompilationFlags">
      <summary>Flags that effect how the condition text should be compiled by the expression evaluator. During evaluation, the caller must make sure that the DkmEvaluationFlags set on the InspectionContext agree with this value -- that is that they may only differ by the last set of flags which are only relevant to the display of values.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationFlags,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmLanguageExpression object. This can be evaluated with DkmInspectionContext.EvaluateExpression. The caller is responsible for closing the created object after finishing.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Language">[In] Describes a programming language.</param>
      <param name="CompilationFlags">[In] Flags that effect how the condition text should be compiled by the expression evaluator. During evaluation, the caller must make sure that the DkmEvaluationFlags set on the InspectionContext agree with this value -- that is that they may only differ by the last set of flags which are only relevant to the display of values.</param>
      <param name="Text">[In] Source text of the parsed expression.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmLanguageExpression instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.Language">
      <summary>Describes a programming language.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.Text">
      <summary>Source text of the parsed expression.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression.UniqueId">
      <summary>GUID that uniquely identifies this expression object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId">
      <summary>TODO.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.C">
      <summary>C.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.CausalityBreakpoint">
      <summary>Language used for causality function breakpoints (ASMX).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.ClientScript">
      <summary>Client side (targeting Internet Explorer) script.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Cobol">
      <summary>Cobol.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Cpp">
      <summary>C++.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.CSharp">
      <summary>C#.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Fortran">
      <summary>Fortran.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.HLSL">
      <summary>HLSL.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.ILAssembly">
      <summary>MSIL Assembly.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Java">
      <summary>Java.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.JScript">
      <summary>JScript (ECMA Script).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.MethodId">
      <summary>Language used for specifying MVID/METHOD_TOKEN. This is used for Indigo. Example: '{6AF7F59F-ED82-4f76-95BE-6BB908DBDC69}/06000001'.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Pascal">
      <summary>Pascal.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.Script">
      <summary>Script.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.SQL">
      <summary>T-SQL.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageId.VB">
      <summary>Visual Basic.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress">
      <summary>Pairing between an instruction address and the language that should be used to decode it.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.Address">
      <summary>Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.Compile(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.Evaluation.DkmFailedEvaluationResult@)">
      <summary>Compile the input expression so that it is ready for evaluation. A typical expression evaluator may lex the input string, parse the tokens, bind the tokens to symbols and possibly transform the expression into an intermediate representation for evaluation. However, because this method returns no result on success, all of this processing is optional and an expression evaluator may delay all of this work to the 'EvaluateExpression' method. The advantage of performing this work during 'Compile' is to issue any expression errors back to this user as soon as possible, and to improve the performance of repeated evaluations. Currently, these advantages appear in the user scenario of breakpoint conditions -- 'Compile' errors can be shown to the user before the dialog closes, and as breakpoints may be hit frequently, there may be noticeable performance advantages of moving work from 'Evaluate' to 'Compile'. 'Compile' may also be used in HPC scenarios where an expression is compiled against one input address and then evaluated against the same method in various other processes. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Expression">[In] Expression to compile.</param>
      <param name="Error">[Out,Optional] Indicates any error compiling the expression. On successful compilation, this value should be null. In error cases, this value is used to indicate the reason for the compilation failure, and the caller should return S_OK.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.CompileCondition(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointCondition,System.String@)">
      <summary>Compiles an input breakpoint condition into an inspection query which can be evaluated on the target computer. If the breakpoint condition uses DkmBreakpointConditionOperator.BreakWhenTrue, the expression evaluator should require that the specified condition evaluates to a Boolean value. The created query must return only a single result. For BreakWhenTrue conditions, this must be either a 4-byte or 1-byte value, and any non-zero value is considered true. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] The result of the compilation. This is null in the case that the compilation failed. In this case, ErrorText should indicate the reason for the failure.</returns>
      <param name="Condition">[In] Breakpoint condition to compile.</param>
      <param name="ErrorText">[Out,Optional] If the compilation failed, this indicates the reason why. This value should be null if the compile succeeded. If the compile does fail, S_FALSE is returned (native code only).</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Create a new DkmLanguageInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Language">[In] Describes a programming language.</param>
      <param name="Address">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.GetMethodName(Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags)">
      <summary>Provides a text representation for a method symbol. This is used when describing an address in the UI, for example the 'Function' column in the breakpoints window. Location constraint: IDE components may call this method regardless of what type of code is being debugged. This method is also currently supported for debug monitor components, when you debug code running under the CLR; however this functionality may be removed in a future version.</summary>
      <returns>[Out] Language's representation of the name of this method.</returns>
      <param name="ArgumentFlags">[In] Flags to indicate what information about the arguments should be included in the method name. As parameter values cannot be obtained without a stack frame and a stack frame is not available here, the "Values" flag will never be present.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.GetStepIntoFlags">
      <summary>Called during a Step-Into to determine special behavior for a particular function. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Flags which describe how to continue with a Step-Into action.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.Language">
      <summary>Describes a programming language.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageInstructionAddress.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeRawReturnValue">
      <summary>DkmNativeRawReturnValue carries sufficient context that can be used to partially reconstruct and visualize a function call's return value in the context of Native stepping.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeRawReturnValue.Create(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeReturnValueRegister},System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmNativeRawReturnValue object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ReturnFrom">[In] IP address in the symbol that was returned called and from. Note that there is no guarantee where in the function this address will be.</param>
      <param name="Registers">[In] Set of platform dependent registers that may hold the return value.</param>
      <param name="Memory">[In] The result of copying some (platform dependent) number of bytes at the address referenced by the (platform dependent) return-value register. May be used to provide visualizations for pointer return values.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeRawReturnValue.Memory">
      <summary>The result of copying some (platform dependent) number of bytes at the address referenced by the (platform dependent) return-value register. May be used to provide visualizations for pointer return values.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeRawReturnValue.Registers">
      <summary>Set of platform dependent registers that may hold the return value.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeReturnValueRegister">
      <summary>Set of platform dependent registers that may hold the return value of a function call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeReturnValueRegister.Create(System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmNativeReturnValueRegister object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Identifier">[In] The code-view register ID constant.</param>
      <param name="Value">[In] The value of the register. The size of the register in bytes can be found by the length of this array.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeReturnValueRegister.Identifier">
      <summary>The code-view register ID constant.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmNativeReturnValueRegister.Value">
      <summary>The value of the register. The size of the register in bytes can be found by the length of this array.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmPointerValueHome">
      <summary>An instance of DkmExpressionValueHome that defines a linear address in the debuggee. The expression evaluator addin should format the object pointed to by this address.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmPointerValueHome.Address">
      <summary>A straight linear address in the debuggee process.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmPointerValueHome.Create(System.UInt64)">
      <summary>Create a new DkmPointerValueHome object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Address">[In] A straight linear address in the debuggee process.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue">
      <summary>DkmRawReturnValue carries sufficient context that can be used to partially reconstruct and visualize a function call's return value. Derived classes: DkmCustomRawReturnValue, DkmNativeRawReturnValue</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.ReturnFrom">
      <summary>IP address in the symbol that was returned called and from. Note that there is no guarantee where in the function this address will be.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.TagValue">
      <summary>DkmRawReturnValue is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.Tag">
      <summary>DkmRawReturnValue is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.Tag.NativeRawReturnValue">
      <summary>Object is an instance of 'DkmNativeRawReturnValue'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue.Tag.CustomRawReturnValue">
      <summary>Object is an instance of 'DkmCustomRawReturnValue'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression">
      <summary>Dispatcher object that represents a top-level visualized expression. An instance is created by the expression evaluator when it determines that a type should be visualized.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.ArrayLength">
      <summary>If this is an array and the expression evaluator was able to determine the length of that array, this will be non-zero. Note that there are cases where the expression evaluator will not be able to provide this data.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,System.Guid,System.Guid,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags,System.UInt32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmRootVisualizedExpression object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionContext">[In] Options and target context to use when it performs the inspection operation.</param>
      <param name="VisualizerId">[In] GUID that ties together the addin and the expressions that call that addin.</param>
      <param name="SourceId">[In] GUID that ties together the expression evaluator that created this object and the object itself. Generally used by expression evaluators to filter their implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpressions that they created.</param>
      <param name="StackFrame">[In] Stack frame the expression is being evaluated in expression in.</param>
      <param name="ValueHome">[In] Base class for all expression value homes.</param>
      <param name="Module">[In] The module that contains the type symbol.</param>
      <param name="Name">[In] The name of the expression up to the root node. Addins can use this name or construct their own.</param>
      <param name="FullName">[In] The full name of the expression up to the root node. Addins can use this full name or construct their own. However, if the addin uses a different full name, it must be parsed by the expression evaluator.</param>
      <param name="Flags">[In] Flags the expression evaluator passes to the visualizer addin describing the value in question. For instance, this will include whether the object is a pointer or whether it is a reference.</param>
      <param name="ArrayLength">[In] If this is an array and the expression evaluator was able to determine the length of that array, this will be non-zero. Note that there are cases where the expression evaluator will not be able to provide this data.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmRootVisualizedExpression instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.Flags">
      <summary>Flags the expression evaluator passes to the visualizer addin describing the value in question. For instance, this will include whether the object is a pointer or whether it is a reference.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.FullName">
      <summary>The full name of the expression up to the root node. Addins can use this full name or construct their own. However, if the addin uses a different full name, it must be parsed by the expression evaluator.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.Module">
      <summary>The module that contains the type symbol.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpression.Name">
      <summary>The name of the expression up to the root node. Addins can use this name or construct their own.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags">
      <summary>Flags the expression evaluator passes to the visualizer addin describing the value in question. For instance, this will include if the object is a pointer or if it is a reference.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags.None">
      <summary>No flags set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags.IsPointer">
      <summary>The expression being evaluated is a pointer. If expression evaluator correctly formats the address in the pointer in the value, and then dereferences the pointer for child enumeration. An addin may decide to match this behavior.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags.IsReference">
      <summary>The expression being evaluated is a reference. If expression evaluator correctly dereferences the pointer for child enumeration and does not display the address in the value column. An addin may decide to match this behavior.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmRootVisualizedExpressionFlags.IsArray">
      <summary>The expression being evaluated is an array. If the parser was able to determine a length for this array, it will be in the ArrayLength property.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult">
      <summary>The formatted result of a successful evaluation, ready to be displayed in an expression evaluation window.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Access">
      <summary>The access control level (public, private, etc.) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Address">
      <summary>[Optional] If the result is an address (that is the address flag is set in Flags), specifies the location of the backing value. This is used when the evaluation result is used as the input to the memory window or disassembly window. If it is an instruction address then it must have the CPUInstruction address set.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Category">
      <summary>The category (ex: Data, Method, etc.) of this evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Create(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,System.String,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmDataAddress,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.DkmModuleInstance},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmSuccessEvaluationResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InspectionContext">[In] Inspection context used to create this evaluation result.</param>
      <param name="StackFrame">[In] The stack frame this expression result was created on.</param>
      <param name="Name">[In] The name of the expression this result applies to.</param>
      <param name="FullName">[In,Optional] The full name of the expression this result applies to. This value is used to allow for child elements to be added to the watch window (Add Watch from the context menu), and to refresh parts of the evaluation tree. As an example of how FullName differs from name, the name of the 0th element of an array in C++ is '[0]' whereas the full name would by 'myArrayVariable[0]'.</param>
      <param name="Flags">[In] Flags which indicate attributes of an expression evaluation result.</param>
      <param name="Value">[In,Optional] String that describes the value.</param>
      <param name="EditableValue">[In,Optional] If the value is writable, specifies the default string that will be used when you double-click on the value to modify it. The EE should be able to parse and evaluate this string and obtain the current evaluation result. If the value is read-only, the editable value is ignored and should be null.</param>
      <param name="Type">[In,Optional] A string that describes the type of the value.</param>
      <param name="Category">[In] The category (ex: Data, Method, etc) of this evaluation result.</param>
      <param name="Access">[In] The access control level (public, private, etc) of the evaluation result.</param>
      <param name="StorageType">[In] The storage type (ex: static) of the evaluation result.</param>
      <param name="TypeModifierFlags">[In] Type modifier flags (ex: const) of the evaluation result.</param>
      <param name="Address">[In,Optional] If the result is an address (that is the address flag is set in Flags), specifies the location of the backing value. This is used when the evaluation result is used as the input to the memory window or disassembly window. If it is an instruction address then it must have the CPUInstruction address set.</param>
      <param name="CustomUIVisualizers">[In,Optional] A list of custom viewers for this object.</param>
      <param name="ExternalModules">[In,Optional] If available, a list of external modules, excluding the current module, that are used for the inspection of the object. Loading symbols for as many modules in this list as possible will enhance the display of the object.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmSuccessEvaluationResult instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.CustomUIVisualizers">
      <summary>[Optional] A list of custom viewers for this object.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.EditableValue">
      <summary>[Optional] If the value is writable, specifies the default string that will be used when you double-click on the value to modify it. The EE should be able to parse and evaluate this string and obtain the current evaluation result. If the value is read-only, the editable value is ignored and should be null.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.ExternalModules">
      <summary>[Optional] If available, a list of external modules, excluding the current module, that are used for the inspection of the object. Loading symbols for as many modules in this list as possible will enhance the display of the object.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Flags">
      <summary>Flags which indicate attributes of an expression evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.StorageType">
      <summary>The storage type (ex: static) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Type">
      <summary>[Optional] A string that describes the type of the value.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.TypeModifierFlags">
      <summary>Type modifier flags (ex: const) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult.Value">
      <summary>[Optional] String that describes the value.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags">
      <summary>Flags that indicate what information is requested for a variable.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.Types">
      <summary>Provide information about the types of variables.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.TypeAliases">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.Names">
      <summary>Provide information about the names of variables.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.FullNames">
      <summary>Provide full names of the variables.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVariableInfoFlags.Values">
      <summary>Provide information about the values of variables. This flag is set for GetFrameName() when the user has toggled the option "Show Parameter Values". This flag is never set for calls to GetMethodName().</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVendorId">
      <summary>TODO.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVendorId.Microsoft">
      <summary>TODO.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression">
      <summary>Dispatcher object that is used for custom visualization through a concord EE addin. Derived classes: DkmChildVisualizedExpression, DkmRootVisualizedExpression</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.Close">
      <summary>Closes a DkmVisualizedExpression object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmVisualizedExpression objects are automatically closed when their associated DkmInspectionSession object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.CreateDefaultChildFullName(System.Int32)">
      <summary>This method will construct a default full name for a custom visualized child expression. This name will be the root expression's full name and an expand format string that will cause the expression evaluator to callback to the visualizer to obtain children. The DkmVisualizedExpression instance that this is called on should be the parent visualized expression for a child and the root visualized expression for a root.</summary>
      <returns>[Out] The returned full name string.</returns>
      <param name="Index">[In] The index of child for which this full name is created. Ignored for a root item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.EvaluateExpressionCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguageExpression,Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>This method allows a visualizer addin use the expression evaluator to compile and evaluate the default value for an expression. The addin can use this result as-is or override fields by creating a new result. The addin can also decide to use the expression evaluator for expansion using the get children callbacks.</summary>
      <param name="InspectionContext">[In] The inspection context to use for this evaluation.</param>
      <param name="Expression">[In] The expression the visualizer addin wants the expression evaluator to evaluate.</param>
      <param name="StackFrame">[In] Stack frame to evaluate the expression in.</param>
      <param name="ResultObject">[Out] Object that contains the result of the evaluation.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_PROCESS_DESTROYED indicates that the process exited while it tries to evaluate.</exception>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.EvaluateVisualizedExpression(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>Evaluate a visualized expression returning a DkmEvaluationResult for it. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="ResultObject">[Out] Object that contains the result of the evaluation. This object must be closed by the caller when the caller has finished with the object. The expression evaluator reserves the right to override this instance so do not rely on storing data items in the DkmEvaluationResult instance. Use the DkmVisualizedExpression instance as a data container instead.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetChildren(System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression[]@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext@)">
      <summary>Gets an enumeration context used to obtain the children of this evaluation result. This is used in all expression evaluation windows. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="InitialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be at first returned. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="InspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="InitialChildren">[Out] The initial children to return.</param>
      <param name="EnumContext">[Out] Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetChildrenCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[]@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext@)">
      <summary>This method allows a visualizer addin use the expression evaluator for expansion. The evaluation result contained in the visualized expression must have come from the expression evaluator via EvaluateExpressionCallback.</summary>
      <param name="DefaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can only control the expansion of evaluations it understands.</param>
      <param name="InitialRequestSize">[In] The initial number of children that the caller wants returned. This value can be zero if no children will be at first returned. This value may be larger than the number of children that this expression has, in which case all children should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="InspectionContext">[In] The inspection context to use for computing the children. This may differ from the original inspection context with regard to settings, such as radix, evaluation flags, or time-out.</param>
      <param name="InitialChildren">[Out] The initial children to return. Each child must be closed by the caller when the caller has finished.</param>
      <param name="EnumContext">[Out] Context object that is used to enumerate the children. This object must be closed by the caller of this API when enumeration is completed.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetItems(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmChildVisualizedExpression[]@)">
      <summary>Called to obtain items from an instance of DkmEvaluationResultEnumContext created by an earlier call to GetChildren. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="EnumContext">[In] The enum context to use for this call. This instance will have been returned from a previous call to DkmVisualizedExpression.</param>
      <param name="StartIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="Count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="Items">[Out] The DkmChildVisualizedExpression items to return.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetItemsCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultEnumContext,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult[]@)">
      <summary>This method allows a visualizer addin use the expression evaluator for expansion using the passed enumeration context. This is used to obtain local variables of a stack frame or child members from an evaluation result.</summary>
      <param name="EnumContext">[In] Context object that is used to enumerate the children.</param>
      <param name="StartIndex">[In] The zero-based index of the first item to obtain.</param>
      <param name="Count">[In] The number of items to try to return. This value may be larger than the total number of remaining items, in which case all remaining items should be returned. Very large or negative values should not be used as arrays can have very large sizes which would cause out-of-memory if all elements were requested.</param>
      <param name="Items">[Out] The DkmEvaluationResult items to return. Each item must be closed by the caller when the caller has finished.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetSymbolInterface(System.Guid,System.Object@)">
      <summary>Allows custom expression evaluator addins to obtain the symbol interface for the type being visualized. This is not stored in the DkmVisualizedExpression to enable addins that live on the remote computer and do not depend on symbols. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="TypeSymbolInterfaceId">[In] The GUID of the TypeSymbolInterface interface requested from the caller. For the Microsoft native C++ expression evaluator, this should be IID_IDiaSymbol.</param>
      <param name="TypeSymbolInterface">[Out] The symbol interface of the type that was used to evaluate the expression.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetUnderlyingString">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window (click the magnifying glass icon). Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.GetUnderlyingStringCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult)">
      <summary>This method is used for evaluation results that include DkmEvaluationResultFlags.RawString to obtain the underlying string, without enclosing quotation marks or escape sequences. This is method is invoked to display one of the various string visualizers in an expression evaluation window (click the magnifying glass icon).</summary>
      <returns>[Out,Optional] The underlying string value.</returns>
      <param name="DefaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can only control evaluations it understands.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.InspectionContext">
      <summary>Options and target context to use when it performs the inspection operation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionContext" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.InspectionSession">
      <summary>The InspectionSession allows the various components which examine data in the target process to store private data with the same lifetime. Inspection sessions are closed when the user attempts to continue the process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.RuntimeInstance">
      <summary>Indicates which runtime monitor will be used to perform this evaluation.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.SetValueAsString(System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Value">[In] Textual representation of value to assign to the evaluation result.</param>
      <param name="Timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="ErrorText">[Out,Optional] If the operation failed, this indicates the reason why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.SetValueAsStringCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult,System.String,System.Int32,System.String@)">
      <summary>Modifies the value of the given evaluation result (assumed to be non-read-only) to match the given string. This is used after the user edits a value in any of the evaluation windows.</summary>
      <param name="DefaultEvaluationResult">[In] The evaluation result returned from the expression evaluator for this expression. The expression evaluator can only control evaluations it understands.</param>
      <param name="Value">[In] Textual representation of value to assign to the evaluation result.</param>
      <param name="Timeout">[In] If a function evaluation is needed to assign the value, specifies the time-out to use.</param>
      <param name="ErrorText">[Out,Optional] If the operation failed, this indicates the reason why. This value should be null if the operation succeeded. In native code, an S_OK return value is used when it returns error text.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.SourceId">
      <summary>Guid which ties together the expression evaluator that created this object and the object itself. Generally used by expression evaluators to filter their implementation of IDkmCustomVisualizerCallback to only DkmVisualizedExpression they created.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.StackFrame">
      <summary>Stack frame the expression is being evaluated in expression in.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.TagValue">
      <summary>DkmVisualizedExpression is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.UniqueId">
      <summary>Guid which uniquely identifies this instance.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.UseDefaultEvaluationBehavior(System.Boolean@,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResult@)">
      <summary>Called by the expression evaluator when a visualized expression's children are being expanded, the value is being set, or the underlying string is being obtained. If the visualizer addin wants complete control of the expression it should return false. It will then receive calls to GetChildren, GetItems, SetValueAsString, and GetUnderlyingString. If the visualizer addin wants to defer these operations to the expression evaluator, it should return true. It must also give the expression evaluator back the instance of DkmEvaluationResult that came from the EE via one of the IDkmCustomVisualizerCallback methods. Note that the addin MUST have obtained the default DkmEvaluationResult from the EE if it wants the EE to control the object. Returning true from this method is primarily used by visualizer addins that just adjust something small such as the view of a value but do not want to modify expansion or setting values. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="UseDefaultEvaluationBehavior">[Out] Return true to use default expansion, false otherwise.</param>
      <param name="DefaultEvaluationResult">[Out,Optional] The instance of DkmEvaluationResult returned from a call to one of the methods of IDkmCustomVisualizerCallback. The expression evaluator can only control DkmEvaluationResults it understands.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.ValueHome">
      <summary>Base class for all expression value homes.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmExpressionValueHome" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.VisualizerId">
      <summary>Guid which ties together the addin and the expressions that call that addin. The addin should use the Guid provided in the native visualizer file as a filter.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.Tag">
      <summary>DkmVisualizedExpression is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.Tag.RootVisualizedExpression">
      <summary>Object is an instance of 'DkmRootVisualizedExpression'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.DkmVisualizedExpression.Tag.ChildVisualizedExpression">
      <summary>Object is an instance of 'DkmChildVisualizedExpression'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult">
      <summary>The results for a set of threads that match a specific context.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult.Create(System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmThreadEvaluationResultCollection})">
      <summary>Creates a new DkmContextGroupEvaluationILResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="EvaluationResults">[In] Result of the evaluation on this set of threads.</param>
      <param name="ResultData">[In] An array of result data structures that indicate the source instruction and the data buffer for all threads.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult.EvaluationResults">
      <summary>Result of the evaluation on this set of threads.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult.ResultData">
      <summary>An array of result data structures that indicate the source instruction and the data buffer for all threads.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult">
      <summary>The results for a set of threads that match a specific context. Derived classes: DkmFailedContextGroupEvaluationResult, DkmSuccessContextGroupEvaluationResult</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Close">
      <summary>Closes the compute thread evaluation result object to release the resources associated with it. This method must be invoked by the component which initiated the enumeration (ex: called DkmInspectionContext.EvaluateExpression, DkmEvaluationResultEnumContext.GetItems, etc). DkmContextGroupEvaluationResult objects are automatically closed when their associated DkmRuntimeInstance object is closed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.EvaluationResults">
      <summary>Result of the evaluation on this set of threads.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.FullName">
      <summary>[Optional] The full name of the expression this result applies to. This value is used to enable child elements to be added to the watch window (Add Watch from the context menu), and to refresh parts of the evaluation tree. As an example of how FullName differs from name, the name of the 0th element of an array in C++ is '[0]' whereas the full name would by 'myArrayVariable[0]'.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Name">
      <summary>The name of the expression this result applies to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.TagValue">
      <summary>DkmContextGroupEvaluationResult is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.ThreadIds">
      <summary>The thread IDs for the evaluation results.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.UniqueId">
      <summary>Guid which uniquely identifies this evaluation result.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Tag">
      <summary>DkmContextGroupEvaluationResult is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Tag.SuccessContextGroupEvalResult">
      <summary>Object is an instance of 'DkmSuccessContextGroupEvaluationResult'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult.Tag.FailedContextGroupEvalResult">
      <summary>Object is an instance of 'DkmFailedContextGroupEvaluationResult'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult">
      <summary>Result of an asynchronous DkmInspectionContext.EvaluateExpressionOnThreads call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationResult})">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInspectionContext.EvaluateExpressionOnThreads.</summary>
      <param name="Results">[In] Object that contains the results of the evaluation. This object must be closed by the caller when the caller has finished with the object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInspectionContext.EvaluateExpressionOnThreads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_PROCESS_DESTROYED indicates that the process exited while it tries to evaluate.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmEvaluateExpressionOnThreadsAsyncResult.Results">
      <summary>Object that contains the results of the evaluation. This object must be closed by the caller when the caller has finished with the object.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult">
      <summary>Result of an asynchronous DkmCompiledILInspectionQuery.ExecuteQueryOnThreads call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmCompiledILInspectionQuery.ExecuteQueryOnThreads.</summary>
      <param name="Result">[In] Results of the evaluations.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmCompiledILInspectionQuery.ExecuteQueryOnThreads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult.Result">
      <summary>Results of the evaluations.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmContextGroupEvaluationILResult" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmFailedContextGroupEvaluationResult">
      <summary>The formatted result of a failed evaluation, ready to be displayed in an expression evaluation window.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmFailedContextGroupEvaluationResult.Create(System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},System.Int32,System.String,System.String,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.String,System.Boolean,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmFailedContextGroupEvaluationResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ThreadIds">[In] The thread IDs for the evaluation results.</param>
      <param name="EvaluationResults">[In] Result of the evaluation on this set of threads.</param>
      <param name="Name">[In] The name of the expression this result applies to.</param>
      <param name="FullName">[In,Optional] The full name of the expression this result applies to. This value is used to allow for child elements to be added to the Watch window (Add Watch from the context menu) and to refresh parts of the evaluation tree. As an example of how <paramref name="FullName" /> differs from <paramref name="name" />, the name of the 0th element of an array in C++ is '[0]' whereas the full name would be 'myArrayVariable[0]'.</param>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="ErrorMessage">[In] Specifies the error message to display to the user.</param>
      <param name="HasSideEffects">[In] Specifies that the evaluation failed because it would cause side effects and side effects are not allowed.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmFailedContextGroupEvaluationResult instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmFailedContextGroupEvaluationResult.ErrorMessage">
      <summary>Specifies the error message to display to the user.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmFailedContextGroupEvaluationResult.HasSideEffects">
      <summary>Specifies that the evaluation failed because it would cause side effects and side effects are not allowed.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection">
      <summary>A collection of parameters that should be used together.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection.Create(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue})">
      <summary>Creates a new DkmILParameterValueCollection object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Parameters">[In,Optional] The parameter collection.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection.Parameters">
      <summary>[Optional] The parameter collection.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult">
      <summary>The formatted result of a successful evaluation, ready to be displayed in an expression evaluation window.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Access">
      <summary>The access control level (public, private, etc) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Category">
      <summary>The category (ex: Data, Method, etc) of this evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Create(System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},System.Int32,System.String,System.String,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags,System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultCategory,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultAccessType,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType,Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmCustomUIVisualizerInfo},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmSuccessContextGroupEvaluationResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ThreadIds">[In] The thread IDs for the evaluation results.</param>
      <param name="EvaluationResults">[In] Result of the evaluation on this set of threads.</param>
      <param name="Name">[In] The name of the expression this result applies to.</param>
      <param name="FullName">[In,Optional] The full name of the expression this result applies to. This value is used to allow child elements to be added to the watch window (Add Watch from the context menu), and to refresh parts of the evaluation tree. As an example of how FullName differs from name, the name of the 0th element of an array in C++ is '[0]' whereas the full name would by 'myArrayVariable[0]'.</param>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="Flags">[In] Flags which indicate attributes of an expression evaluation result.</param>
      <param name="Values">[In] The formatted values for each thread.</param>
      <param name="Type">[In,Optional] A string that describes the type of the value.</param>
      <param name="Category">[In] The category (ex: Data, Method, etc) of this evaluation result.</param>
      <param name="Access">[In] The access control level (public, private, etc) of the evaluation result.</param>
      <param name="StorageType">[In] The storage type (ex: static) of the evaluation result.</param>
      <param name="TypeModifierFlags">[In] Type modifier flags (ex: const) of the evaluation result.</param>
      <param name="CustomUIVisualizers">[In,Optional] A list of custom viewers for this object.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmSuccessContextGroupEvaluationResult instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.CustomUIVisualizers">
      <summary>[Optional] A list of custom viewers for this object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Flags">
      <summary>Flags which indicate attributes of an expression evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.StorageType">
      <summary>The storage type (ex: static) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultStorageType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Type">
      <summary>[Optional] A string that describes the type of the value.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.TypeModifierFlags">
      <summary>Type modifier flags (ex: const) of the evaluation result.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmEvaluationResultTypeModifierFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmSuccessContextGroupEvaluationResult.Values">
      <summary>The formatted values for each thread.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmThreadEvaluationResultCollection">
      <summary>The set of results from a single thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmThreadEvaluationResultCollection.Create(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult},Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason)">
      <summary>Create a new DkmThreadEvaluationResultCollection object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Results">[In] The set of results from processing the query on the given thread.</param>
      <param name="FailureReason">[In] If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmThreadEvaluationResultCollection.FailureReason">
      <summary>If an expected error occurs evaluating the DkmIL, indicates the reason for the failure.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmThreadEvaluationResultCollection.Results">
      <summary>The set of results from processing the query on the given thread.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery">
      <summary>An inspection query compiled to one or more DkmIL instructions.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction})">
      <summary>Create a new DkmCompiledILInspectionQuery object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="Instructions">[In] Body of the query.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery.ExecuteQueryOnThreads(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection},Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmExecuteQueryOnThreadsAsyncResult})">
      <summary>Executes a compiled inspection query and returns any results. This method will append a new work item to the specified work list, and return after the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="ILContext">[In] The stack frame context we are evaluating on.</param>
      <param name="Threads">[In] The compute threads to use when executing the query.</param>
      <param name="Parameters">[In,Optional] Parameters to pass to each thread. The collection should be empty if unused, or have exactly as many members as the Threads parameter.</param>
      <param name="CompletionRoutine">Routine to call when the request is finished. If the request is successfully appended to the work list, this will always be called (including when the operation is canceled). This will never be called if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery.ExecuteQueryOnThreads(Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.Group.DkmILParameterValueCollection})">
      <summary>Executes a compiled inspection query and returns any results.</summary>
      <returns>[Out] Results of the evaluations.</returns>
      <param name="ILContext">[In] The stack frame context we are evaluating on.</param>
      <param name="Threads">[In] The compute threads to use when executing the query.</param>
      <param name="Parameters">[In,Optional] Parameters to pass to each thread. The collection should be empty if unused, or have exactly as many members as the Threads parameter.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmCompiledILInspectionQuery.Instructions">
      <summary>Body of the query.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILAdd">
      <summary>Pops two values off the evaluation stack, adds them, and pushes the sum onto the evaluation stack. Both operands popped off the stack must be the size indicated by DkmPrimitiveObjectType. The resultant value will have the same size as the operands. In the event of overflow, the result will be truncated.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILAdd.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILAdd object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of addition to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILAdd.Type">
      <summary>The type of addition to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILAmpAdjustBufferTag">
      <summary>A request to translate a C++ AMP pointer tag if its buffer has been forwarded. Pops the 32-bit tag off the stack and pushes the new 32-bit tag on the stack. Usually a no-op.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILAmpAdjustBufferTag.Create">
      <summary>Creates a new DkmILAmpAdjustBufferTag object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBeginTry">
      <summary>Begins a try block. If an error occurs in the execution of the try block, control will jump to an appropriate catch block to allow the MSIL to recover from the error. Exception handling in native MSIL works as follows: An exception in native MSIL means that some operation, such as a register read or memory read failed. Each exception is identified by a 32-bit exception code that describes the problem. Exception code values are defined according to the DkmILFailureReason enumeration, and additional user-defined values may also be used to handle exception-conditions that are specific to an intrinsic function (e.g., attempt to take the log of 0).By default, when an exception occurs, the MSIL processing will stop immediately, which causes DkmCompiledInspectionQuery::ExecuteQuery() to fail, returning the exception code as an out parameter. To handle the exception with MSIL, the MSIL should execute a DkmILBeginTry instruction to enter a guarded exception-handling state. The MSIL processing will remain in this state until a DkmILEndTryBlock instruction is executed. A DkmILBeginTryBlock instruction specifies what to do if an exception occurs in the block. The block's exception handling logic is defined by a collection of DkmILCatchBlock objects. Each catch block defines the exception code that the catch block will catch in addition to the offset into the instruction stream where the catch block is located. Thus, when an exception occurs, we will do the following: 1) Check whether we are inside a try block: No: Abort the MSIL operation and cause DkmCompiledInspectionQuery::ExecuteQuery() to fail. Yes: 2) Examine the list of DkmILCatchBlock objects associated with the try block in sequential order, looking for a catch block that catches the exception code. (If more than one catch block works, we use the first match and ignore the other matches). If we find a match: - Clear the state that says we're in a try block (so any exceptions from the catch handler will go unhandled unless a new try block gets set up). - Remove all values from the MSIL stack that was pushed after we entered the try block. Local variables, saved return values, and MSIL stack values that were already pushed before the try block began are retained. (It is unauthorized to pop a value off the stack inside a try block that was pushed outside the try block). - Push the exception code on the stack as a 32-bit value. - Transfer control to the offset of the catch handler and continue the MSIL. If we do not find a match: - The exception is unhandled. Abort the MSIL operation and cause DkmCompiledInspectionQuery::ExecuteQuery() to fail. If during the execution of the inspection query, we detect that the work list has been canceled, we will promptly end the MSIL processing. The MSIL will not have a chance to handle this. In general, exception handling is enabled when an inspection fails or an arithmetic error occurs (e.g., division by zero), however, on error conditions that can only occur through invalid MSIL (e.g., attempt to pop from empty stack), we do not guarantee that exception handling of such errors will be supported. If an exception occurs that we do not support handling, the MSIL processing will stop. Currently, nested try blocks are not supported, that is, an attempt to execute a DkmILBeginTry when already inside a try block is considered an error.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBeginTry.CatchBlocks">
      <summary>Ordered list of catch blocks to handle exceptions occurring in the try block.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBeginTry.Create(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCatchBlock})">
      <summary>Create a new DkmILBeginTry object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="CatchBlocks">[In] Ordered list of catch blocks to handle exceptions occurring in the try block.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitAnd">
      <summary>Pops two integer values off of the evaluation stack. Performs a bitwise and on the two values, and pushes the result onto the stack. The two values popped from the stack must be the same size.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitAnd.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILBitAnd object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitAnd.Type">
      <summary>The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldRead">
      <summary>Reads the value of a bit field from memory. The address of the bit field is popped off the stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldRead.BitPosition">
      <summary>The bit position to read from.  Must be between 0 and 63.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldRead.Create(System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILBitFieldRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="BitPosition">[In] The bit position to read from. Must be between 0 and 63.</param>
      <param name="NumBits">[In] The number of bits to read. Must be between 1 and 64.</param>
      <param name="Type">[In] The type of object to read. Must be an integer and must be at least as large, in bits, as <paramref name="NumBits" />.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldRead.NumBits">
      <summary>Number of bits to read. Must be between 1 and 64.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldRead.Type">
      <summary>The type of object to read. Must be an integer and must be at least as large, in bits, as <paramref name="NumBits" />.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldWrite">
      <summary>Pops a value off the stack. Then, pops a memory address off the stack. Then, modifies the value of the bit field at that memory address, at the given offset and size, to match the value that was just popped off the stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldWrite.BitPosition">
      <summary>The bit position to write to. Must be between 0 and 63.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldWrite.Create(System.UInt32,System.UInt32)">
      <summary>Create a new DkmILBitFieldWrite object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="BitPosition">[In] The bit position to write to. Must be between 0 and 63.</param>
      <param name="NumBits">[In] Number of bits to write. Must be between 1 and 64.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitFieldWrite.NumBits">
      <summary>Number of bits to write. Must be between 1 and 64.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitNot">
      <summary>Pops an integer value off of the evaluation stack. Inverts all the bits and pushes the result onto the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitNot.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILBitNot object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitNot.Type">
      <summary>The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitOr">
      <summary>Pops two integer values off of the evaluation stack. Performs a bitwise OR on the two values and pushes the result onto the stack. The two values popped from the stack must be the same size.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitOr.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILBitOr object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g., 32-bit or 64-bit). Floating-point modes are not allowed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitOr.Type">
      <summary>The type of operands to expect (e.g., 32-bit or 64-bit). Floating-point modes are not allowed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftLeft">
      <summary>Pops two integer values off of the evaluation stack. Shifts the first value left by the second value and pushes the result onto the evaluation stack. The first operand must be the size indicated by DkmPrimitiveObjectType. The second operand must be 32-bit.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftLeft.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILBitShiftLeft object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g., 32-bit or 64-bit). Floating-point modes are not allowed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftLeft.Type">
      <summary>The type of operands to expect (e.g., 32-bit or 64-bit). Floating-point modes are not allowed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftRight">
      <summary>Pops two integer values off of the evaluation stack. Shifts the first value right by the second value and pushes the result onto the evaluation stack. The first operand must be the size indicated by by DkmPrimitiveObjectType. The second operand must be 32-bit.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftRight.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILBitShiftRight object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed. Also, specifies whether the operation is signed or unsigned. An unsigned mode means the upper-bit will be filled with a zero; a signed mode means the upper-bit will be preserved.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitShiftRight.Type">
      <summary>The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed. Also, specifies whether the operation is signed or unsigned. An unsigned mode means the upper-bit will be filled with a zero; a signed mode means the upper-bit will be preserved.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitXor">
      <summary>Pops two integer values off of the evaluation stack. Performs a bitwise exclusive-or on the two values, and pushes the result onto the stack. The two values popped from the stack must be the same size.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitXor.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILBitXor object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILBitXor.Type">
      <summary>The type of operands to expect (e.g. 32-bit or 64-bit). Floating-point modes are not allowed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention">
      <summary>Describes the calling convention for a function evaluation on x86. Ignored for other architectures.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention.StdCall">
      <summary>The x86 stdcall calling convention.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention.CDecl">
      <summary>The x86 cdecl calling convention.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention.ThisCall">
      <summary>The x86 thiscall calling convention.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention.FastCall">
      <summary>The x86 fastcall calling convention.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCatchBlock">
      <summary>An MSIL catch block, which can be used to recover from errors when executing MSIL.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCatchBlock.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason,System.Int32)">
      <summary>Creates a new DkmILCatchBlock object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ErrorCode">[In] The type of error to catch. "None" to catch all errors.</param>
      <param name="Target">[In] The index of the MSIL instruction to jump to when the catch block executes.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCatchBlock.ErrorCode">
      <summary>The type of error to catch. "None" to catch all errors.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCatchBlock.Target">
      <summary>The index of the MSIL instruction to jump to when the catch block executes.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareEqual">
      <summary>Pops two values off of the evaluation stack. If the two values are equal (same size, all the bytes have the same value), pushes a 32-bit 1 onto the stack. Otherwise, pushes a 32-bit 0 onto the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareEqual.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILCompareEqual object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareEqual.Type">
      <summary>The type of comparison to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThan">
      <summary>Pops two values off the evaluation stack and performs a numeric comparison of the values, by using the arithmetic mode specified. If the first operand is greater than the second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThan.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILCompareGreaterThan object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g. integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThan.Type">
      <summary>The type of comparison to perform (e.g. integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThanOrEqual">
      <summary>Pops two values off the evaluation stack and performs a numeric comparison of the values by using the arithmetic mode specified. If the first operand is greater than or equal to the second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThanOrEqual.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILCompareGreaterThanOrEqual object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareGreaterThanOrEqual.Type">
      <summary>The type of comparison to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThan">
      <summary>Pops two values off the evaluation stack and performs a numeric comparison of the values, by using the arithmetic mode specified. If the first operand is less than the second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThan.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILCompareLessThan object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g. integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThan.Type">
      <summary>The type of comparison to perform (e.g. integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThanOrEqual">
      <summary>Pops two values off the evaluation stack and performs a numeric comparison of the values by using the arithmetic mode specified. If the first operand is less than the second operand, pushes a 32-bit value of 1 on the stack; otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThanOrEqual.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILCompareLessThanOrEqual object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareLessThanOrEqual.Type">
      <summary>The type of comparison to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareNotEqual">
      <summary>Pops two values off of the evaluation stack. If the two values are not equal (same size, all the bytes do not have the same value), pushes a 32-bit 1 onto the stack. Otherwise, pushes a 32-bit 0 onto the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareNotEqual.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILCompareNotEqual object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCompareNotEqual.Type">
      <summary>The type of comparison to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILConvert">
      <summary>Pops a value off the evaluation stack and converts it from one type to another.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILConvert.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILConvert object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="OriginalType">[In] The expected type of the object to be popped from the stack. The actual object popped from the stack must have a size that matches this type.</param>
      <param name="TargetType">[In] The type that you want to convert the value to. This is the type of the object that will be pushed onto the stack.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILConvert.OriginalType">
      <summary>The expected type of the object to be popped from the stack. The actual object popped from the stack must have a size that matches this type.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILConvert.TargetType">
      <summary>The type that you want to convert the value to. This is the type of the object that will be pushed onto the stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILDivide">
      <summary>Pops two values off the evaluation stack, divides them, and pushes the result onto the evaluation stack. Both operands popped off the stack must be the size indicated by DkmPrimitiveObjectType. The first value popped from the stack will be divided by the second value popped. Therefore, to evaluate "a / b", you would push a, and then push b, and then divide. The resultant value will have the same size as the operands. In the event of overflow, the result will be truncated.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILDivide.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILDivide object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of subtraction to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILDivide.Type">
      <summary>The type of subtraction to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILDuplicateTop">
      <summary>Make a copy of the value on the top of the DkmIL stack and push this copy on top of the stack. If the result of a DkmDuplicateTop is returned, the GUID associated with the result will be the GUID of the original instruction, not the GUID of the DkmDuplicateTop.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILDuplicateTop.Create">
      <summary>Create a new DkmILDuplicateTop object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEndTry">
      <summary>Ends a try block. After this, all exceptions will go unhandled unless a new DkmILBeginTry instruction is executed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEndTry.Create">
      <summary>Create a new DkmILEndTry object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult">
      <summary>Represents the result of evaluating one DkmILInstruction.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult.Create(System.Guid,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmILEvaluationResult object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceId">[In] UniqueId of the DkmILInstruction object that originally pushed the returned value onto the evaluation stack.</param>
      <param name="ResultBytes">[In] The results of evaluating the DkmILInstruction.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult.ResultBytes">
      <summary>The results of evaluating the DkmILInstruction.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult.SourceId">
      <summary>UniqueId of the DkmILInstruction object that originally pushed the returned value onto the evaluation stack.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction">
      <summary>Pops the address of the function off the eval stack, and then pops the arguments off the MSIL stack in reverse order. (Before the DkmILExecuteFunction instruction, arguments should be pushed on the stack in order.) Next, executes the function in the debuggee process. The return value for the function is copied to the MSIL stack as a byte array.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.ArgumentCount">
      <summary>The number of arguments to pass to the intrinsic function. These arguments are popped off the MSIL stack.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.ArgumentFlags">
      <summary>Flags affecting arguments to a function evaluation. There will be one argument flag for each argument.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.CallingConvention">
      <summary>The calling convention of the function to be executed. Ignored on non-x86 processors that only have a single calling convention.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.Create(System.UInt32,System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILCallingConvention,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags},System.UInt32)">
      <summary>Creates a new DkmILExecuteFunction object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ArgumentCount">[In] The number of arguments to pass to the intrinsic function. These arguments are popped off the MSIL stack.</param>
      <param name="ReturnValueSize">[In] The size of the return value in bytes. This dictates how the return address is found on some architectures. For instance, on x86, a 4 byte or less return value is returned in EAX. An 8 byte return value is returned in EDX:EAX, and for anything larger, a pointer is returned in EAX to an object on the heap, or for by value returns, to an object on the stack after the stack is cleaned up.</param>
      <param name="CallingConvention">[In] The calling convention of the function to be executed. Ignored on non-x86 processors that only have a single calling convention.</param>
      <param name="Flags">[In] Flags affecting how a function evaluation should occur.</param>
      <param name="ArgumentFlags">[In] Flags affecting arguments to a function evaluation. There will be one argument flag for each argument.</param>
      <param name="UniformComplexReturnElementSize">[In] Used for the arm calling convention where a complex type that contains all elements of the same size are returned enregistered. This is only used if the EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags is set. This value should return the size of each element in the complex type. FloatingPointReturn is used to determine whether the return value is in the integer registers of the floating point registers. The MSIL Interpreter will copy these values onto the stack and return a pointer to that location as if they were not enregistered.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.Flags">
      <summary>Flags affecting how a function evaluation should occur.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.ReturnValueSize">
      <summary>The size of the return value in bytes. This dictates how the return address is found on some architectures. For instance, on x86, a 4 byte or less return value is returned in EAX. An 8 byte return value is returned in EDX:EAX, and for anything larger, a pointer is returned in EAX to an object on the heap, or for by-value returns, to an object on the stack after the stack is cleaned up.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteFunction.UniformComplexReturnElementSize">
      <summary>Used for the arm calling convention where a complex type that contains all elements the same size are returned enregistered. This is only used if the EnregisteredComplexReturn flag in DkmILFunctionEvaluationFlags is set. This value should return the size of each element in the complex type. FloatingPointReturn is used to determine whether the return value is in the integer registers of the floating point registers. The MSIL Interpreter will copy these values onto the stack and return a pointer to that location as if they were not enregistered.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic">
      <summary>Pops the arguments off the IL stack in reverse order (before the DkmILExecuteIntrinsic instruction, arguments should be pushed on the stack in order). Then, executes an EE-defined operation that uses these values. Then, pushes the result back onto the IL stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.ArgumentCount">
      <summary>The number of arguments to pass to the intrinsic function. These arguments are popped off the IL stack.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.Create(System.Guid,System.Guid,System.UInt32,System.UInt32,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery})">
      <summary>Create a new DkmILExecuteIntrinsic object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="LanguageId">[In] The language associated with the intrinsic function.</param>
      <param name="Id">[In] A unique identifier for the intrinsic function in the language.</param>
      <param name="ArgumentCount">[In] The number of arguments to pass to the intrinsic function. These arguments are popped off the IL stack.</param>
      <param name="Subroutines">[In,Optional] Optional collection of subroutines that the intrinsic function can call into.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.Execute(Microsoft.VisualStudio.Debugger.Evaluation.DkmILContext,Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult[],System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmCompiledInspectionQuery},Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason@)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILEvaluationResult" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.Id">
      <summary>A unique identifier for the intrinsic function in the language.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.LanguageId">
      <summary>The language associated with the intrinsic function.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExecuteIntrinsic.Subroutines">
      <summary>[Optional] Optional collection of subroutines that the intrinsic function can call into.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExtractBytes">
      <summary>Pops a value off the MSIL stack and extracts a subset of the bytes of that value, pushing the result back onto the MSIL stack. If the complete region of bytes to extract does not fall in the bounds of the value popped from the stack, an MSIL exception of code ByteExtractionOutOfBounds will be thrown.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExtractBytes.Create(System.Int32,System.Int32)">
      <summary>Creates a new DkmILExtractBytes object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Offset">[In] The offset of the first byte to extract.</param>
      <param name="Length">[In] The number of bytes to extract.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExtractBytes.Length">
      <summary>The number of bytes to extract.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILExtractBytes.Offset">
      <summary>The offset of the first byte to extract.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason">
      <summary>Indicates a reason why an IL instruction did not execute. In addition to these constants, negative values may be used to indicate customized error conditions resulting from the execution of intrinsic functions.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.None">
      <summary>The IL was evaluated successfully.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.DivideByZero">
      <summary>An attempt was made to divide an integer by zero.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.MemoryReadError">
      <summary>An attempt to read from the debuggee's memory failed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.MemoryWriteError">
      <summary>An attempt to write to the debuggee's memory failed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.RegisterReadError">
      <summary>An attempt to read the value of a register from the debuggee failed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.RegisterWriteError">
      <summary>An attempt to write to the value of a register from the debuggee failed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.Aborted">
      <summary>Execution was ended because the user canceled the evaluation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.StringTooLong">
      <summary>An attempt was made to read a string which was larger than the maximum length.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.Timeout">
      <summary>Execution was ended because the evaluation time-out was exceeded.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.TooManyFuncEval">
      <summary>A function evaluation is already in progress. Multiple function evaluations are not supported.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.AbortFailed">
      <summary>An attempt to end the evaluation failed. The process is now in an indeterminate state.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.MinidumpNotSupported">
      <summary>This operation is not supported when you debug a minidump.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.AbortUnhandledException">
      <summary>The evaluation was aborted because an unhandled exception occurred in the process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.UserModeScheduledNotSupported">
      <summary>This operation is not supported on a user-mode scheduled thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason.ByteExtractionOutOfBounds">
      <summary>A DkmILExtractBytes instruction failed because the range of bytes to extract falls outside the bounds of the value.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags">
      <summary>Flags affecting how arguments to a function evaluation are treated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags.Default">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags.FloatingPoint">
      <summary>Set if this argument is a floating point value. This can affect how the value is passed to the function.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags.Scalar">
      <summary>Set if this argument is a scalar type. On some architectures, this will affect how the parameter is passed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags.CopyToDebuggee">
      <summary>Set if the argument must be copied into the debuggee address space and then passed by reference. Used to support string literals in argument parameters.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationArgumentFlags.ThisPointer">
      <summary>Set if this argument is the this pointer for a call.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags">
      <summary>Flags affecting how a function evaluation should occur.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.Default">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.FloatingPointReturn">
      <summary>Set if this function returns a floating point value that changes how the return value is found.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.ScalarReturn">
      <summary>Set if this function returns a scalar type. On some architectures this changes how the value is returned.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.ReturnAddressOfValue">
      <summary>Set if the caller needs by-value return values returned as a reference on the stack. The interpreter will make a copy of the return value on the debuggee stack and return a pointer to that value. The value will only be valid in the debuggee address space until the next continue or next function evaluation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.NoEnregisteredReturn">
      <summary>Set if the return value will not be enregistered by the called function regardless of return value size. This is used by the C++ expression evaluator when a class or struct has a copy constructor defined and an instance of that class is being returned by-value. The address of the return value on the stack will be returned from the function evaluation. The value will only be valid in the debuggee address space until the next continue or next function evaluation.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.HasThisPointer">
      <summary>Set if the function being called has a this pointer. The this pointer is the first argument in the in the argument collection.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFunctionEvaluationFlags.EnregisteredComplexReturn">
      <summary>Set if the return value for the function will be an enregistered complex return type. This is used for the calling convention on arm where a composite type consists of several elements of the same type is returned in registers. The size of each element must be passed to the function evaluation instruction. FloatingPointReturn is used to determine whether the return value is in the integer registers of the floating point registers.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslBufferRead">
      <summary>A request to read data from a shader shared buffer. The offset in the buffer is popped from the Microsoft intermediate language (MSIL) stack. The result is pushed on the MSIL stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslBufferRead.BytesToRead">
      <summary>The number of bytes to read from the shared buffer.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslBufferRead.Create(System.Int32,System.UInt32,System.UInt32)">
      <summary>Create a new DkmILHlslBufferRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RegisterId">[In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.</param>
      <param name="RegisterIndex">[In] The index of the register to read.</param>
      <param name="BytesToRead">[In] The number of bytes to read from the shared buffer.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslBufferRead.RegisterId">
      <summary>The VSD3D_REGISTER_SET value cast to a CvRegisterId.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslBufferRead.RegisterIndex">
      <summary>The index of the register to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetGroupId">
      <summary>A request to 'read' the current group ID. The result is pushed on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetGroupId.Create(Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents)">
      <summary>Create a new DkmILHlslGetGroupId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="GroupIdComponents">[In] Specifies what part of the thread group ID should be pushed on the stack.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetGroupId.GroupIdComponents">
      <summary>Specifies what part of the thread group ID should be pushed on the stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetThreadId">
      <summary>A request to 'read' the current thread ID. The result is pushed on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetThreadId.Create(System.Boolean,System.Boolean,Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents)">
      <summary>Create a new DkmILHlslGetThreadId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="UseDispatchId">[In] Indicates whether the thread ID should be returned relative to the dispatch (true) or relative to the tile (false).</param>
      <param name="UseFlatModel">[In] Instructs the debugger to fetch the thread id in flat format (if true), or as a vector (if false).</param>
      <param name="ThreadIdComponents">[In] Specifies what part of the thread ID should be pushed on the stack.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetThreadId.ThreadIdComponents">
      <summary>Specifies what part of the thread ID should be pushed on the stack.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetThreadId.UseDispatchId">
      <summary>Indicates whether the thread ID should be returned relative to the dispatch (true) or relative to the tile (false).</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslGetThreadId.UseFlatModel">
      <summary>Instructs the debugger to fetch the thread id in flat format (if true), or as a vector (if false).</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead">
      <summary>A request to read the value of a specific register. The index of the first vector element to read is popped from the IL stack. The result is pushed on the IL stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.ByteOffset">
      <summary>The offset in bytes from the start of the register to begin reading.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.BytesToRead">
      <summary>The number of bytes to be read from each vector register.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.Create(System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Create a new DkmILHlslIndexedRegisterRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RegisterId">[In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.</param>
      <param name="RegisterIndex">[In] The index of the register to read.</param>
      <param name="ByteOffset">[In] The offset in bytes from the start of the register to begin reading.</param>
      <param name="BytesToRead">[In] The number of bytes to be read from each vector register.</param>
      <param name="VectorElements">[In] The number of vector elements to read.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.RegisterId">
      <summary>The VSD3D_REGISTER_SET value cast to a CvRegisterId.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.RegisterIndex">
      <summary>The index of the register to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslIndexedRegisterRead.VectorElements">
      <summary>The number of vector elements to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead">
      <summary>A request to read the value of a specific register. The result is pushed on the IL stack.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.ByteOffset">
      <summary>The offset in bytes from the start of the register to begin reading.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.BytesToRead">
      <summary>The number of bytes to be read from each vector register.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.Create(System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Create a new DkmILHlslRegisterRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RegisterId">[In] The VSD3D_REGISTER_SET value cast to a CvRegisterId.</param>
      <param name="RegisterIndex">[In] The index of the register to read.</param>
      <param name="ByteOffset">[In] The offset in bytes from the start of the register to begin reading.</param>
      <param name="BytesToRead">[In] The number of bytes to be read from each vector register.</param>
      <param name="FirstElement">[In] The index of the first vector element.</param>
      <param name="VectorElements">[In] The number of vector elements to read.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.FirstElement">
      <summary>The index of the first vector element.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.RegisterId">
      <summary>The VSD3D_REGISTER_SET value cast to a CvRegisterId.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.RegisterIndex">
      <summary>The index of the register to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILHlslRegisterRead.VectorElements">
      <summary>The number of vector elements to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction">
      <summary>Abstract base class for the concrete debugger immediate language instructions used by expression evaluators to batch query information about the debuggee. Derived classes: DkmILAdd, DkmILAmpAdjustBufferTag, DkmILBeginTry, DkmILBitAnd, DkmILBitFieldRead, DkmILBitFieldWrite, DkmILBitNot, DkmILBitOr, DkmILBitShiftLeft, DkmILBitShiftRight, DkmILBitXor, DkmILCompareEqual, DkmILCompareGreaterThan, DkmILCompareGreaterThanOrEqual, DkmILCompareLessThan, DkmILCompareLessThanOrEqual, DkmILCompareNotEqual, DkmILConvert, DkmILDivide, DkmILDuplicateTop, DkmILEndTry, DkmILExecuteFunction, DkmILExecuteIntrinsic, DkmILExtractBytes, DkmILHlslBufferRead, DkmILHlslGetGroupId, DkmILHlslGetThreadId, DkmILHlslIndexedRegisterRead, DkmILHlslRegisterRead, DkmILIsFalse, DkmILIsTrue, DkmILJump, DkmILJumpIfFalse, DkmILJumpIfTrue, DkmILLoad, DkmILMemoryRead, DkmILMemoryStringRead, DkmILMemoryWrite, DkmILMultiply, DkmILNop, DkmILPop, DkmILPushConstant, DkmILRegisterRead, DkmILRegisterWrite, DkmILRemainder, DkmILReturnTop, DkmILSave, DkmILSubtract, DkmILThrow, DkmILTlsGetValue</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.TagValue">
      <summary>DkmILInstruction is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.UniqueId">
      <summary>Uniquely identifies the DkmILInstruction object. Used as a hash-table key to allow for quickly matching up DkmIL instructions with their matching values.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag">
      <summary>DkmILInstruction is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.RegisterRead">
      <summary>Object is an instance of 'DkmILRegisterRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.RegisterWrite">
      <summary>Object is an instance of 'DkmILRegisterWrite'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.MemoryRead">
      <summary>Object is an instance of 'DkmILMemoryRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.MemoryWrite">
      <summary>Object is an instance of 'DkmILMemoryWrite'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.MemoryStringRead">
      <summary>Object is an instance of 'DkmILMemoryStringRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.TlsGetValue">
      <summary>Object is an instance of 'DkmILTlsGetValue'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitFieldRead">
      <summary>Object is an instance of 'DkmILBitFieldRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitFieldWrite">
      <summary>Object is an instance of 'DkmILBitFieldWrite'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.PushConstant">
      <summary>Object is an instance of 'DkmILPushConstant'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.DuplicateTop">
      <summary>Object is an instance of 'DkmILDuplicateTop'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Pop">
      <summary>Object is an instance of 'DkmILPop'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Save">
      <summary>Object is an instance of 'DkmILSave'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Load">
      <summary>Object is an instance of 'DkmILLoad'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Nop">
      <summary>Object is an instance of 'DkmILNop'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Add">
      <summary>Object is an instance of 'DkmILAdd'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Subtract">
      <summary>Object is an instance of 'DkmILSubtract'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Multiply">
      <summary>Object is an instance of 'DkmILMultiply'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Divide">
      <summary>Object is an instance of 'DkmILDivide'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Remainder">
      <summary>Object is an instance of 'DkmILRemainder'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.ExtractBytes">
      <summary>Object is an instance of 'DkmILExtractBytes'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitAnd">
      <summary>Object is an instance of 'DkmILBitAnd'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitOr">
      <summary>Object is an instance of 'DkmILBitOr'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitXor">
      <summary>Object is an instance of 'DkmILBitXor'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitShiftLeft">
      <summary>Object is an instance of 'DkmILBitShiftLeft'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitShiftRight">
      <summary>Object is an instance of 'DkmILBitShiftRight'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BitNot">
      <summary>Object is an instance of 'DkmILBitNot'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.IsTrue">
      <summary>Object is an instance of 'DkmILIsTrue'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.IsFalse">
      <summary>Object is an instance of 'DkmILIsFalse'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareEqual">
      <summary>Object is an instance of 'DkmILCompareEqual'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareNotEqual">
      <summary>Object is an instance of 'DkmILCompareNotEqual'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareGreaterThan">
      <summary>Object is an instance of 'DkmILCompareGreaterThan'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareGreaterThanOrEqual">
      <summary>Object is an instance of 'DkmILCompareGreaterThanOrEqual'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareLessThan">
      <summary>Object is an instance of 'DkmILCompareLessThan'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.CompareLessThanOrEqual">
      <summary>Object is an instance of 'DkmILCompareLessThanOrEqual'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Convert">
      <summary>Object is an instance of 'DkmILConvert'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.ReturnTop">
      <summary>Object is an instance of 'DkmILReturnTop'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Throw">
      <summary>Object is an instance of 'DkmILThrow'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.Jump">
      <summary>Object is an instance of 'DkmILJump'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.JumpIfTrue">
      <summary>Object is an instance of 'DkmILJumpIfTrue'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.JumpIfFalse">
      <summary>Object is an instance of 'DkmILJumpIfFalse'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.ExecuteIntrinsic">
      <summary>Object is an instance of 'DkmILExecuteIntrinsic'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.BeginTry">
      <summary>Object is an instance of 'DkmILBeginTry'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.EndTry">
      <summary>Object is an instance of 'DkmILEndTry'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.ExecuteFunction">
      <summary>Object is an instance of 'DkmILExecuteFunction'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.HlslRegisterRead">
      <summary>Object is an instance of 'DkmILHlslRegisterRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.HlslIndexedRegisterRead">
      <summary>Object is an instance of 'DkmILHlslIndexedRegisterRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.HlslBufferRead">
      <summary>Object is an instance of 'DkmILHlslBufferRead'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.HlslGetThreadId">
      <summary>Object is an instance of 'DkmILHlslGetThreadId'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.HlslGetGroupId">
      <summary>Object is an instance of 'DkmILHlslGetGroupId'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILInstruction.Tag.AmpAdjustBufferTag">
      <summary>Object is an instance of 'DkmILAmpAdjustBufferTag'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsFalse">
      <summary>Pops a value off of the evaluation stack. If the value is zero, pushes a 32-bit value of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsFalse.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILIsFalse object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g. integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsFalse.Type">
      <summary>The type of comparison to perform (e.g. integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsTrue">
      <summary>Pops a value off of the evaluation stack. If the value is non-zero, pushes a 32-bit value of 1 on the stack. Otherwise, pushes a 32-bit value of 0 on the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsTrue.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILIsTrue object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of comparison to perform (e.g. integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILIsTrue.Type">
      <summary>The type of comparison to perform (e.g. integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJump">
      <summary>Jumps to another instruction in the instruction stream.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJump.Create(System.UInt32)">
      <summary>Create a new DkmILJump object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Target">[In] Location in the instruction stream to jump to.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJump.Target">
      <summary>Location in the instruction stream to jump to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfFalse">
      <summary>Pops a value off the IL stack. Then, jumps to another instruction in the instruction stream only if the value bytes are all zero.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfFalse.Create(System.UInt32)">
      <summary>Create a new DkmILJumpIfFalse object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Target">[In] Location in the instruction stream to jump to.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfFalse.Target">
      <summary>Location in the instruction stream to jump to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfTrue">
      <summary>Pops a value off the IL stack. Then, jumps to another instruction in the instruction stream only if the value bytes are not all zero.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfTrue.Create(System.UInt32)">
      <summary>Create a new DkmILJumpIfTrue object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Target">[In] Location in the instruction stream to jump to.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILJumpIfTrue.Target">
      <summary>Location in the instruction stream to jump to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILLoad">
      <summary>Loads a value from an index previously saved from a DkmSave instruction and pushes the value to the top of the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILLoad.Create(System.UInt32)">
      <summary>Create a new DkmILLoad object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Index">[In] The index at which to save the value.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILLoad.Index">
      <summary>The index at which to save the value.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryRead">
      <summary>A request to read a sequence of bytes from memory. The address to read from is popped off the DkmIL stack and must have a size of 4 if the debuggee is 32-bit, or 8 if the debuggee is 64-bit. The bytes that are read from memory are pushed onto the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryRead.Create(System.UInt32,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags)">
      <summary>Create a new DkmILMemoryRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Size">[In] Number of bytes to read.</param>
      <param name="Flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryRead.Flags">
      <summary>Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryRead.Size">
      <summary>Number of bytes to read.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryStringRead">
      <summary>A request to read a null-terminated string from the target process. The address to read from is popped off the DkmIL stack and must have a size of 4 if the debuggee is 32-bit, or 8 if the debuggee is 64-bit. The bytes that are read from memory are pushed onto the stack. This will include the null-terminator if this value is read. The null-terminator will be missing when DkmReadMemoryFlags.AllowPartialRead is true, and either the MaxCharacters is hit, or unreadable memory is hit before the null terminator.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryStringRead.CharacterSize">
      <summary>Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).</summary>
      <returns>Returns <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryStringRead.Create(Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.UInt16,System.Int32)">
      <summary>Create a new DkmILMemoryStringRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Flags">[In] Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</param>
      <param name="CharacterSize">[In] Number of bytes in each character. This should be set to 1 (ANSI/UTF-8), 2 (UTF-16) or 4 (UTF-32).</param>
      <param name="MaxCharacters">[In] The maximum number of characters to read from the target process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null terminator is not found within this range with DkmILFailureReason.StringTooLong.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryStringRead.Flags">
      <summary>Flags controlling the behavior of DkmProcess.ReadMemory and DkmProcess.ReadMemoryString.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryStringRead.MaxCharacters">
      <summary>The maximum number of characters to read from the target process. When DkmReadMemoryFlags.AllowPartialRead is false, the request will fail if a null terminator is not found within this range with DkmILFailureReason.StringTooLong.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryWrite">
      <summary>A request to write a sequence of bytes from memory. Pops a value off the stack. Then, pops an address of the stack. Writes the value popped off the stack to debuggee memory at the address popped off the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMemoryWrite.Create">
      <summary>Create a new DkmILMemoryWrite object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMultiply">
      <summary>Pops two values off the evaluation stack, multiplies them, and pushes the product onto the evaluation stack. Both operands popped off the stack must be the size indicated by DkmPrimitiveObjectType. In the event of overflow, the result will be truncated.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMultiply.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Create a new DkmILMultiply object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of subtraction to perform (e.g. integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILMultiply.Type">
      <summary>The type of subtraction to perform (e.g. integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILNop">
      <summary>Placeholder instruction that performs no operation.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILNop.Create">
      <summary>Creates a new DkmILNop object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue">
      <summary>A value that can be passed in as a parameter to an IL stream.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue.Create(System.UInt32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmILParameterValue object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="LocalIndex">[In] The index of the local variable in the IL that will receive the parameter value. When the IL stream starts executing, the local variable at this index will be preset to the parameter value.</param>
      <param name="ValueBytes">[In] The bytes representing the value to pass in as the parameter.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue.LocalIndex">
      <summary>The index of the local variable in the IL that will receive the parameter value. When the IL stream starts executing, the local variable at this index will be preset to the parameter value.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILParameterValue.ValueBytes">
      <summary>The bytes representing the value to pass in as the parameter.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILPop">
      <summary>Pop the value on top of the DkmIL stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILPop.Create">
      <summary>Create a new DkmILPop object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILPushConstant">
      <summary>Pushes a constant value onto the DkmIL stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILPushConstant.Create(System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmILPushConstant object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Value">[In] The value to push onto the DkmIL stack.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILPushConstant.Value">
      <summary>The value to push onto the DkmIL stack.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterRead">
      <summary>A request to read the value of a specific register. The result is pushed on the DkmIL stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterRead.Create(System.Int32)">
      <summary>Creates a new DkmILRegisterRead object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RegisterId">[In] The code-view definition of which register to read. Values are defined in cvconst.h. This is architecture dependent.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterRead.RegisterId">
      <summary>The code-view definition of which register to read. Values are defined in cvconst.h. This is architecture dependent.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterWrite">
      <summary>Pops a value off the IL stack. Then, writes the value to the given register of the given thread. The write will be visible to the debuggee from the top frame of that thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterWrite.Create(System.Int32)">
      <summary>Create a new DkmILRegisterWrite object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RegisterId">[In] The code-view definition of which register to write. Values are defined in cvconst.h. This is architecture dependent.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRegisterWrite.RegisterId">
      <summary>The code-view definition of which register to write. Values are defined in cvconst.h. This is architecture dependent.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRemainder">
      <summary>Pops two values off the evaluation stack and computes the second value popped off the stack modulo the first value popped off the stack.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRemainder.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILRemainder object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of operands to consume (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILRemainder.Type">
      <summary>The type of operands to consume (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILReturnTop">
      <summary>Pop the value on top of the DkmIL stack and return it as an instance of DkmILEvaluationResult.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILReturnTop.Create">
      <summary>Create a new DkmILReturnTop object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSave">
      <summary>Saves the value at the top of the stack in a temporary slot at the given index, from which it can later be loaded back.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSave.Create(System.UInt32)">
      <summary>Create a new DkmILSave object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Index">[In] The index at which to save the value.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSave.Index">
      <summary>The index at which to save the value.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSubtract">
      <summary>Pops two values off the evaluation stack, subtracts them, and pushes the difference onto the evaluation stack. Both operands popped off the stack must be the size indicated by DkmPrimitiveObjectType. The first value popped from the stack will be subtracted from the second value popped. Therefore, to evaluate "a - b", you would push a, and then push b, and then subtract. The resultant value will have the same size as the operands. In the event of overflow, the result will be truncated.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSubtract.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType)">
      <summary>Creates a new DkmILSubtract object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Type">[In] The type of subtraction to perform (e.g., integer vs. floating-point).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILSubtract.Type">
      <summary>The type of subtraction to perform (e.g., integer vs. floating-point).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILThrow">
      <summary>Throws a native IL exception in the given failure code.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILThrow.Create(Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason)">
      <summary>Create a new DkmILThrow object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FailureCode">[In] Indicates a reason why an IL instruction did not execute. In addition to these constants, negative values may be used to indicate customized error conditions resulting from the execution of intrinsic functions.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILThrow.FailureCode">
      <summary>Indicates a reason why an IL instruction did not execute. In addition to these constants, negative values may be used to indicate customized error conditions resulting from the execution of intrinsic functions.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILFailureReason" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILTlsGetValue">
      <summary>Pushes an index of a TLS slot off the MSIL stack. Reads the value of that TLS slot for the thread of the current stack frame and pushes the result onto the MSIL stack. If the TLS index is not valid, the result is undefined. It may read a random value from memory, or fail. The value that is pushed on the stack is a pointer-sized value (4 bytes if the debuggee is 32-bit, 8 bytes if the debuggee is 64-bit).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmILTlsGetValue.Create">
      <summary>Creates a new DkmILTlsGetValue object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType">
      <summary>Indicates the underlying primitive type (ex: UInt32) being operated on.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Int8">
      <summary>Represents a signed 8-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.UInt8">
      <summary>Represents an unsigned 8-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Int16">
      <summary>Represents a signed 16-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.UInt16">
      <summary>Represents an unsigned signed 16-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Int32">
      <summary>Represents a signed 32-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.UInt32">
      <summary>Represents an unsigned 32-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Int64">
      <summary>Represents a signed 64-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.UInt64">
      <summary>Represents an unsigned 64-bit integer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Float">
      <summary>Represents a 32-bit single-precision floating-point value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.Double">
      <summary>Represents a 64-bit double-precision floating-point value.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Evaluation.IL.DkmPrimitiveObjectType.LongDouble">
      <summary>Represents a 10-byte floating-point value.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmAddExceptionTriggerAsyncResult">
      <summary>Result of an asynchronous DkmProcess.AddExceptionTrigger call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmAddExceptionTriggerAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmProcess.AddExceptionTrigger.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmAddExceptionTriggerAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmAddExceptionTriggerAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory">
      <summary>Indicates the type of exception.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.ActiveScript">
      <summary>ActiveScript Exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.Clr">
      <summary>Common Language Runtime Exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.Cpp">
      <summary>C++ Exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.Gpu">
      <summary>GPU Exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.ManagedDebuggingAssistant">
      <summary>Managed Debugging Assistant (MDA). These are notifications that come of the CLR to notify the user of problems.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.NativeRuntimeCheck">
      <summary>Native Run-Time Check.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategory.Win32">
      <summary>Win32 Exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategoryTrigger">
      <summary>Describes the complete category (ex: .NET Framework exceptions, Win32 exceptions) that a component wants to break on.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategoryTrigger.Create(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.DkmThread,System.Guid)">
      <summary>Creates a new DkmExceptionCategoryTrigger object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="Thread">[In,Optional] Thread on which this trigger applies. If null, the trigger will be examined for all threads.</param>
      <param name="ExceptionCategory">[In] Indicates the type of exception.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCategoryTrigger.ExceptionCategory">
      <summary>Indicates the type of exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCodeTrigger">
      <summary>Describe an exception that a component wants to break on by its exception code. Code triggers are used for exception categories which use exception codes to identify exceptions (ex: Win32 exceptions). Code triggers will not fire for exception categories which use a name string to identify exceptions (ex: CLR exceptions).</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCodeTrigger.Code">
      <summary>32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCodeTrigger.Create(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.DkmThread,System.Guid,System.UInt32)">
      <summary>Create a new DkmExceptionCodeTrigger object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="Thread">[In,Optional] Thread on which this trigger applies. If null, the trigger will be examined for all threads.</param>
      <param name="ExceptionCategory">[In] Indicates the type of exception.</param>
      <param name="Code">[In] 32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionCodeTrigger.ExceptionCategory">
      <summary>Indicates the type of exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionGlobalTrigger">
      <summary>An exception trigger which will fire regardless of exception category, exception name, or exception code. Thus, this kind of exception trigger can only be conditioned based on processing stage or thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionGlobalTrigger.Create(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Create a new DkmExceptionGlobalTrigger object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="Thread">[In,Optional] Thread on which this trigger applies. If null, the trigger will be examined for all threads.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation">
      <summary>Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing. Derived classes: DkmClrExceptionInformation, DkmCppExceptionInformation, DkmCustomExceptionInformation, DkmGPUMemoryAccessExceptionInformation, DkmWin32ExceptionInformation</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.CanModifyProcessing">
      <summary>Determines if processing for this exception may be modified by the debugger. For example, if this user has performed an action (such as set next statement) that required the exception to be implicitly squashed, this may return false. This method may also return false if the runtime does not permit the exception from being squashed.</summary>
      <returns>[Out] True if the debug monitor can modify the processing of this exceptions.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Code">
      <summary>32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.ExceptionCategory">
      <summary>Indicates the type of exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.GetAdditionalInformation">
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.GetDescription">
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.GetWinRTErrorInfo(System.String@,System.String@,System.String@)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.ImplementationException">
      <summary>[Optional] Information about the underlying exception used to implement a higher level exception. For example, CLR and C++ exceptions may be implemented in addition to Win32 exceptions. So this may store the DkmWin32ExceptionInformation for CLR or C++ exceptions.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.InstructionAddress">
      <summary>[Optional] Address where the exception occurred. This will always be present for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these may originate from inside the runtime.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Name">
      <summary>[Optional] Name of the exception. For C++ or CLR exceptions, this is the type name. This value will be null for exception categories that identify exceptions by code (ex: Win32).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.OnContinued"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.OnDebugMonitorException"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.ProcessingStage">
      <summary>The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled). This enumeration indicates the stage(s) for a notification.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.SquashProcessing">
      <summary>Updates the state of the target process so that when execution is resumed, the target process will not continue standard exception processing (ex: handler search, stack unwinding). This method must be called before resuming execution.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.TagValue">
      <summary>DkmExceptionInformation is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag">
      <summary>DkmExceptionInformation is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag.Win32Exception">
      <summary>Object is an instance of 'DkmWin32ExceptionInformation'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag.ClrException">
      <summary>Object is an instance of 'DkmClrExceptionInformation'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag.CppException">
      <summary>Object is an instance of 'DkmCppExceptionInformation'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag.GPUMemoryAccessException">
      <summary>Object is an instance of 'DkmGPUMemoryAccessExceptionInformation'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation.Tag.CustomException">
      <summary>Object is an instance of 'DkmCustomExceptionInformation'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags">
      <summary>Specifies exception interception actions.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags.None">
      <summary>No flags set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags.Intercept">
      <summary>Intercept exception.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInterceptActionFlags.CancelIntercept">
      <summary>Cancel intercept request.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionNameTrigger">
      <summary>Describes an exception that a component wants to break on by its name. NameTriggers are used for exception categories that use names to identify exceptions. For example, CLR exceptions and C++ exceptions are identified by type name. Name triggers will not fire for code-based exception categories (ex: Win32 exceptions).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionNameTrigger.Create(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.DkmThread,System.Guid,System.String)">
      <summary>Creates a new DkmExceptionNameTrigger object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="Thread">[In,Optional] Thread on which this trigger applies. If null, the trigger will be examined for all threads.</param>
      <param name="ExceptionCategory">[In] Indicates the type of exception.</param>
      <param name="Name">[In] Name of the exception. For C++ or CLR exceptions, this is the type name.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionNameTrigger.ExceptionCategory">
      <summary>Indicates the type of exception.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionNameTrigger.Name">
      <summary>Name of the exception. For C++ or CLR exceptions, this is the type name. This value will be null for exception categories that identify exceptions by code (ex: Win32 exceptions).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage">
      <summary>The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled). This enumeration indicates the stage(s) for a notification.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.Thrown">
      <summary>An exception was thrown. This notification occurs for all kinds of exceptions.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.UserCodeSearch">
      <summary />
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.AppDomainTransition">
      <summary>The target process is about to swallow the exception at an application domain transition.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.ManagedUnmanagedTransition">
      <summary>The target process is about to pass the exception from managed code into unmanaged code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.UserUnhandled">
      <summary>An exception handler has been found outside user code. This notification is provided only for exception categories that support Just My Code. Currently, only the CLR exception category supports Just My Code.\n.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.Unhandled">
      <summary>No handler was found for this exception.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage.UserVisible">
      <summary>Exception should be visible to users. When set, the exception will be sent to the output window if the user does not want to stop at the exception.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger">
      <summary>Describes an exception or collection of exceptions that a component wants to break on. When a higher-level component wants to be notified about certain exceptions, it should create one or more exception triggers, and then enable these triggers (DkmProcess.EnableExceptionTriggers). After this, when the exception occurs, an ExceptionTriggerHit exception will be fired whenever this trigger is met. Derived classes: DkmExceptionCategoryTrigger, DkmExceptionCodeTrigger, DkmExceptionGlobalTrigger, DkmExceptionNameTrigger.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.ProcessingStage">
      <summary>The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled). This enumeration is a bitmask of which of these stages the trigger should fire for.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.TagValue">
      <summary>DkmExceptionTrigger is an abstract base class. This enumeration indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Thread">
      <summary>[Optional] Thread on which this trigger applies. If null, the trigger will be examined for all threads.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag">
      <summary>DkmExceptionTrigger is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag.GlobalTrigger">
      <summary>Object is an instance of 'DkmExceptionGlobalTrigger'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag.CategoryTrigger">
      <summary>Object is an instance of 'DkmExceptionCategoryTrigger'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag.NameTrigger">
      <summary>Object is an instance of 'DkmExceptionNameTrigger'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTrigger.Tag.CodeTrigger">
      <summary>Object is an instance of 'DkmExceptionCodeTrigger'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit">
      <summary>Provides information about an exception trigger which was satisfied (hit) by an exception coming from the target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.AdditionalInformation">
      <summary>[Optional] Optional additional information about this exception. For CLR exceptions, this contains the 'Message' property from the System.Exception which was thrown. This information is obtained from IDkmExceptionFormatter.GetAdditionalInformation.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.CapabilitySid">
      <summary>[Optional] Specifies the missing capability if there is one which resulted in a runtime exception.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Create(Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,System.String,System.String,System.String,System.String,System.String,System.Guid)">
      <summary>Create a new DkmExceptionTriggerHit object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Exception">[In] Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</param>
      <param name="Description">[In] Description string for the exception. This is obtained from IDkmExceptionFormatter.GetDescription.</param>
      <param name="RestrictedErrorDescription">[In,Optional] Optional Windows Runtime Restricted Description for the error, obtained from the IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.</param>
      <param name="CapabilitySid">[In,Optional] Specifies the missing capability if there is one which resulted in a runtime exception.</param>
      <param name="RestrictedReference">[In,Optional] Specifies the restricted reference. This is provided instead of the RestrictedDescription and any CapabilitySid. A scenario for this is when the debuggee process is not running in same session as debugger process. Components above must use this to determine the restricted description and any missing capability.</param>
      <param name="AdditionalInformation">[In,Optional] Optional additional information about this exception. For CLR exceptions, this contains the 'Message' property from the System.Exception which was thrown. This information is obtained from IDkmExceptionFormatter.GetAdditionalInformation.</param>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Description">
      <summary>Description string for the exception. This is obtained from IDkmExceptionFormatter.GetDescription.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Exception">
      <summary>Provides information about an exception which was raised in the target process. This information includes details of what exception was raised and the current stage of exception processing.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.RestrictedErrorDescription">
      <summary>[Optional] Optional Windows Runtime Restricted Description for the error, obtained from the IDkmExceptionFormatterCallback.GetRestrictedErrorInfo.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.RestrictedReference">
      <summary>[Optional] Specifies the restricted reference. This is provided instead of the RestrictedDescription and any CapabilitySid. A scenario for this is when the debuggee process is not running in same session as debugger process. Components above must use this to determine the restricted description and any missing capability.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Send">
      <summary>Raise a ExceptionTriggerHit event. Components which implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components may be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint which may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionTriggerHit.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags">
      <summary>Flags which affect how a search should be performed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags.UseWildcard">
      <summary>Input expression contains a wildcard search to bind.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnFunctionResolvedAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnFunctionResolved call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnFunctionResolvedAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeFunctionResolutionRequest.OnFunctionResolved.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnFunctionResolvedAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnFunctionResolvedAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnResolverMessageAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeFunctionResolutionRequest.OnResolverMessage call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnResolverMessageAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeFunctionResolutionRequest.OnResolverMessage.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnResolverMessageAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnResolverMessageAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest">
      <summary>DkmRuntimeFunctionResolutionRequest represents an expression to be parsed and evaluated by a runtime based expression evaluator and is bound to a particular process. Resolutions will send DkmModuleInstance::FunctionResolved events.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.Close">
      <summary>Closes the DkmRuntimeFunctionResolutionRequest object. Once this is closed, no new resolutions will be sent. DkmRuntimeFunctionResolutionRequest objects are automatically closed when their associated DkmProcess object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.CompilerId">
      <summary>Language/Vendor of the request. Vendor is usually set to Guid.Empty. Language and vendor will be set to Guid.Empty for function breakpoints set with an 'Unknown' language.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,System.String,System.UInt32,System.String,Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmRuntimeFunctionResolutionRequest object instance. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="CompilerId">[In] Language/Vendor of the request. Vendor is usually set to Guid.Empty.</param>
      <param name="FunctionName">[In] The name of the function to resolve to.</param>
      <param name="LineOffset">[In] The line offset from the start of the function to bind to.</param>
      <param name="ModuleName">[In] The name of the module to resolve to.</param>
      <param name="SearchFlags">[In] Flags which affect how a search should be performed.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmRuntimeFunctionResolutionRequest instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.EnableResolution(Microsoft.VisualStudio.Debugger.DkmWorkList)">
      <summary>Called by the breakpoint manager to add a pending resolve request. Expression evaluators, or other components will immediately try to bind the breakpoint against current modules, and will bind the breakpoint to additional locations as modules load. The caller of this interface should implement IDkmRuntimeFunctionResolverClient to obtain the results of the resolution. Implementations of this interface should stop trying to bind the breakpoint when the DkmRuntimeFunctionResolutionRequest object is closed. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.FunctionName">
      <summary>The name of the function to resolve to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.LineOffset">
      <summary>The line offset from the start of the function to bind to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.ModuleName">
      <summary>The name of the module to resolve to.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.OnFunctionResolved(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.OnFunctionResolved(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnFunctionResolvedAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.OnResolverMessage(Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel,System.String)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.OnResolverMessage(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Breakpoints.DkmBreakpointMessageLevel,System.String,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.FunctionResolution.DkmOnResolverMessageAsyncResult})"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.SearchFlags">
      <summary>Flags which affect how a search should be performed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmRuntimeFunctionResolutionRequest.UniqueId">
      <summary>Uniquely identifies the DkmRuntimeFunctionResolutionRequest object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest">
      <summary>DkmSymbolFunctionResolutionRequest represents an expression to be parsed and evaluated by a symbol based expression evaluator and is not bound to a particular process. Used to perform function breakpoint binds.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage,System.String,System.UInt32,System.String,Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags)">
      <summary>Create a new DkmSymbolFunctionResolutionRequest object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="Module">[In,Optional] The module to bind against. If null, then all modules should be checked. If the module's name does not match the module name parameter, no bind will occur.</param>
      <param name="Language">[In] Describes a programming language.</param>
      <param name="FunctionName">[In] Source text of the parsed expression.</param>
      <param name="LineOffset">[In] The line offset from the start of the function to bind to.</param>
      <param name="ModuleName">[In] Module name to bind in.</param>
      <param name="SearchFlags">[In] Flags which affect how a search should be performed.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.FunctionName">
      <summary>Source text of the parsed expression.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.Language">
      <summary>Describes a programming language.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.LineOffset">
      <summary>The line offset from the start of the function to bind to.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.Module">
      <summary>[Optional] The module to bind against. If null, then all modules should be checked. If the module's name does not match the module name parameter, no bind will occur.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.ModuleName">
      <summary>Module name to bind in.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.Resolve">
      <summary>Resolve an address string to zero or more address symbols. This is used to bind function breakpoints. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmInstructionSymbol[] represents a method in the target process.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmSymbolFunctionResolutionRequest.SearchFlags">
      <summary>Flags which affect how a search should be performed.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.FunctionResolution.DkmAddressSearchFlags" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel">
      <summary>The model type that a compute kernel uses.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel.Flat">
      <summary>Compute kernel uses flat model.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel.Tile">
      <summary>Compute kernel uses tile model.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel.HLSL">
      <summary>Compute kernel uses three-dimensional HLSL model.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty">
      <summary>Collection of properties of GPU compute kernel.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty.#ctor(System.String,System.String)">
      <summary>Initializes a new DkmComputeProperty value.</summary>
      <param name="Name">[In] Property name.</param>
      <param name="Value">[In] Property value.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty.Name">
      <summary>Property name.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty.Value">
      <summary>Property value.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo">
      <summary>Collection of properties of GPU compute threads.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.#ctor(System.UInt32,System.UInt32,System.UInt64,System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState,System.Boolean,System.Boolean)">
      <summary>Initialize a new DkmComputeThreadInfo value.</summary>
      <param name="ThreadCount">[In] The number of threads represented by this object, could be greater than one if returned in a group by call.</param>
      <param name="VectorId">[In] Vector index.</param>
      <param name="ThreadGroupId">[In] Thread group ID, unique to kernel.</param>
      <param name="ThreadId">[In] Thread ID, unique to kernel.</param>
      <param name="InstructionPointer">[In] The IP of the compute thread.</param>
      <param name="ThreadState">[In] State of the compute thread.</param>
      <param name="FlaggedState">[In] Flagged state of the compute thread.</param>
      <param name="FrozenState">[In] Frozen state of the compute thread.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.FlaggedState">
      <summary>Flagged state of the compute thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.FrozenState">
      <summary>Frozen state of the compute thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.InstructionPointer">
      <summary>The IP of the compute thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.ThreadCount">
      <summary>The number of threads represented by this object, could be greater than one if returned in a group by call.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.ThreadGroupId">
      <summary>Thread group ID, unique to kernel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.ThreadId">
      <summary>Thread ID, unique to kernel.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.ThreadState">
      <summary>State of the compute thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo.VectorId">
      <summary>Vector index.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState">
      <summary>Compute thread state flags.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Unknown">
      <summary>Not a valid compute thread state.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Active">
      <summary>Compute thread is active.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Divergent">
      <summary>Compute thread is divergent.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Blocked">
      <summary>Compute thread is blocked.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Unused">
      <summary>Compute thread is unused.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.NotStarted">
      <summary>Compute thread is not started.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadState.Completed">
      <summary>Compute thread is completed.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUAddressType">
      <summary>DkmGPUAddressType describes if an address represents a special location in the GPU debuggee's byte code.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUAddressType.None">
      <summary>No type flat is set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUAddressType.FunctionCall">
      <summary>The address is at the inline function call site, that is, the instruction just before inline function.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUAddressType.NoStepInto">
      <summary>The address has symbols but should not be stepped into.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUBreakpointBehaviorFlags">
      <summary>Flags for describing GPU breakpoint behavior.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUBreakpointBehaviorFlags.None">
      <summary>No specific behavior.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUBreakpointBehaviorFlags.BreakOncePerWarp">
      <summary>Break one time per warp.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUBreakpointBehaviorFlags.BreakForEveryThread">
      <summary>Break for every thread.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPUBreakpointBehaviorFlags.BreakOnFirstDefaultWarp">
      <summary>Break on first or default warp.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel">
      <summary>DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.Create(System.Int32,System.Int64,System.Int64,System.Int64,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt32},System.Int64,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt32},System.Int32,Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>DkmGPUComputeKernel is called by a debug monitor to create a new DkmGPUComputeKernel instance. DkmGPUComputeKernel objects for GPU compute kernels are created by the base debug monitor.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="DispatchId">[In] The GPU dispatch id for this kernel object.</param>
      <param name="GPUDevice">[In] The GPU device this compute kernel runs on.</param>
      <param name="GPUShader">[In] A compute kernel is a running instance of this GPU shader.</param>
      <param name="GPUShaderDispatch">[In] The handle of the executing GPU shader corresponding to this compute kernel.</param>
      <param name="GroupDimensions">[In] Thread group dimensions in a compute kernel.</param>
      <param name="NumberOfGroups">[In] Number of thread groups in a compute kernel.</param>
      <param name="ThreadDimensions">[In] Thread dimensions in a compute kernel.</param>
      <param name="NumberOfThreads">[In] Number of compute threads in a thread group of compute kernel.</param>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmGPUComputeKernel instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.DispatchId">
      <summary>The GPU dispatch id for this kernel object.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.FindComputeThread(System.Int64)">
      <summary>Find a DkmGPUComputeThread element within this DkmGPUComputeKernel. If no element that has the given input key is present, FindComputeThread will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="GlobalThreadIndex">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetActiveThreadGroups(System.Int64[]@,System.Int32@)">
      <summary>Obtain the active thread groups from the compute kernel.</summary>
      <param name="ActiveThreadGroups">[Out] List of global Thread group id of all active thread groups.</param>
      <param name="NumberOfGroups">[Out] Number of active thread groups in the compute kernel.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetComputeKernelName">
      <summary>Get the name of compute kernel.</summary>
      <returns>[Out] Name of the ComputeKernel that is started.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetComputeKernelProperties(Microsoft.VisualStudio.Debugger.GPU.DkmComputeProperty[]@,System.Int32@)">
      <summary>Get properties of the compute kernel.</summary>
      <param name="ComputeProperties">[Out] List of Compute kernel properties.</param>
      <param name="NumberOfProperties">[Out] Number of properties in the compute kernel.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetComputeVectorWidth(System.Int32@)">
      <summary>Obtain the warp size of the hardware or emulator.</summary>
      <param name="Width">[Out] Width of the hardware.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetCurrentGroupDimensions(System.Int32[]@,System.Int32@)">
      <summary>Get the dimension of the thread block.</summary>
      <param name="GroupDimensions">[Out] Grid Dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetCurrentThreadDimensions(System.Int32[]@,System.Int32@)">
      <summary>Get the dimension of the thread block.</summary>
      <param name="ThreadDimensions">[Out] Thread group dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Thread block dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetFlatComputeKernelDimensions(System.Int32[]@,System.Int32[]@,System.Int32@,Microsoft.VisualStudio.Debugger.GPU.DkmComputeKernelModel@)">
      <summary>Get the dimension of the thread block.</summary>
      <param name="FlatThreadDimensions">[Out] Thread group dimensions.</param>
      <param name="FlatIndexBase">[Out] Thread group dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Thread block dimensions.</param>
      <param name="Model">[Out] Model Type.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GetThreadFromId(System.UInt64,Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread@)">
      <summary>Gets the DkmGPUComputeThread object for a given thread ID.</summary>
      <param name="ThreadId">[In] ID of the thread to return.</param>
      <param name="Thread">[Out] Thread object that matches the given thread ID.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GPUDevice">
      <summary>The GPU device this compute kernel runs on.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GPUShader">
      <summary>A compute kernel is a running instance of this GPU shader.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GPUShaderDispatch">
      <summary>The handle of the executing GPU shader corresponding to this compute kernel.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GroupBy(Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause)">
      <summary>Runs the group by query on thread information objects.</summary>
      <returns>[Out] The result set of compute thread information objects.</returns>
      <param name="GroupByFlags">[In] Flags specifying on which columns the group by is run.</param>
      <param name="From">[In] From clause specification for selection (can be empty to select from all available threads).</param>
      <param name="Where">[In] Where clause specification for group by.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.GroupDimensions">
      <summary>Thread group dimensions in a compute kernel.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.NumberOfGroups">
      <summary>Number of thread groups in a compute kernel.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.NumberOfThreads">
      <summary>Number of compute threads in a thread group of compute kernel.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.Select(System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64},Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause)">
      <summary>Runs the select query on thread information objects.</summary>
      <returns>[Out] The result set of compute thread information objects.</returns>
      <param name="From">[In] From clause specification for selection (can be empty to select from all available threads).</param>
      <param name="Where">[In] Where clause specification for selection.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.ThreadDimensions">
      <summary>Thread dimensions in a compute kernel.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.UniqueId">
      <summary>Guid which uniquely identifies this compute kernel object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.Unload(System.Int32)">
      <summary>ComputeKernelExit is sent by the dispatcher when DkmGPUComputeKernel::Unload is invoked by the monitor. This method may only be called by the component which created the object.</summary>
      <param name="ExitCode">[In] 32-bit value that the compute kernel returned on exit.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.UpdateFlaggedState(Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause,System.Boolean)">
      <summary>Update flagged state of compute threads.</summary>
      <param name="Where">[In] Where clause specification for update.</param>
      <param name="Flagged">[In] The value to update with.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel.UpdateFrozenState(Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause,System.Boolean)">
      <summary>Update frozen state of compute threads.</summary>
      <param name="Where">[In] Where clause specification for update.</param>
      <param name="Frozen">[In] The value to update with.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread">
      <summary>Represents a compute thread running in the GPU target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.ComputeKernel">
      <summary>DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.Create(Microsoft.VisualStudio.Debugger.DkmProcess,System.UInt64,System.Boolean,System.Int64,Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeKernel,Microsoft.VisualStudio.Debugger.DkmThread.System,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmGPUComputeThread object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="NativeStartAddress">[In] If available, this is the Win32 start address of this thread (value passed to the CreateThread API). The value will not always be available, for example, it is generally not available in scenarios where the thread was started after the debugger attached, or in minidumps.</param>
      <param name="IsMainThread">[In] True if this is the main thread of this process. The main thread is the first thread to start.</param>
      <param name="GlobalThreadIndex">[In] Unique to kernel compute thread index.</param>
      <param name="ComputeKernel">[In] DkmGPUComputeKernel represents a GPU compute kernel running in the target process.</param>
      <param name="System">[In,Optional] Describes traits of the thread that are relevant to a full Win32 thread. Currently, this value is required, and all threads will have a 'System' block. In the future, this value may be NULL if the DkmThread represents something other than a full Win32 thread.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmGPUComputeThread instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GetGroupId(System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="GroupDimensions">[Out] Grid dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GetRegisterDescriptions">
      <summary>Obtains the list of all register descriptions from the GPU compute thread.</summary>
      <returns>[Out] The list of all register descriptions from the GPU compute thread.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GetThisGroupDimension(System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="GroupDimensions">[Out] Grid dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Grid dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GetThisThreadDimension(System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="ThreadDimensions">[Out] Thread group dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Thread block dimensions.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GetThreadId(System.Int32[]@,System.Int32@)">
      <summary>Gets the dimension of the thread block.</summary>
      <param name="ThreadDimensions">[Out] Thread group dimensions.</param>
      <param name="NumberOfDimensions">[Out] Number of Thread block dimensions.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.GlobalThreadIndex">
      <summary>Unique to kernel compute thread index.</summary>
      <returns>Returns <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.ReadMemory(System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Byte[])"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.ReadMemory(System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.DkmReadMemoryFlags,System.Void*,System.Int32)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.SetRegisterValue(Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Sets the value of a register in the GPU compute thread.</summary>
      <param name="RegisterDescription">[In] The description of a register from the GPU compute thread.</param>
      <param name="RegisterValue">[In] The value bytes of a register to be written in the GPU compute thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.UpdateBufferTag(System.UInt32)">
      <summary>Checks whether a tag for a buffer has been forwarded for this kernel execution.</summary>
      <returns>[Out] The forwarded tag value.</returns>
      <param name="InputTag">[In] The C++ AMP pointer tag.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.ValidateAddress(System.UInt64)">
      <summary>Validates the specified GPU memory address.</summary>
      <returns>[Out] True if the specified address is a valid GPU memory address; false otherwise.</returns>
      <param name="Address">[In] The address to validate.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread.WriteMemory(System.UInt64,System.UInt64,System.Byte[])"></member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUDataAddress">
      <summary>Represents an address in GPU data. The high 32-bit in Value is tag and the low 32-bit in Value is offset.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUDataAddress.ComputeThread">
      <summary>DkmGPUComputeThread represents a compute thread running in the GPU target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUDataAddress.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,System.UInt64,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.GPU.DkmGPUComputeThread,System.UInt64)">
      <summary>Create a new DkmGPUDataAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="Value">[In] Data address.</param>
      <param name="InstructionAddress">[In,Optional] Set when the data address is an instruction address.</param>
      <param name="ComputeThread">[In] DkmGPUComputeThread represents a compute thread running in the GPU target process.</param>
      <param name="InstructionPointer">[In] GPU data address may correspond to different register location at different instruction pointer.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUDataAddress.InstructionPointer">
      <summary>GPU data address may correspond to different register location at different instruction pointer.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPUMemoryAccessExceptionInformation">
      <summary>Provides information about a GPU memory access exception that was raised in the target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUMemoryAccessExceptionInformation.ConflictingInstructionAddress">
      <summary>The address of the conflicting instruction.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.GPU.DkmGPUMemoryAccessExceptionInformation.ConflictingThreadGlobalIndex">
      <summary>The global ID of the conflicting thread.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPUMemoryAccessExceptionInformation.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.String,System.UInt32,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,System.UInt64,System.UInt64)">
      <summary>Creates a new DkmGPUMemoryAccessExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment that is loaded into a DkmProcess and that contains code to be debugged.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="InstructionAddress">[In,Optional] Address where the exception occurred. This will always be present for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these may originate from inside the runtime.</param>
      <param name="Name">[In,Optional] Name of the exception. For C++ or CLR exceptions, this is the type name. This value will be null for exception categories that identify exceptions by code (ex: Win32).</param>
      <param name="Code">[In] 32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex: EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</param>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="ConflictingInstructionAddress">[In] The address of the conflicting instruction.</param>
      <param name="ConflictingThreadGlobalIndex">[In] The global ID of the conflicting thread.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription">
      <summary>The description of GPU registers for a GPU compute thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription.#ctor(System.UInt32,System.UInt32,System.UInt64,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Initializes a new DkmGPURegisterDescription value.</summary>
      <param name="RegisterType">[In] The GPU register type.</param>
      <param name="RegisterIndex">[In] The index of a GPU register.</param>
      <param name="RegisterSize">[In] The size of a GPU register, in bytes.</param>
      <param name="RegisterValue">[In] The value bytes of a GPU register. This is ordinarily 16 bytes.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription.RegisterIndex">
      <summary>The index of a GPU register.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription.RegisterSize">
      <summary>The size of a GPU register, in bytes.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription.RegisterType">
      <summary>The GPU register type.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmGPURegisterDescription.RegisterValue">
      <summary>The value bytes of a GPU register. This is ordinarily 16 bytes.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents">
      <summary>Indicates which parts of a thread or group ID should be used.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents.X">
      <summary>The X part of the id vector.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents.Y">
      <summary>The Y part of the id vector.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmHlslThreadIdComponents.Z">
      <summary>The Z part of the id vector.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags">
      <summary>Options for how to query compute thread information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.None">
      <summary>No query option flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.ThreadGroupId">
      <summary>Do the query by ThreadGroupId.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.VectorId">
      <summary>Do the query by VectorId.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.ThreadId">
      <summary>Do the query by ThreadId.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.ThreadState">
      <summary>Do the query by ThreadState.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.FlaggedState">
      <summary>Do the query by FlagState.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.InstructionPointer">
      <summary>Do the query by InstructionPointer.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags.FrozenState">
      <summary>Do the query by FrozenState.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause">
      <summary>A structure used as a where clause when querying compute thread information.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause.#ctor(Microsoft.VisualStudio.Debugger.GPU.DkmQueryComputeThreadInfoFlags,Microsoft.VisualStudio.Debugger.GPU.DkmComputeThreadInfo)">
      <summary>Initializes a new DkmWhereClause value.</summary>
      <param name="ColumnFlags">[In] Flags specifying columns in a where clause.</param>
      <param name="Values">[In] Values of the columns specified in ColumnFlags.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause.ColumnFlags">
      <summary>Flags specifying columns in a where clause.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.GPU.DkmWhereClause.Values">
      <summary>Values of the columns specified in ColumnFlags.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmEELocalObject object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmEELocalObject instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetAssembly(System.UInt32,System.UInt32,System.UInt32@,System.String@,System.Byte[]@,System.Byte[]@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetHostAssembly(System.UInt32,System.Byte[]@,System.Byte[]@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetTargetAssembly(System.String,System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetTargetClass(System.String,System.UInt32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetValueAttributeProps(System.UInt32,System.UInt32,System.String@,System.UInt32@,System.String@,System.String@,System.String@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetViewerAttributeProps(System.UInt32,System.UInt32,System.String@,System.UInt32@,System.String@,System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.GetVisualizerAttributeProps(System.UInt32,System.UInt32,System.String@,System.UInt32@,System.String@,System.UInt32@,System.String@,System.UInt32@,System.String@,System.UInt32@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.InitCache"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.Process">
      <summary>DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Internal.DkmEELocalObject.UniqueId">
      <summary>GUID that uniquely identifies this DkmPropertyProxy.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy">
      <summary>Concord wrapper around IPropertyProxyEESide.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.Create(System.UInt32,Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmPropertyProxy object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In]</param>
      <param name="EvaluationResult">[In] The evaluation result this proxy is based on.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmPropertyProxy instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.EvaluationResult">
      <summary>The evaluation result this proxy is based on.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmSuccessEvaluationResult" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.GetManagedViewerCreationData(System.String@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.String@,System.UInt32@,System.Boolean@)">
      <summary>Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="AssemblyName">[Out,Optional]</param>
      <param name="AssemblyBytes">[Out,Optional]</param>
      <param name="AssemblyPdb">[Out,Optional]</param>
      <param name="ClassName">[Out,Optional] class name.</param>
      <param name="AssemblyResolution">[Out] enum_ASSEMBLYLOCRESOLUTION enumeration.</param>
      <param name="ReplacementOk">[Out] replacement OK.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.Id">
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.InitSourceDataProvider">
      <summary>Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] The result bytes.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.InPlaceUpdateObject(System.Byte[])">
      <summary>Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional]</returns>
      <param name="DataIn">[In]</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.ResolveAssemblyReference(System.String,System.UInt32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte}@,System.String@,System.UInt32@)">
      <summary>Implements IPropertyProxyEESide::ResolveAssemblyReference(). Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="AssemblyName">[In]</param>
      <param name="Flags">[In] GETASSEMBLY flags.</param>
      <param name="AssemblyBytes">[Out,Optional]</param>
      <param name="AssemblyPdb">[Out,Optional]</param>
      <param name="AssemblyLocation">[Out,Optional]</param>
      <param name="AssemblyResolution">[Out] ASSEMBLYLOCRESOLUTION enumeration.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Internal.DkmPropertyProxy.UniqueId">
      <summary>GUID that uniquely identifies this DkmPropertyProxy.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation">
      <summary>Provides information about a C++ exception which was raised in the target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation.Address">
      <summary>The address where the exception occurred.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionInformation,System.String,System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation)">
      <summary>Create a new DkmCppExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="InstructionAddress">[In,Optional] Address where the exception occurred. This will always be present for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these may originate from inside the runtime.</param>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="ImplementationException">[In,Optional] Information about the underlying exception used to implement a higher level exception. For example, CLR and C++ exceptions may be implemented in addition to Win32 exceptions. So this may store the DkmWin32ExceptionInformation for CLR or C++ exceptions.</param>
      <param name="Name">[In] Type name of the exception. Example: 'std::exception'.</param>
      <param name="ExceptionObjectPointer">[In] Address in the target process of the thrown object.</param>
      <param name="Address">[In] The address where the exception occurred.</param>
      <param name="WinRTExceptionInfo">[In,Optional] Extended information about a Windows Runtime exception if it exists.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation.ExceptionObjectPointer">
      <summary>Address in the target process of the thrown object.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation.Name">
      <summary>Type name of the exception. Example: 'std::exception'.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppExceptionInformation.WinRTExceptionInfo">
      <summary>[Optional] Extended information about a Windows Runtime exception if it exists.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation">
      <summary>Extended information about a CPP exception thrown when you debug a Windows Runtime application.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.Create(System.String,System.String,System.String,System.String,System.Int32)">
      <summary>Creates a new DkmCppWinRTExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Description">[In] Basic non-restricted description of the exception.</param>
      <param name="RestrictedDescription">[In] Restricted description of the exception.</param>
      <param name="RestrictedReference">[In] Reference string that is used as a key to find restricted information when RestrictedReference is missing.</param>
      <param name="RestrictedCapabilitySid">[In] Security identifier of a missing capability if this exception was thrown for that reason.</param>
      <param name="ExceptionHR">[In] The failed HRESULT value that caused this exception to be thrown.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.Description">
      <summary>Basic non-restricted description of the exception.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.ExceptionHR">
      <summary>The failed HRESULT value that caused this exception to be thrown.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.RestrictedCapabilitySid">
      <summary>Security identifier of a missing capability if this exception was thrown for that reason.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.RestrictedDescription">
      <summary>Restricted description of the exception.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmCppWinRTExceptionInformation.RestrictedReference">
      <summary>Reference string that is used as a key to find restricted information when RestrictedReference is missing.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult">
      <summary>Result of an asynchronous DkmNativeModuleInstance.FindExportName call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmNativeModuleInstance.FindExportName.</summary>
      <param name="Address">[In,Optional] If the export was found in the specified module, this will contain the target address. Note that this instruction address object may be in a different module than the searched module. This can occur if the export was forwarded and the destination module is already loaded. If the destination module is not loaded, the export will be ignored.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult.Address">
      <summary>[Optional] If the export was found in the specified module, this will contain the target address. Note that this instruction address object may be in a different module than the searched module. This can occur if the export was forwarded and the destination module is already loaded. If the destination module is not loaded, the export will be ignored.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmNativeModuleInstance.FindExportName.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult">
      <summary>Result of an asynchronous DkmNativeInstructionAddress.FindNearestExport call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult.#ctor(System.String,System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmNativeInstructionAddress.FindNearestExport.</summary>
      <param name="ExportName">[In,Optional] Name of the export.</param>
      <param name="ByteOffset">[In] Byte offset from the start of the export.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult.ByteOffset">
      <summary>Byte offset from the start of the export.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmNativeInstructionAddress.FindNearestExport.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult.ExportName">
      <summary>[Optional] Name of the export.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata">
      <summary>DkmNativeAddressMetadata represents symbol based metadata about addresses. This includes if the address is a thunk, a prolog, or a trampoline.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata.AddressType">
      <summary>A value from the DkmNativeAddressType enumeration describing what this address is in the debuggee.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata.AddressTypeLength">
      <summary>The length of the current address type.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata.Create(Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType,Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressStepType,System.UInt32)">
      <summary>Create a new DkmNativeAddressMetadata object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="AddressType">[In] A value from the DkmNativeAddressType enumeration describing what this address is in the debuggee.</param>
      <param name="StepType">[In] A value from the DkmNativeAddressStepType enumeration describing how the native steppers should treat this address when a step encounters it.</param>
      <param name="AddressTypeLength">[In] The length of the thunk symbol in bytes if this is a thunk.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressMetadata.StepType">
      <summary>A value from the DkmNativeAddressStepType enumeration describing how the native steppers should treat this address when a step encounters it.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressStepType" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressStepType">
      <summary>DkmNativeAddressStepType describes how the native range steppers should treat this location. Used during step-in and step-out.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressStepType.None">
      <summary>No special treatment for this location.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressStepType.ContinueStep">
      <summary>Stopping at this address does not make sense. Continue stepping past it.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType">
      <summary>DkmNativeAddressType describes whether an address represents a special location in the debuggee instruction stream.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Native">
      <summary>The address has native symbols and is at a normal location.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.NativeNoSource">
      <summary>The address has native symbols but has no source information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Thunk">
      <summary>The address represents a thunk in the target process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Prolog">
      <summary>The address represents a prolog to a function in the target process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Epilog">
      <summary>The address represents an epilog to a function in the target process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Trampoline">
      <summary>The address represents a trampoline in the target process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.NonStopStepIntoCode">
      <summary>The address represents code telling debugger do not stop and step into for any call.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.NlgReturn">
      <summary>The address is at the label _NLG_Return or _NLG_Return2.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.Custom">
      <summary>The address represents a custom location in the debuggee.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.NoNativeSymbols">
      <summary>The address does not have native symbols.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.NativeNoStepInto">
      <summary>The address has native symbols but should not be stepped into.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Native.DkmNativeAddressType.CompilerGeneratedGlueCode">
      <summary>The address represents compiler-generated Windows Runtime glue code.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress">
      <summary>DkmNativeInstructionAddress is used for addresses that resolve to in a native module. This is used regardless as to if there are symbols for the module.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.Create(Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance,Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance,System.UInt32,Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction)">
      <summary>Create a new DkmNativeInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] Represents the native code executing in a target process.</param>
      <param name="ModuleInstance">[In] The module that contains the InstructionPointer.</param>
      <param name="RVA">[In] The RVA of InstructionPointer within Module.</param>
      <param name="CPUInstruction">[In,Optional] CPUInstruction provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.FindNearestExport(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Native.DkmFindNearestExportAsyncResult})">
      <summary>Finds the nearest module export from the specified instruction address. The export could be either a function or data export, although function exports are far more common. Because exports do not have address ranges, the specified address may not actually be associated with the returned export. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.FindNearestExport(System.Int32@)">
      <summary>Finds the nearest module export from the specified instruction address. The export could be either a function or data export, although function exports are far more common. Because exports do not have address ranges, the specified address may not actually be associated with the returned export.</summary>
      <returns>[Out,Optional] Name of the export.</returns>
      <param name="ByteOffset">[Out] Byte offset from the start of the export.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.GetSteppingCallSites(Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange[])">
      <summary>GetSteppingCallSites is called to obtain call sites reachable from an instruction. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmNativeSteppingCallSite[] specifies a call instruction and its target..</returns>
      <param name="SteppingRanges">[In] The stepping ranges to evaluate for call sites.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.ModuleInstance">
      <summary>The module that contains the InstructionPointer.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.RuntimeInstance">
      <summary>Represents the native code executing in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress.RVA">
      <summary>The RVA of InstructionPointer within Module.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionSymbol"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionSymbol.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.UInt32)">
      <summary>Create a new DkmNativeInstructionSymbol object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</param>
      <param name="RVA">[In] The RVA of InstructionPointer within Module.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionSymbol.GetNativeInstructionMetadataCallback(Microsoft.VisualStudio.Debugger.DkmInstructionAddress)">
      <summary>Returns address information to the native debug monitor.</summary>
      <returns>[Out,Optional] DkmNativeAddressMetadata represents symbol based metadata about addresses. This includes if the address is a thunk, a prolog, or a trampoline.</returns>
      <param name="InstructionAddress">[In,Optional] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionSymbol.RVA">
      <summary>The RVA of InstructionPointer within Module.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance">
      <summary>'DkmNativeModuleInstance' is used for modules which contain CPU code and are loaded by the Win32 loader.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.BaseAddress">
      <summary>The starting memory address of where the module is loaded. This value should always be valid.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.ClrHeaderStatus">
      <summary>Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the loaded module. This indicates which type of binary was loaded.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.Create(System.String,System.String,System.UInt64,Microsoft.VisualStudio.Debugger.DkmModuleVersion,Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId,Microsoft.VisualStudio.Debugger.DkmModuleFlags,Microsoft.VisualStudio.Debugger.DkmModuleMemoryLayout,System.UInt32,System.String,Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance,System.UInt64,System.UInt32,Microsoft.VisualStudio.Debugger.Clr.DkmClrHeaderStatus,System.Boolean,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,Microsoft.VisualStudio.Debugger.DkmModuleInstance.MinidumpInfo,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmNativeModuleInstance object instance. This method will send a ModuleInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] Short representation of the module name. For file-based modules, this is the file name and extension (ex: kernel32.dll).</param>
      <param name="FullName">[In] Fully qualified module name. For file-based modules, this is the full path of the module (ex: c:\windows\system32\kernel32.dll.</param>
      <param name="TimeDateStamp">[In] Date/Time of when the loaded module was built. This value is obtained from the IMAGE_NT_HEADERS of the loaded module. The unit of measurement is a FILETIME value, which is a 64-bit value that represents the number of 100-nanosecond intervals since January 1, 1601 (UTC).</param>
      <param name="Version">[In,Optional] File version information.</param>
      <param name="SymbolFileId">[In,Optional] Contains information that is required to locate symbols for this module. On Win32, this information is contained in the IMAGE_DEBUG_DIRECTORY.</param>
      <param name="Flags">[In] Flags which indicate traits of a DkmModuleInstance.</param>
      <param name="MemoryLayout">[In] Enumeration that indicates how a module is laid out in memory.</param>
      <param name="LoadOrder">[In] The integer count of the number of module instances that have loaded up to and including this module. Each runtime instance keeps track of its own load order count.</param>
      <param name="LoadContext">[In] String description of the context under which this module has been loaded.</param>
      <param name="RuntimeInstance">[In] Represents the native code executing in a target process.</param>
      <param name="BaseAddress">[In] The starting memory address of where the module is loaded. This value should always be valid.</param>
      <param name="Size">[In] The number of bytes in the module's memory region.</param>
      <param name="ClrHeaderStatus">[In] Contains information from the 'Flags' field of the IMAGE_COR20_HEADER of the loaded module. This indicates which type of binary was loaded.</param>
      <param name="IsDisabled">[In] Indicates if this module instance has been disabled. Disabled modules are largely ignored by the debugger. For native modules, the address range of the disabled module is treated as if it is unmapped. For CLR modules, any frames from these modules is hidden from the call stack.</param>
      <param name="Module">[In,Optional] The symbol handler's representation of a module (DkmModule) which is associated with this module instance. This value is at first null, and is assigned if symbols are associated with this module instance.</param>
      <param name="MinidumpInfo">[In,Optional] 'MinidumpInfo' is used to convey additional information about modules in a DkmProcess for a minidump.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmNativeModuleInstance instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.FindExportName(Microsoft.VisualStudio.Debugger.DkmWorkList,System.String,System.Boolean,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Native.DkmFindExportNameAsyncResult})">
      <summary>Finds the address of the specified named exported function (or data export). This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Name">[In] The export name to search for in the module's export table.</param>
      <param name="IgnoreDataExports">[In] If true, the implementation will ignore any export which is in non-executable memory.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.FindExportName(System.String,System.Boolean)">
      <summary>Finds the address of the specified named exported function (or data export).</summary>
      <returns>[Out,Optional] If the export was found in the specified module, this will contain the target address. Note that this instruction address object may be in a different module than the searched module. This can occur if the export was forwarded and the destination module is already loaded. If the destination module is not loaded, the export will be ignored.</returns>
      <param name="Name">[In] The export name to search for in the module's export table.</param>
      <param name="IgnoreDataExports">[In] If true, the implementation will ignore any export which is in non-executable memory.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.GetFunctionTableEntry(System.UInt64)">
      <summary>Obtain the function table entry for the passed address. The format of the engine depends on the debuggee architecture.</summary>
      <returns>[Out] The contents of the function table entry.</returns>
      <param name="Address">[In] The address to search the function table for. Normally, each entry contains a start and an end address. Implementations should return the entry whose address range contains the requested address.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.RuntimeInstance">
      <summary>Represents the native code executing in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmNativeModuleInstance.Size">
      <summary>The number of bytes in the module's memory region.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance">
      <summary>Represents the native code executing in a target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new runtime instance object from a debug monitor. This method must be called from the event thread when a debug monitor detects that a new runtime instance has loaded (for example, when the corresponding runtime .dll loads in the target process). This method will send a RuntimeInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process that is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="Id">[In] Identifies a DkmRuntimeInstance object in a process.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmNativeRuntimeInstance instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance.FindNativeModuleInstance(System.UInt64)">
      <summary>Finds a DkmNativeModuleInstance element within this DkmNativeRuntimeInstance. If no element that has the given input key is present, FindNativeModuleInstance will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="BaseAddress">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmNativeRuntimeInstance.GetNativeModuleInstances">
      <summary>Enumerates the DkmNativeModuleInstance elements of this DkmNativeRuntimeInstance object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation">
      <summary>Provides information about a Win32 exception which was raised in the target process.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation.Address">
      <summary>The address where the exception occurred.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.UInt32,Microsoft.VisualStudio.Debugger.Exceptions.DkmExceptionProcessingStage,System.UInt32,System.UInt64,System.UInt64,System.Collections.ObjectModel.ReadOnlyCollection{System.UInt64})">
      <summary>Create a new DkmWin32ExceptionInformation object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
      <param name="InstructionAddress">[In,Optional] Address where the exception occurred. This will always be present for C++ and Win32 exceptions. It may be missing from CLR exceptions or MDAs as these may originate from inside the runtime.</param>
      <param name="Code">[In] 32-bit integer code for the exception. For Win32 exceptions, this is the code passed to RaiseException (ex:EXCEPTION_ACCESS_VIOLATION). This value is zero for exception categories that identify exceptions by string (ex: CLR).</param>
      <param name="ProcessingStage">[In] The debugger receives notifications from the target process at various stages within exception processing (ex: exception thrown, exception unhandled).</param>
      <param name="ExceptionFlags">[In] The exception flags. This can be either zero to indicate a continuable exception, or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception.</param>
      <param name="ParentExceptionRecordAddress">[In] Address in the target process where the parent EXCEPTION_RECORD pointer can be found. This is ordinarily zero.</param>
      <param name="Address">[In] The address where the exception occurred.</param>
      <param name="ExceptionParameters">[In] Parameters passed when the exception was raised. These parameters may be passed from the Kernel as part of handling a hardware fault (ex: access violation), or they may be passed from kernel32!RaiseException for software exceptions.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation.ExceptionFlags">
      <summary>The exception flags. This can be either zero to indicate a continuable exception, or EXCEPTION_NONCONTINUABLE to indicate a noncontinuable exception.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation.ExceptionParameters">
      <summary>Parameters passed when the exception was raised. These parameters may be passed from the Kernel as part of handling a hardware fault (ex: access violation), or they may be passed from kernel32!RaiseException for software exceptions.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Native.DkmWin32ExceptionInformation.ParentExceptionRecordAddress">
      <summary>Address in the target process where the parent EXCEPTION_RECORD pointer can be found. This is ordinarily zero.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask">
      <summary>Represents either a managed TPL task or a native Concurrency Runtime task.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.Close">
      <summary>Closes a DkmTask object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmTask objects are automatically closed when their associated DkmTaskProvider object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.Create(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider,Microsoft.VisualStudio.Debugger.DkmThread,System.UInt64,System.UInt64,Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>This method is called to represent a task on a specific thread.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="TaskProvider">[In] Represents a task provider which is loaded into the target process.</param>
      <param name="Thread">[In,Optional] DkmThread represents a thread running in the target process.</param>
      <param name="TaskId">[In] Identifier for this particular instance.</param>
      <param name="ParentTaskId">[In] ID of parent task, 0 if there is no parent task.</param>
      <param name="StackSegment">[In] TODO.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmTask instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.GetChildTasks">
      <summary>Returns children tasks. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] TODO.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.GetSynchronizationObjects">
      <summary>TODO. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] TODO.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.GetTaskProperties(System.UInt32,System.Int32,Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties@)">
      <summary>Returns task properties. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Radix">[In] TODO.</param>
      <param name="Fields">[In] TODO.</param>
      <param name="Properties">[Out] TODO.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.ParentTaskId">
      <summary>ID of parent task, 0 if there is no parent task.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.StackSegment">
      <summary>TODO.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.TaskId">
      <summary>Identifier for this particular instance.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.TaskProvider">
      <summary>Represents a task provider which is loaded into the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask.Thread">
      <summary>[Optional] DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties">
      <summary>The properties of the task.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.#ctor(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32)">
      <summary>Initializes a new DkmTaskProperties value.</summary>
      <param name="Name">[In] Name of task.</param>
      <param name="Location">[In] </param>
      <param name="Property1">[In] </param>
      <param name="Property2">[In]</param>
      <param name="Property3">[In]</param>
      <param name="State">[In]</param>
      <param name="Flags">[In]</param>
      <param name="Fields">[In]</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Fields"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Flags"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Location"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Name">
      <summary>The name of task.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Property1"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Property2"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.Property3"></member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProperties.State"></member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider">
      <summary>Represents a task provider which is loaded into the target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.Close">
      <summary>Closes a DkmTaskProvider object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmTaskProvider objects are automatically closed when their associated DkmRuntimeInstance object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.Create(System.Guid,System.String,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>This method is called a task provider component to create a DkmTaskProvider object. It may be called in response to a call to InitializeTaskProviders call, or to a module/application domain load event. This method will send a TaskProviderCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="TaskProviderId">[In] Extensible GUID indicating the task provider which a task is from.</param>
      <param name="Name">[In] Task name e.g. Chore or Task.</param>
      <param name="RuntimeInstance">[In] The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmTaskProvider instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.FindTask(System.UInt64)">
      <summary>Find a DkmTask element within this DkmTaskProvider. If no element that has the given input key is present, FindTask will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="TaskId">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.GetPropertyNames">
      <summary>TODO. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] TODO.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.GetTasks(System.Boolean,System.UInt32,System.UInt32@,Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask[]@,System.UInt32@)">
      <summary>TODO. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="IsRoot">[In] TODO.</param>
      <param name="RequestCount">[In] Count of tasks requested.</param>
      <param name="ScheduledTaskCount">[Out] Number of scheduled tasks.</param>
      <param name="Items">[Out] TODO.</param>
      <param name="TaskEnumFlags">[Out] TODO.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.Name">
      <summary>Task name e.g. Chore or Task.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.RuntimeInstance">
      <summary>The DkmRuntimeInstance class represents an execution environment which is loaded into a DkmProcess and which contains code to be debugged.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.TaskProviderId">
      <summary>Extensible GUID indicating the task provider which a task is from.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProvider.UniqueId">
      <summary>Identifier for this particular instance.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProviderId">
      <summary>Extensible GUID indicating the task provider that a task is from.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProviderId.ConcurrencyRuntime">
      <summary>Task provider for Concurrency Runtime programming framework for C++.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskProviderId.TPL">
      <summary>Task provider for Task Parallel Library (TPL) for managed.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.#ctor(System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.Int32)">
      <summary>Initializes a new DkmTaskStackSegment value.</summary>
      <param name="AddressMin">[In] Trimmed minimum address on stack.</param>
      <param name="AddressMax">[In] Trimmed maximum address on stack.</param>
      <param name="AddressOriginalMin">[In] Original minimum address on stack.</param>
      <param name="AddressOriginalMax">[In] Original maximum address on stack.</param>
      <param name="ThreadId">[In] OS thread id.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.AddressMax">
      <summary>Trimmed maximum address on stack.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.AddressMin">
      <summary>Trimmed minimum address on stack.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.AddressOriginalMax">
      <summary>Original maximum address on stack.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.AddressOriginalMin">
      <summary>Original minimum address on stack.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskStackSegment.ThreadId">
      <summary>OS thread id.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject">
      <summary>Represents a synchronization object.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.Close">
      <summary>Closes a DkmTaskSynchronizationObject object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmTaskSynchronizationObject objects are automatically closed when their associated DkmTask object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.Create(Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask,Microsoft.VisualStudio.Debugger.DkmThread,System.String,System.String,System.String,System.Int32,System.Int32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmTaskSynchronizationObject object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Task">[In] Represents either a managed TPL task or a native Concurrency Runtime task.</param>
      <param name="OwningThread">[In,Optional] The owning thread.</param>
      <param name="DecimalName">[In,Optional] Name of the object, in base 10.</param>
      <param name="HexidecimalName">[In,Optional] Name of the object, in base 16.</param>
      <param name="Type">[In,Optional] TODO.</param>
      <param name="WaitTime">[In] TODO.</param>
      <param name="Timeout">[In] TODO.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmTaskSynchronizationObject instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.DecimalName">
      <summary>[Optional] Name of the object, in base 10.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.HexidecimalName">
      <summary>[Optional] Name of the object, in base 16.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.OwningThread">
      <summary>[Optional] The owning thread.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.Task">
      <summary>Represents either a managed TPL task or a native Concurrency Runtime task.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTask" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.Timeout">
      <summary>TODO.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.Type">
      <summary>[Optional] TODO.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.UniqueId">
      <summary>Identifier for this particular instance.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ParallelTasks.DkmTaskSynchronizationObject.WaitTime">
      <summary>TODO.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmOnScriptCriticalErrorAsyncResult">
      <summary>Result of an asynchronous DkmScriptRuntimeInstance.OnScriptCriticalError call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmOnScriptCriticalErrorAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmScriptRuntimeInstance.OnScriptCriticalError.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmOnScriptCriticalErrorAsyncResult" />.</returns>
      <param name="exception">[In] The exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmOnScriptCriticalErrorAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptBlockMappingInfo">
      <summary>Provides the content and position of a block of code in a mixed-content document (ex: .aspx file). This can be used to map the block from source to generated document.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptBlockMappingInfo.CodeText">
      <summary>Text of the code in the script block.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptBlockMappingInfo.Create(System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Creates a new DkmScriptBlockMappingInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="CodeText">[In] Text of the code in the script block.</param>
      <param name="TextSpan">[In] The text span of this script block.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptBlockMappingInfo.TextSpan">
      <summary>The text span of this script block.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument">
      <summary>Represents a document that is executing in a script runtime environment. For example, the JavaScript engine.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode,System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,System.String,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentFlags,Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmScriptDocument object instance. This method will send a ScriptDocumentTreeNodeCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The runtime that produced this container.</param>
      <param name="Parent">[In,Optional] Parent in the script document tree. This will be null for the root application container.</param>
      <param name="Title">[In] Title of the node.</param>
      <param name="Module">[In] The symbol container that owns this document.</param>
      <param name="Url">[In,Optional] URL of the script document. This may be null if the document has no URL.</param>
      <param name="FilePath">[In,Optional] File path (ex: c:\myfolder\file.js) of the script document. This will be null if the document has no URL or has a non-'file://' URL.</param>
      <param name="Flags">[In] Flag properties of a script document.</param>
      <param name="SourceProjectItem">[In,Optional] The project item that matches this document.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmScriptDocument instance. Pass null in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.FilePath">
      <summary>[Optional] File path (ex: c:\myfolder\file.js) of the script document. This will be null if the document has no URL or has a non-'file://' URL.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.Flags">
      <summary>Flags properties of a script document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.GetContent(System.Boolean,System.UInt32[]@)">
      <summary>Provides the current content of the specified document object.</summary>
      <returns>[Out] The current content of this document.</returns>
      <param name="EnableContentEvents">[In] If true, the script document provider should raise events when the content of this document changes. Passing true is equivalent to calling SetRaiseContentEvents(true). If false, the RaiseContentEvent state remains the same.</param>
      <param name="SectionDividers">[Out] For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this is the 1-based line numbers for where the section dividers should be drawn.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.GetProjectItemScriptBlocks">
      <summary>Queries the language service (IVsLanguageDebugInfoScript) to obtain script block information from the associated project item of the specified script document. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Set of script blocks returned from the language service.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.Module">
      <summary>The symbol container that owns this document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.OnContentInsert(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.String)">
      <summary>Raises a ScriptDocumentContentInsert event. The script document provider will only raise this event if events have been enabled for this document. This method may only be called by the component that created the object.</summary>
      <param name="Span">[In] The text span of the inserted text. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this must start on a new line, and at the end of a line immediately before a new section would begin.</param>
      <param name="NewText">[In] The new text content that is inserted into the document.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.OnContentRemove(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.Int32)">
      <summary>Raises a ScriptDocumentContentRemove event. The script document provider will only raise this event if events have been enabled for this document. This method may only be called by the component that created the object.</summary>
      <param name="Span">[In] The text span of the removed text. For aggregate documents (DkmScriptDocumentFlags.AggregateDocument is set), this must start at the begging of a line and correspond to a previously added section.</param>
      <param name="CharsToRemove">[In] Number of characters in the section to remove.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.SetRaiseContentEvents(System.Boolean)">
      <summary>Enables or disables raising events when the content of the document is changed. By default, documents do not generate content events. So this method should be called by any component that wants to receive content events. The script document manager maintains a count of the number of calls to enable content events, and will raise events whenever this count is greater than 0. Callers should make sure that SetRaiseContentEvents(false) is called only after a successful call to SetRaiseContentEvents(true). Content events are automatically disabled when the document is unloaded.</summary>
      <param name="Enable">[In] If true, content events should be enabled for this document. If false, the count of content event listeners is decremented. When the count reaches zero, no additional events will be sent.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.SetRaiseSymbolEvents(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Boolean,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Script.DkmSetRaiseSymbolEventsAsyncResult})">
      <summary>Enables or disables raising ScriptSymbolsUpdated when symbols in the document are changed. By default, documents do not generate symbol events. So this method should be called by any component that wants to receive symbol events. The script document manager maintains a count of the number of calls to enable symbol events, and will raise events whenever this count is greater than 0. Callers should make sure that SetRaiseSymbolEvents(false) is called only after a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when the document is unloaded. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine.</summary>
      <param name="WorkList">Work list to append the new work item to.</param>
      <param name="Enable">[In] If true, symbol events should be enabled for this document. If false, the count of symbol event listeners is decremented. When the count reaches zero, no additional events will be sent.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.SetRaiseSymbolEvents(System.Boolean)">
      <summary>Enables or disables raising ScriptSymbolsUpdated when symbols in the document are changed. By default, documents do not generate symbol events. So this method should be called by any component that wants to receive symbol events. The script document manager maintains a count of the number of calls to enable symbol events, and will raise events whenever this count is greater than 0. Callers should make sure that SetRaiseSymbolEvents(false) is called only after a successful call to SetRaiseSymbolEvents(true). Symbol events are automatically disabled when the document is unloaded.</summary>
      <param name="Enable">[In] If true, symbol events should be enabled for this document. If false, the count of symbol event listeners is decremented. When the count reaches zero, no additional events will be sent.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.SourceProjectItem">
      <summary>[Optional] The project item that matches this document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.TryResolve(Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId)">
      <summary>This method is called when a script document is created or when the project item path is set to try to bind breakpoints against the given script document. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] If the given script document matches the given source file id, this returns a DkmResolvedDocument for the match. Otherwise, null is returned.</returns>
      <param name="SourceFileId">[In] Identifies a source file and provides the information that a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.UniqueId">
      <summary>GUID that uniquely identifies this script document folder object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument.Url">
      <summary>[Optional] URL of the script document. This may be null if the document has no URL.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentFlags">
      <summary>Flag properties of a script document.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentFlags.AggregateDocument">
      <summary>Document represents a container which aggregated together many sub-documents. For JavaScript, this is use for 'eval code' and 'Function code' documents.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode">
      <summary>Represents a node in the 'Script Documents' virtual tree within solution explorer. Nodes may be either a virtual container, or they can be a document. In the latter case, they will be a DkmScriptDocument. Derived classes: DkmScriptDocument</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.Create(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode,System.String,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmScriptDocumentTreeNode object instance. This method will send a ScriptDocumentTreeNodeCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="RuntimeInstance">[In] The runtime which produced this container.</param>
      <param name="Parent">[In,Optional] Parent in the script document tree. This will be null for the root application container.</param>
      <param name="Title">[In] Title of the node.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmScriptDocumentTreeNode instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.Parent">
      <summary>[Optional] Parent in the script document tree. This will be null for the root application container.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.Process">
      <summary>DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmProcess" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.RuntimeInstance">
      <summary>The runtime which produced this container.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.Title">
      <summary>Title of the node.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.UniqueId">
      <summary>Guid which uniquely identifies this script document folder object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocumentTreeNode.Unload">
      <summary>Invoked by a script document provide to fire a ScriptDocumentTreeNodeUnload event. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress">
      <summary>DkmScriptInstructionAddress is used to represent an executable statement in a script-based runtime environment such the Microsoft JavaScript engine.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.AdditionalData">
      <summary>[Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.Create(Microsoft.VisualStudio.Debugger.DkmModuleInstance,Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,System.Int32,System.Int32,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte},Microsoft.VisualStudio.Debugger.DkmInstructionAddress.CPUInstruction)">
      <summary>Create a new DkmScriptInstructionAddress object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="ModuleInstance">[In,Optional] The module that contains this address. Addresses without a module cannot have symbols (even for custom addresses). CLR addresses will always have a module. Native addresses will not have a module if either the CPU jumped to an invalid address (ex: NULL), or if the CPU is executing dynamically-emitted code.</param>
      <param name="RuntimeInstance">[In] Represents a script-based execution environment executing in a target process.</param>
      <param name="Document">[In] Document that contains this instruction.</param>
      <param name="Revision">[In] Indicates the revision number which inserted the statement represented by this object. Typically, this will be zero for non-dynamic documents.</param>
      <param name="StartIndex">[In] Indicates the starting character index of this statement, relative to the start of revision which inserted this statement.</param>
      <param name="StatementLength">[In] Length of the statement (in characters).</param>
      <param name="AdditionalData">[In,Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</param>
      <param name="CPUInstruction">[In,Optional] CPUInstruction provides the address that the CPU will execute. This is always provided for native instructions. It may be provided for CLR or custom addresses depending on how the address object was created.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.Document">
      <summary>Document that contains this instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.Revision">
      <summary>Indicates the revision number which inserted the statement represented by this object. Typically, this will be zero for non-dynamic documents.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.RuntimeInstance">
      <summary>Represents a script-based execution environment executing in a target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.StartIndex">
      <summary>Indicates the starting character index of this statement, relative to the start of revision which inserted this statement.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress.StatementLength">
      <summary>Length of the statement (in characters).</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol">
      <summary>Represents an executable statement in a script-based runtime environment.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.AdditionalData">
      <summary>[Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.Guid,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,System.Int32,System.Int32,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmScriptInstructionSymbol object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers all of these to be identical, there will be only one module object.</param>
      <param name="RuntimeType">[In] The Runtime ID identifies the execution environment for a particular block of code. Runtime IDs are used by the dispatcher to decide which monitor to dispatch to. Note that the ordering of the runtime ID GUIDs is somewhat significant as this dictates which runtime receives the first shot during arbitration. Thus, if one wants to declare a new runtime instance that is built on the CLR, the runtime ID should be less than DkmRuntimeId.Clr.</param>
      <param name="Document">[In] Document that contains this instruction.</param>
      <param name="Revision">[In] Indicates the revision number that inserted the statement represented by this object. Typically, this will be zero for non-dynamic documents.</param>
      <param name="StartIndex">[In] Indicates the starting character index of this statement, relative to the start of revision that inserted this statement.</param>
      <param name="StatementLength">[In] Length of the statement (in characters).</param>
      <param name="AdditionalData">[In,Optional] Additional runtime-specific data associated with an address. This data will not be used when it compares addresses.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.Document">
      <summary>Document that contains this instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.GetNextSteppingAction(Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol,System.Boolean)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.Revision">
      <summary>Indicates the revision number that inserted the statement represented by this object. Typically, this will be zero for non-dynamic documents.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.StartIndex">
      <summary>Indicates the starting character index of this statement, relative to the start of revision which inserted this statement.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionSymbol.StatementLength">
      <summary>Length of the statement (in characters).</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance">
      <summary>Represents a script-based execution environment executing in a target process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.AbortExecutionOnResume">
      <summary>API which is called from break mode which tells the script runtime that execution should be aborted when resuming (BREAKRESUMEACTION_ABORT). This API requires an MSHTML v10+ target execution environment.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.Create(Microsoft.VisualStudio.Debugger.DkmProcess,Microsoft.VisualStudio.Debugger.DkmRuntimeInstanceId,System.Int32,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new runtime instance object from a debug monitor. This method must be called from the event thread when a debug monitor detects that a new runtime instance has loaded (for example, when the corresponding runtime dll loads in the target process). This method will send a RuntimeInstanceLoad event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Process">[In] DkmProcess represents a target process which is being debugged. The debugger debugs processes. Therefore, this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</param>
      <param name="Id">[In] Identifies a DkmRuntimeInstance object in a process.</param>
      <param name="LoadOrderIndex">[In] Index indicating the relative load order of this script runtime instance to other script runtime instances in the target process. The first runtime instance to load will be given an index of zero.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmScriptRuntimeInstance instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.GetRemoteDebugApplication">
      <returns>Returns <see cref="T:System.Object" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.LoadOrderIndex">
      <summary>Index indicating the relative load order of this script runtime instance to other script runtime instances in the target process. The first runtime instance to load will be given an index of zero.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.OnScriptCriticalError(Microsoft.VisualStudio.Debugger.DkmWorkList,System.String,System.Int32,System.String,Microsoft.VisualStudio.Debugger.Script.DkmScriptInstructionAddress,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Script.DkmOnScriptCriticalErrorAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptRuntimeInstance.OnScriptSymbolsUpdated(Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument[])">
      <summary>Raises the notification that one or more script documents have been updated.</summary>
      <param name="Documents">[In] Set of documents which have been updated.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem">
      <summary>The source project system item for a script document.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem.Create(System.String,System.Boolean)">
      <summary>Creates a new DkmScriptSourceProjectItem object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Path">[In] Moniker of the project item returned from MapDeployedURLToProjectItem.</param>
      <param name="IsGenerated">[In] True if the script document is expected to be a generated client-side document. Therefore, the project item cannot be directly mapped.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem.IsGenerated">
      <summary>True if the script document is expected to be a generated client-side document. Therefore, the project item cannot be directly mapped.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmScriptSourceProjectItem.Path">
      <summary>Moniker of the project item returned from MapDeployedURLToProjectItem. Project systems can plug into this through IsDocumentInProject.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptSymbolNextSteppingAction">
      <summary>Value returned from IDkmScriptSymbolCallback.GetNextSteppingAction which indicates the next action that the script DM should take.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptSymbolNextSteppingAction.CompleteStep">
      <summary>Step has landed at non-hidden code which maps to the same statement/line (depending on the IsSteppingByLine value) as where the step was originated.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptSymbolNextSteppingAction.SkipStatement">
      <summary>Step completed at a hidden statement, or at a statement which is still part of the same statement/line (depending on the IsSteppingByLine value) as the StartingInstruction. The debug monitor should step again. If it is a performing a step into, the debug monitor should resume with a step into. Otherwise a step over should be performed.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptSymbolNextSteppingAction.SkipMethodCall">
      <summary>Step completed at a hidden statement, or at a statement which is still part of the same statement/line (depending on the IsSteppingByLine value) as the StartingInstruction. The debug monitor should step again with a step over (even if the original operation was a step into).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Script.DkmScriptSymbolNextSteppingAction.SkipCurrentMethod">
      <summary>Step completed in a hidden method, or the rest of the method is hidden code. The debug monitor should step out of the method.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Script.DkmSetRaiseSymbolEventsAsyncResult">
      <summary>Result of an asynchronous DkmScriptDocument.SetRaiseSymbolEvents call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Script.DkmSetRaiseSymbolEventsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmScriptDocument.SetRaiseSymbolEvents.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmSetRaiseSymbolEventsAsyncResult" />.</returns>
      <param name="exception">[In] Exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Script.DkmSetRaiseSymbolEventsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmActivateAppPackageAsyncResult">
      <summary>Result of an asynchronous DkmTransportConnection.ActivateAppPackage call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmActivateAppPackageAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmTransportConnection.ActivateAppPackage.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmActivateAppPackageAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmActivateAppPackageAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings">
      <summary>Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings.Create(System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.Guid})">
      <summary>Creates a new DkmDebugLaunchSettings object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="OptionsString">[In] More information provided by a project system when it calls LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).</param>
      <param name="EngineFilter">[In,Optional] GUIDs for the set of debug engines being used to debug this process. This will be null if the process was started outside the debugger.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings.EngineFilter">
      <summary>[Optional] GUIDs for the set of debug engines being used to debug this process. This will be null if the process was started outside the debugger.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings.GetGPUAdditionalEnvironmentVariables(Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario)">
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings.OptionsString">
      <summary>More information provided by a project system when it calls LaunchDebugTargets through VsDebugTarget[2/3/etc].bstrOptions).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmLaunchedProcessInfo">
      <summary>DkmLaunchedProcessInfo is returned from APIs that start a process.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmLaunchedProcessInfo.#ctor(System.Int32,System.Int64,System.Int32)">
      <summary>Initializes a new DkmLaunchedProcessInfo value.</summary>
      <param name="ProcessId">[In] ID of the started process. Minidump implementations can set this to 0.</param>
      <param name="StartTime">[In] 64-bit date time value indicating when the process was started. The start time together with the ID and the computer where the process was started can uniquely identify a process. This can be set to 0 if this is unknown/invalid (ex: minidumps).</param>
      <param name="ThreadId">[In] ID of the first thread in the started process. Minidump implementations can set this to 0.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmLaunchedProcessInfo.ProcessId">
      <summary>ID of the started process. Minidump implementations can set this to 0.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmLaunchedProcessInfo.StartTime">
      <summary>64-bit date time value indicating when the process was started. The start time together with the ID and the computer where the process was started can uniquely identify a process. This can be set to 0 if this is unknown/invalid (ex: minidumps).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmLaunchedProcessInfo.ThreadId">
      <summary>ID of the first thread in the started process. Minidump implementations can set this to 0.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest">
      <summary>DkmProcessAttachRequest is used to describe the process that debugger should attach to.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.AttachToProcess">
      <summary>Causes the debug monitor to attach to the process. Before this method returns, the debug monitor must start an event thread (or reuse an existing event thread) and create the DkmProcess object on the event thread. Creating the DkmProcess object will send a process create event. Note that this method may only be called in response to the Visual Studio debugger package requesting an attach. Components that want to attach to another process should send a custom event to a Visual Studio package. From a package, an attach can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</returns>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_ATTACH_USER_CANCELED indicates that the attach to process operation was canceled. Returning this error will suppress most error messages. So it can be used in combination with DkmUserMessage.Post or DkmCustomMessage.SendToVsService as a way to provide custom failure messages to the user.</exception>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.Create(Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,System.String,System.Int32,System.Guid,Microsoft.VisualStudio.Debugger.Start.DkmStartMethod,System.Guid,Microsoft.VisualStudio.Debugger.DkmEngineSettings,Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings)">
      <summary>Create a new DkmProcessAttachRequest object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="Path">[In] Full path of the starting executable of the process.</param>
      <param name="ProcessId">[In] Id of the process which the debugger should attach to.</param>
      <param name="UniqueProcessId">[In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated by the port, and is used to uniquely identifies the process object.</param>
      <param name="StartMethod">[In] DkmStartMethod describes how the debug engine started debugging this process.</param>
      <param name="HostingProcessLanguage">[In,Optional] TODO.</param>
      <param name="EngineSettings">[In] Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</param>
      <param name="DebugLaunchSettings">[In] Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.DebugLaunchSettings">
      <summary>Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.EngineSettings">
      <summary>Contains the session-wide debug settings. There is one instance of this object per engine Guid (ex: one instance for COMPlusOnlyEng2, one instance for COMPlusNativeEng).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmEngineSettings" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.HostingProcessLanguage">
      <summary>[Optional] TODO.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.Path">
      <summary>Full path of the starting executable of the process.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.ProcessId">
      <summary>Id of the process which the debugger should attach to.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.StartMethod">
      <summary>DkmStartMethod describes how the debug engine started debugging this process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessAttachRequest.UniqueProcessId">
      <summary>Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated by the port, and is used to uniquely identifies the process object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterList">
      <summary>Holds the list of implementations of the IDkmProcessLaunchEnvironmentFilter interface that may be called by a component. This object is used to call these environment filters.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterList.Count">
      <summary>Returns the number of implementations of the IDkmProcessLaunchEnvironmentFilter interface that may be called through this object.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterList.Create">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterList" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterList.GetAdditionalEnvironmentVariables(System.Int32,Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings,Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario)">
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario">
      <summary>Enumeration of the scenarios where IDkmProcessLaunchEnvironmentFilter implementations are invoked.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario.ClassicLaunch">
      <summary>Application is about to be started with CreateProcess.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchEnvironmentFilterScenario.AppPackageLaunch">
      <summary>Windows app package or Windows Phone app package is about to be started.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags">
      <summary>Flag traits of a DkmProcessLaunchRequest.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags.None">
      <summary>No launch flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags.NoDebug">
      <summary>Launches the process without debugging (Ctrl+F5).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags.EnableENC">
      <summary>Launches the process with Edit and Continue enabled.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags.MergeEnvironment">
      <summary>Merges DkmProcessLaunchRequest.Environment with the environment block of the monitor. If this flag is missing and DkmProcessLaunchRequest.Environment is specified, the processed will be started with only environment variables from the input block.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest">
      <summary>DkmProcessLaunchRequest is used to describe the process that debugger should start.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Arguments">
      <summary>[Optional] Arguments to pass to the executable file on the command line.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Close">
      <summary>Closes a DkmProcessLaunchRequest object instance. This will release any resources associated with this object across all components. This includes resources across computer or managed/native marshaling boundaries. DkmProcessLaunchRequest objects are automatically closed when their associated DkmTransportConnection object is closed. This method may only be called by the component which created the object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Connection">
      <summary>This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Create(System.String,System.String,System.String,System.String,Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo,Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags,System.Int32,Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,Microsoft.VisualStudio.Debugger.DkmEngineSettings,Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Create a new DkmProcessLaunchRequest object instance. The caller is responsible for closing the created object after they have finished.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="FileName">[In] Path to the executable file to start.</param>
      <param name="Arguments">[In,Optional] Arguments to pass to the executable file on the command line.</param>
      <param name="WorkingDirectory">[In] The full path of the current directory for the process. The string can also specify a UNC path.</param>
      <param name="Environment">[In,Optional] A pointer to the environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process.</param>
      <param name="StartupInfo">[In,Optional] More information used to start a new process. This information is contained in the 'STARTUPINFO' structure in Win32.</param>
      <param name="ModeFlags">[In] Flag traits of a DkmProcessLaunchRequest.</param>
      <param name="Win32Flags">[In] Win32 process creation flags used when starting the process. For example, CREATE_NO_WINDOW (0x08000000) could be passed to disable creating the console window. The following flags should never be passed, and the behavior is undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS, CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM, CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.</param>
      <param name="Connection">[In] This represents a connection between the monitor and the IDE. It can be either a local connection if the monitor is running in the same process as the IDE, or it can be a remote connection. In the monitor process, there is only one connection.</param>
      <param name="EngineSettings">[In,Optional] Settings to use when starting this executable under the debugger.</param>
      <param name="DebugLaunchSettings">[In] Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmProcessLaunchRequest instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.DebugLaunchSettings">
      <summary>Settings supplied during a start debugging operation from a project system or other caller of LaunchDebugTargets (or various other start debugging APIs).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmDebugLaunchSettings" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.EngineSettings">
      <summary>[Optional] Settings to use when starting this executable under the debugger. This may be omitted if the process is not being started under the debugger (ex: Ctrl-F5).</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmEngineSettings" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Environment">
      <summary>[Optional] A pointer to the environment block for the new process. If this parameter is NULL, the new process uses the environment of the calling process. An environment block consists of a null-terminated block of null-terminated strings. Each string is in the following form: 'name=value\0'. Because the equal sign is used as a separator, it must not be used in the name of an environment variable.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.FileName">
      <summary>Path to the executable file to launch.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.LaunchDebuggedProcess">
      <summary>Causes the debug monitor to create a new process under the debugger. The process should be left suspended until ResumeDebuggedProcess is called. The debug monitor must wait for ResumeDebuggedProcess before creating the DkmProcess object because it needs the UniqueProcessId value from the AD7 Layer. Note that this method may only be called in response to the Visual Studio debugger package requesting a launch. Components that want to launch another process under the debugger should send a custom event to a Visual Studio package. From a package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.LaunchProcess(System.Int32)">
      <summary>This API is remote-able version of the Win32 CreateProcess API. The implementation will merge the environment block, process command line redirection and launch the process. Unless the NoDebug flag is used, CreateProcess will use the DEBUG_PROCESS flag when it creates the Win32 process.</summary>
      <returns>[Out] DkmLaunchedProcessInfo is returned from APIs that launch a process.</returns>
      <param name="AdditionalWin32Flags">[In] Win32 process creation flags additionally to those found in the DkmProcessLaunchRequest.Win32Flags. This is often used to pass DEBUG_PROCESS (0x1), DEBUG_ONLY_THIS_PROCESS (0x2), or CREATE_SUSPENDED (0x4).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.ModeFlags">
      <summary>Flag traits of a DkmProcessLaunchRequest.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchModeFlags" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.ResumeDebuggedProcess(System.Guid)">
      <summary>Causes the debug monitor to resume a started process and create the DkmProcess object. The DkmProcess object will be created on the event thread and creating the object will send a process create event. Note that this method may only be called in response to the Visual Studio debugger package requesting a launch. Components that want to launch another process under the debugger should send a custom event to a Visual Studio package. From a package, a launch can be requested through the IVsDebugger.LaunchDebugTargets API.</summary>
      <returns>[Out] DkmProcess represents a target process which is being debugged. The debugger debugs processes, so this is the basic unit of debugging. A DkmProcess can represent a system process or a virtual process such as minidumps.</returns>
      <param name="UniqueProcessId">[In] Value to assign to the 'DkmProcess.UniqueId' field. This Guid is generated by the port, and is used to uniquely identifies the process object.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.ResumeProcess">
      <summary>This API is used to resume a process which was started from CreateProcess with the LaunchSuspended flag set to true.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.StartupInfo">
      <summary>[Optional] More information used to launch a new process. This information is contained in the 'STARTUPINFO' structure in Win32.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.UniqueId">
      <summary>UniqueId uniquely identifies the launch request.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.Win32Flags">
      <summary>Win32 process creation flags used when starting the process. For example, CREATE_NO_WINDOW (0x08000000) could be passed to disable creating the console window. The following flags should never be passed, and the behavior is undefined if they are present: DEBUG_PROCESS, DEBUG_ONLY_THIS_PROCESS, CREATE_SUSPENDED, EXTENDED_STARTUPINFO_PRESENT, CREATE_SEPARATE_WOW_VDM, CREATE_SHARED_WOW_VDM, and CREATE_UNICODE_ENVIRONMENT.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessLaunchRequest.WorkingDirectory">
      <summary>The full path of the current directory for the process. The string can also specify a UNC path.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo">
      <summary>More information used to start a new process. This information is contained in the 'STARTUPINFO' structure in Win32.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.Create(System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt16,System.UInt64,System.UInt64,System.UInt64)">
      <summary>Create a new DkmProcessStartupInfo object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Desktop">[In,Optional] The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For more information, see Thread Connection to a Desktop.</param>
      <param name="Title">[In,Optional] For console processes, this is the title displayed in the title bar if a new console window is created. If NULL, the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or console processes that do not create a new console window.</param>
      <param name="X">[In] If 'Flags' specifies STARTF_USEPOSITION, this member is the x offset of the upper-left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.</param>
      <param name="Y">[In] If 'Flags' specifies STARTF_USEPOSITION, this member is the y offset of the upper-left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.</param>
      <param name="XSize">[In] If 'Flags' specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.</param>
      <param name="YSize">[In] If 'Flags' specifies STARTF_USESIZE, this member is the height of the window if a new window is created, in pixels. Otherwise, this member is ignored.</param>
      <param name="XCountChars">[In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.</param>
      <param name="YCountChars">[In] If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.</param>
      <param name="FillAttribute">[In] If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.</param>
      <param name="Flags">[In] 'STARTF_*' flags for this request. More information can be found in Win32 documentation under 'STARTUPINFO.dwFlags'.</param>
      <param name="ShowWindow">[In] If 'Flags' specifies STARTF_USESHOWWINDOW, this member can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.</param>
      <param name="StdInputHandle">[In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard input handle for the process. Otherwise, this value should be zero.</param>
      <param name="StdOutputHandle">[In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard output handle for the process. Otherwise, this value should be zero.</param>
      <param name="StdErrorHandle">[In] If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard error handle for the process. Otherwise, this value should be zero.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.Desktop">
      <summary>[Optional] The name of the desktop, or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For more information, see Thread Connection to a Desktop.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.FillAttribute">
      <summary>If 'Flags' specifies STARTF_USEFILLATTRIBUTE, this member is the initial text and background colors if a new console window is created in a console application. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.Flags">
      <summary>'STARTF_*' flags for this request. More information can be found in Win32 documentation under 'STARTUPINFO.dwFlags'.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.ShowWindow">
      <summary>If 'Flags' specifies STARTF_USESHOWWINDOW, this member can be any of the values that can be specified in the nCmdShow parameter for the ShowWindow function, except for SW_SHOWDEFAULT. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.StdErrorHandle">
      <summary>If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard error handle for the process. Otherwise, this value should be zero.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.StdInputHandle">
      <summary>If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard input handle for the process. Otherwise, this value should be zero.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.StdOutputHandle">
      <summary>If 'Flags' specifies STARTF_USESTDHANDLES, this member is the standard output handle for the process. Otherwise, this value should be zero.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.Title">
      <summary>[Optional] For console processes, this is the title displayed in the title bar if a new console window is created. If NULL, the name of the executable file is used as the window title instead. This parameter must be NULL for GUI or console processes that do not create a new console window.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.X">
      <summary>If 'Flags' specifies STARTF_USEPOSITION, this member is the x offset of the upper-left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.XCountChars">
      <summary>If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer width, in character columns. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.XSize">
      <summary>If 'Flags' specifies STARTF_USESIZE, this member is the width of the window if a new window is created, in pixels. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.Y">
      <summary>If 'Flags' specifies STARTF_USEPOSITION, this member is the y offset of the upper-left corner of a window if a new window is created, in pixels. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.YCountChars">
      <summary>If 'Flags' specifies STARTF_USECOUNTCHARS, if a new console window is created in a console process, this member specifies the screen buffer height, in character rows. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Start.DkmProcessStartupInfo.YSize">
      <summary>If 'Flags' specifies STARTF_USESIZE, this member is the height of the window if a new window is created, in pixels. Otherwise, this member is ignored.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod">
      <summary>DkmStartMethod describes how the debug engine started debugging this process.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod.Launch">
      <summary>Process was launched under the debugger.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod.Attach">
      <summary>Process was launched outside the debugger and the debugger attached.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod.AttachForSuspendedLaunch">
      <summary>Process was launched suspended by the project system or SDM. Then the engine was asked to attach to the process when the process was still at the initial suspension point. This is used for Low-rights Internet Explorer (LoRIE).</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Start.DkmStartMethod.AttachForHostingLaunch">
      <summary>Hosting process was launched by the project system and then the project system asked the debugger to attach to the process.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmLanguageStepIntoFlags">
      <summary>Flags that describe how to continue with a Step-Into action.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmLanguageStepIntoFlags.None">
      <summary>The function stepping should not deviate from default.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmLanguageStepIntoFlags.NoStepInto">
      <summary>The function should not be stepped into.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmNativeSteppingCallSite">
      <summary>DkmNativeSteppingCallSite specifies a call instruction and its target..</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmNativeSteppingCallSite.CallSite">
      <summary>The address of the call instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmNativeSteppingCallSite.CallTarget">
      <summary>[Optional] The address of the instruction that would be called by the call instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmNativeSteppingCallSite.CallTargetAddress">
      <summary>[Optional] For indirect calls only, the address being dereferenced by the call instruction.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmNativeSteppingCallSite.Create(Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress,Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress,Microsoft.VisualStudio.Debugger.Native.DkmNativeInstructionAddress)">
      <summary>Create a new DkmNativeSteppingCallSite object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="CallSite">[In] The address of the call instruction.</param>
      <param name="CallTarget">[In,Optional] The address of the instruction that would be called by the call instruction.</param>
      <param name="CallTargetAddress">[In,Optional] For indirect calls only, the address being dereferenced by the call instruction.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest">
      <summary>Represents a request to single step a thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.ClearSingleStep">
      <summary>Disables single step on a thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.ClearTempBreak">
      <summary>Clears temporary breakpoint in stepping on a thread.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.Create(System.Guid,Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Creates a new DkmSingleStepRequest object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceId">[In] Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components might be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example an internal breakpoint used for stepping).</param>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.EnableSingleStep">
      <summary>Enables single step on a thread. When the single step is finished, the SingleStepComplete event should be sent. The single step should reset after completion. Implementers should send one single step complete event per instance of DkmSingleStepRequest that they receive. Callers must make a new request to single-step after this DkmSingleStepRequest is completed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.EnableTempBreak(System.Int64[])">
      <summary>Enables temporary breakpoint in stepping on a thread. This resembles single step except one or more instructions are advanced. When breakpoint is hit, step complete event is sent.</summary>
      <param name="TempBreakInstructions">[In] The instruction offset of temporary breakpoints to set.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.OnGPUSingleStepComplete(Microsoft.VisualStudio.Debugger.DkmThread)">
      <summary>Raises a GPUSingleStepComplete event. Components that implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="Thread">[In] DkmThread represents a thread running in the target process.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.OnSingleStepComplete">
      <summary>Raises a SingleStepComplete event. Components that implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components might be creating instances of a class. For example, source ids can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example, an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSingleStepRequest.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason">
      <summary>DkmStepArbitrationReason the reason step arbitration is occurring.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.NewStep">
      <summary>The stepping manager is looking for a runtime to start a new step.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.UnknownModule">
      <summary>The instruction pointer has landed in a location not in a known DkmModuleInstance.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.NoSymbols">
      <summary>The instruction pointer has landed in a location in a known DkmModuleInstance without symbols.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.TransitionModule">
      <summary>The instruction pointer has landed in a location in a DkmModuleInstance marked as a transition module.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.ExitRuntime">
      <summary>The current runtime instance has just finished stepping through a known exit from its runtime. The instruction pointer should be on the first instruction of the next runtime's entry point.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.EnterRuntime">
      <summary>Another runtime instance has detected that the instruction pointer has hit an entry point into its runtime. This is only used after a call to StepControlRequested that return true.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.NoSource">
      <summary>The instruction pointer has landed at a location in a known module but without source information.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.ExceptionHandlerFound">
      <summary>An exception unwind was in flight and a handler was found. If a runtime's exception model can be used by other runtimes, stepping arbitration should be performed. For instance, CLR exceptions use native SEH exceptions. Therefore, during a managed step, if an exception is thrown and a handler is found, native will receive its handler found notification. However, native should not take control of that step. Managed should listen for stepping arbitration with ExceptionHandlerFound as its reason and finish stepping to the managed catch block.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.InstructionLevelOverride">
      <summary>Used by the stepping manager to override a line or statement step with an instruction level step. This is only passed to the native runtime instance if no controlling runtime instance was found during initial stepping arbitration.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason.Unknown">
      <summary>A runtime instance asked for stepping arbitration for an unknown reason.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind">
      <summary>DkmStepKind describes how to step the thread when the Step Method is called.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind.Into">
      <summary>Step the thread into calls.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind.Over">
      <summary>Step the thread over calls.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind.Out">
      <summary>Step the thread out of the current frame.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind.StepIntoSpecific">
      <summary>Step into specific request.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper">
      <summary>DkmStepper represents a request to step a thread. It facilitates shared object lifetime between the various runtime debug monitors that participate in stepping.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.BeforeEnable"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.CancelStepper(Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.Close">
      <summary>Closes the stepper object. This should be closed by components when the stepper has finished, such as when a step complete event is suppressed, or if the stepper does not initialize. Steppers will be implicitly closed if their thread exits or the debugger is stopped. They will be closed by the stepping manager if a different user-level execution request is issued. DkmStepper objects are automatically closed when their associated DkmThread object is closed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.CodePath">
      <summary>[Optional] If StepKind is StepIntoSpecific, specifies which call we are stepping into. Otherwise it is NULL.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.Create(Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,System.UInt64,Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind,Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit,System.Guid,Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper,Microsoft.VisualStudio.Debugger.DkmDataItem)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.CrossThreadParent">
      <summary>[Optional] If a new stepper is created by using OnCrossThreadStepArbitration, the stepping manager will set this field to make is easy to get back to the original stepper if the cross thread step fails or must fallback.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.Enable(System.Boolean)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.FrameBase">
      <summary>The frame base of the first frame at the start of the step. This value will be MAXUINT64 if the StartingAddress was not specified.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.GetControllingRuntimeInstance">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmRuntimeInstance" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.OnCrossThreadStepArbitration(Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance,Microsoft.VisualStudio.Debugger.DkmThread,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Stepping.DkmStepper@)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.OnReturnValues(System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Evaluation.DkmRawReturnValue},System.Boolean)">
      <summary>Raises a ReturnValues event. Components that implement the event sync interface will receive the event notification. Control will return as soon as all components have been notified.</summary>
      <param name="ReturnValues">[In,Optional] DkmRawReturnValues recorded.</param>
      <param name="LastValueInCurrentContext">[In] If true, it is valid to use the current thread context to evaluate the last return value. This is true only in the case immediately after it processes the return instruction, and so should only be set if raising this event immediately before, and on the same thread, as the StepComplete event.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.OnStepArbitration(Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.OnStepComplete(Microsoft.VisualStudio.Debugger.DkmThread,System.Boolean)">
      <summary>Raises a StepComplete event. Components that implement the event sync interface will receive the event notification. This method will enqueue the event and control will immediately return to the caller.</summary>
      <param name="Thread">[In] The thread the step actually finished on. Normally, this is the same as the thread in DkmStepper, but in some scenarios, it could be different.</param>
      <param name="HasException">[In] Contains true if the source runtime instance can determine that an exception is in flight on the stepping thread. Currently, only managed runtime instances ever set this. This is used to quickly determine whether exception-specific logic should apply without making another network round-trip.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.SourceId">
      <summary>Identifies the source of an object. SourceIds are used to enable filtering in scenarios when multiple components might be creating instances of a class. For example, source IDs can be used to determine whether a breakpoint comes from the AD7 AL (ex: user breakpoint, or other breakpoint visible at the SDM level) instead of a breakpoint that may be created by another component (for example an internal breakpoint used for stepping).</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.StartingAddress">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.StepControlRequested(Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.StepKind">
      <summary>DkmStepKind describes how to step the thread when the Step method is called.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepKind" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.StepUnit">
      <summary>DkmStepUnit describes the precision of the step when the Step method is called.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.System#IDisposable#Dispose"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.TakeStepControl(System.Boolean,Microsoft.VisualStudio.Debugger.Stepping.DkmStepArbitrationReason,Microsoft.VisualStudio.Debugger.DkmRuntimeInstance)"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.Thread">
      <summary>DkmThread represents a thread running in the target process.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmThread" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmStepper.UniqueId">
      <summary>GUID that uniquely identifies this DkmStepper.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath">
      <summary>Represents a location that a user can step to from the current location.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath.AdditionalData">
      <summary>[Optional] Additional data about the code path. Meaning is implementation specific.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath.CodePathOffset">
      <summary>For managed, this represents the MSIL offset to call instruction. For native, it is the RVA of the call instruction.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath.Create(System.String,System.Int32,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Creates a new DkmSteppingCodePath object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Name">[In] The string that represents a possible code path that the user can select.</param>
      <param name="CodePathOffset">[In] For managed, this represents the MSIL offset to call instruction. For native, it is the RVA of the call instruction.</param>
      <param name="EndOffset">[In] Represents the end offset for the current step unit.</param>
      <param name="AdditionalData">[In,Optional] Additional data about the code path. Meaning is implementation specific.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath.EndOffset">
      <summary>Represents the end offset for the current step unit.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePath.Name">
      <summary>The string that represents a possible code path that the user can select.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource">
      <summary>Object used for filtering for step into specific.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage)">
      <summary>Creates a new DkmSteppingCodePathSource object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="InstructionSymbol">[In] The instruction symbol at the location to begin looking for step-into specific code paths.</param>
      <param name="InstructionAddress">[In] The instruction address at the location to begin looking for step-into specific code paths.</param>
      <param name="Language">[In] The language of the location to begin looking for step-into specific code paths.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource.GetCodePaths(Microsoft.VisualStudio.Debugger.CallStack.DkmStackWalkFrame,Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit)">
      <summary>GetCodePaths is called to step into specific targets. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] DkmSteppingCodePath[] represents a location that the user can step to from the current location.</returns>
      <param name="StackFrame">[In] Specifies the current frame.</param>
      <param name="StepUnit">[In] Specifies whether code paths are for current statement or line.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource.InstructionAddress">
      <summary>The instruction address at the location to begin looking for step-into specific code paths.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DkmInstructionAddress" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource.InstructionSymbol">
      <summary>The instruction symbol at the location to begin looking for step-into specific code paths.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Stepping.DkmSteppingCodePathSource.Language">
      <summary>The language of the location to begin looking for step-into specific code paths.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmLanguage" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit">
      <summary>DkmStepUnit describes the precision of the step when the Step method is called.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit.Statement">
      <summary>Step the thread to the next statement.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit.Line">
      <summary>Step the thread to the next line.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Stepping.DkmStepUnit.Instruction">
      <summary>Step the thread to the next instruction.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmCodeViewCompilerId">
      <summary>DkmCodeViewCompilerId is used to translate information that is in the S_COMPILE* code view records into a DkmCompilerId. This allows the debugger to load an appropriate expression evaluator for a stack frame. Symbol providers may obtain this collection through DkmEngineSettings. Expression evaluators may add more entries to this collection by having their setup add sub key(s) to the '%VSRegistryRoot%\Debugger\CodeView Compilers' registry key.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmCodeViewCompilerId.#ctor(System.Byte,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId)">
      <summary>Initialize a new DkmCodeViewCompilerId value.</summary>
      <param name="LanguageEnumeration">[In] Language enumeration value which is in the code view record. For example, CV_CFL_CXX is used for C++.</param>
      <param name="CompilerName">[In] Name string in the code view record. '*' may be used to match against any name string.</param>
      <param name="CompilerId">[In] CompilerId (Vendor/Language Guid pair) to map the LanguageEnumeration/CompilerName to.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmCodeViewCompilerId.CompilerId">
      <summary>CompilerId (Vendor/Language Guid pair) to map the LanguageEnumeration/CompilerName to.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmCodeViewCompilerId.CompilerName">
      <summary>Name string in the code view record. '*' may be used to match against any name string.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmCodeViewCompilerId.LanguageEnumeration">
      <summary>Language enumeration value which is in the code view record. For example, CV_CFL_CXX is used for C++.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmCustomSymbolFileId">
      <summary>The custom debug information is populated when a module loads and the debug monitor does not understand the content of the debug directory.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmCustomSymbolFileId.Create(System.Guid,System.Int32,System.Collections.ObjectModel.ReadOnlyCollection{System.Byte})">
      <summary>Create a new DkmCustomSymbolFileId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SymbolProviderId">[In] TODO.</param>
      <param name="Type">[In] 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example, IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete listing.</param>
      <param name="Data">[In] Raw bytes from the PE file header.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmCustomSymbolFileId.Data">
      <summary>Raw bytes from the PE file header.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmCustomSymbolFileId.Type">
      <summary>'Type' value from the IMAGE_DEBUG_DIRECTORY. For example, IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete listing.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength">
      <summary>Indicates how strong of a match there was between the DkmDocumentQuery and the resulting DkmResolvedDocument.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength.FileName">
      <summary>Document matched on file name and extension, but not on any part of the path, or on checksum.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength.SubPath">
      <summary>Document matched on file name and at least one level of directory name, but not the full path nor the checksum.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength.FullPath">
      <summary>Document matched on full path but not on checksum.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength.Checksum">
      <summary>Document matched on checksum value and also to at least a file name match.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength.ExactURL">
      <summary>Input path represented a URL for a dynamic document and the resulting document exactly matched this query. This value is currently never returned from the Microsoft PDB symbol provider but is reserved for future use.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmDynamicSymbolFileId">
      <summary>This is used for in-memory dynamic modules when doing managed debugging.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmDynamicSymbolFileId.Create(System.Guid)">
      <summary>Create a new DkmDynamicSymbolFileId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SymbolProviderId">[In] TODO.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings">
      <summary>Contains the symbol path collection and the cache path.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.Create(System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.Collections.ObjectModel.ReadOnlyCollection{System.String},System.Boolean,System.Boolean)">
      <summary>Creates a new DkmEngineSymbolSettings object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SymbolPaths">[In] A collection of the paths to search for symbols.</param>
      <param name="SymbolCachePath">[In] The path of the symbol cache.</param>
      <param name="IncludeList">[In] A collection of modules to include when manual symbol loading is enabled.</param>
      <param name="ExcludeList">[In] A collection of modules to exclude when automatic symbol loading is enabled.</param>
      <param name="ManualLoading">[In] True if manual symbol loading is enabled. False otherwise.</param>
      <param name="LoadAdjacentSymbols">[In] True if all symbols adjacent to the matching module or at the path specified in the binary should be loaded regardless of include/exclude status.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.ExcludeList">
      <summary>A collection of modules to exclude when automatic symbol loading is enabled.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.IncludeList">
      <summary>A collection of modules to include when manual symbol loading is enabled.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.LoadAdjacentSymbols">
      <summary>True if all symbols adjacent to the matching module or at the path specified in the binary should be loaded regardless of include/exclude status.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.ManualLoading">
      <summary>True if manual symbol loading is enabled. False otherwise.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.SymbolCachePath">
      <summary>The path of the symbol cache.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmEngineSymbolSettings.SymbolPaths">
      <summary>A collection of the paths to search for symbols.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult">
      <summary>Result of an asynchronous DkmModule.FindDocuments call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmModule.FindDocuments.</summary>
      <param name="Documents">[In] A collection of the documents that matched the query.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmModule.FindDocuments.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult.Documents">
      <summary>[Optional] A collection of the documents that matched the query.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult">
      <summary>Result of an asynchronous DkmResolvedDocument.FindSymbols call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol[],Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmResolvedDocument.FindSymbols.</summary>
      <param name="InstructionSymbols">[In] The found instruction symbols which are in the specified text span.</param>
      <param name="SymbolLocation">[In] The source location of each returned instruction symbol. The length of this array should be the same of the returned instruction symbol array.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmResolvedDocument.FindSymbols.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed. E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document. E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan could not be mapped to a location in the specified script document. E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file loaded by the target process does not match the provided Text.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult.InstructionSymbols">
      <summary>[Optional] The found instruction symbols which are in the specified text span.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult.SymbolLocation">
      <summary>[Optional] The source location of each returned instruction symbol. The length of this array should be the same of the returned instruction symbol array.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult">
      <summary>Result of an asynchronous DkmModule.GetFunctionInfo call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmRVASizePair[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmModule.GetFunctionInfo.</summary>
      <param name="Results">[In] The RVA / size pairs from the query.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmModule.GetFunctionInfo.</summary>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult.Results">
      <summary>The RVA / size pairs from the query.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult">
      <summary>Result of an asynchronous DkmModule.GetMethodSymbolStoreData call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmModule.GetMethodSymbolStoreData.</summary>
      <param name="Scopes">[In] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmModule.GetMethodSymbolStoreData.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult" />.</returns>
      <param name="exception">[In] Exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult.Scopes">
      <summary>DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult">
      <summary>Result of an asynchronous DkmModule.GetMethodSymbolStoreDataPreRemap call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult.#ctor(System.Int32,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmModule.GetMethodSymbolStoreDataPreRemap.</summary>
      <param name="RemapToken">[In] Method token after the Remap.</param>
      <param name="Scopes">[In] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmModule.GetMethodSymbolStoreDataPreRemap.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult.RemapToken">
      <summary>Method token after the Remap.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult.Scopes">
      <summary>DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodScopeData" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult">
      <summary>Result of an asynchronous DkmInstructionSymbol.GetSourcePosition call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult.#ctor(System.Boolean,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionSymbol.GetSourcePosition.</summary>
      <param name="StartOfLine">[In] True if this address is the first address in the line's range. False otherwise.</param>
      <param name="SourcePosition">[In,Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionSymbol.GetSourcePosition.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult.SourcePosition">
      <summary>[Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult.StartOfLine">
      <summary>True if this address is the first address in the line's range. False otherwise.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult">
      <summary>Result of an asynchronous DkmInstructionSymbol.GetSourcePositionCallback call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult.#ctor(System.Boolean,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionSymbol.GetSourcePositionCallback.</summary>
      <param name="StartOfLine">[In] True if this address is the first address in the line's range. False otherwise.</param>
      <param name="SourcePosition">[In,Optional] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionSymbol.GetSourcePositionCallback.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult.SourcePosition">
      <summary>[Optional] Source code position which corresponds to a code element. The could represent a location which has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult.StartOfLine">
      <summary>True if this address is the first address in the line's range. False otherwise.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult">
      <summary>Result of an asynchronous DkmModule.GetTokenSymbolStoreAttribute call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult.#ctor(System.Byte[])">
      <summary>Creates a new result structure to hold the output from a successful call to DkmModule.GetTokenSymbolStoreAttribute.</summary>
      <param name="Data">[In] The value of the requested symbol store attribute.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmModule.GetTokenSymbolStoreAttribute.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult.Data">
      <summary>The value of the requested symbol store attribute.</summary>
      <returns>Returns <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult">
      <summary>Result of an asynchronous DkmInstructionSymbol.GetUserCodeSourcePositionCallback call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionSymbol.GetUserCodeSourcePositionCallback.</summary>
      <param name="SourcePosition">[In,Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionSymbol.GetUserCodeSourcePositionCallback.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult.SourcePosition">
      <summary>[Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult">
      <summary>Result of an asynchronous DkmInstructionSymbol.HasLineInfo call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult.#ctor(System.Boolean)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionSymbol.HasLineInfo.</summary>
      <param name="Result">[In] True if there is line information for this location.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionSymbol.HasLineInfo.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult.Result">
      <summary>True if there is line information for this location.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmImageDebugDirectoryFormat">
      <summary>Windows .dlls/.exes contain a section for debugging information. Inside this section there are zero or more IMAGE_DEBUG_DIRECTORY structures, and inside each of these structures there is a 32-bit 'Type' field that indicates the format of the information in the debug directory. DkmImageDebugDirectoryFormat is used to map from this 'Type' value to the symbol provider that is used to handle this kind of debugging information. The debugger initializes a collection of DkmImageDebugDirectoryFormat structs on startup by reading the '%VSRegistryRoot%\Debugger\Image Debug Directory Formats' registry keys.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmImageDebugDirectoryFormat.#ctor(System.Int32,System.Guid)">
      <summary>Initializes a new DkmImageDebugDirectoryFormat value.</summary>
      <param name="TypeValue">[In] 'Type' value from the IMAGE_DEBUG_DIRECTORY. For example, IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete listing.</param>
      <param name="SymbolProvider">[In] Symbol provider ID to use for this.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmImageDebugDirectoryFormat.SymbolProvider">
      <summary>Symbol provider ID to use for this.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmImageDebugDirectoryFormat.TypeValue">
      <summary>'Type' value from the IMAGE_DEBUG_DIRECTORY. For example, IMAGE_DEBUG_TYPE_CODEVIEW (2) is used for PDB files. See winnt.h for a complete listing.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol">
      <summary>Represents a method in the target process. Derived classes: DkmClrInstructionSymbol, DkmCustomInstructionSymbol, DkmNativeInstructionSymbol, DkmScriptInstructionSymbol</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Bind(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Binds an instruction symbol to a particular module instance. An instruction symbol is connected to a DkmModule instead of a DkmModuleInstance. Therefore, it is not bound to a particular process, application domain, or module base address.</summary>
      <returns>[Out] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</returns>
      <param name="ModuleInstance">[In] The Module Instance class represents a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetCompilerId(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the compiler id (LanguageId/VendorId) of a given symbol. For the Microsoft PDB reader, if the PDB was created by a compiler that used ISymUnmanagedWriter, then the PDB reader will be able to determine the correct DkmCompilerId from the LanguageId/VendorId pair passed from ISymUnmanagedWriter.DefineDocument. If the PDB was created by a compiler that did not use ISymUnmanagedWriter, the PDB reader may be able to obtain the DkmCompilerId from the S_COMPILE* PDB records. For this to work, the compiler must first emit the S_COMPILE* record for each compiland. The compiler must be sure to correctly fill out the language enumeration value and the compiler string. The compiler should make sure that the compiler string is sufficiently specific to use for selecting an expression evaluator; we recommend that you include a company name. After emitting the Enum/Name pair, the setup for the expression evaluator should then register this pair with the debugger. To do so, the expression evaluator should set this registry key: %VSRegistryRoot%\Debugger\CodeView Compilers\%CodeViewLanguageCode%:%CompilerName% and define the VendorId/LanguageId.</summary>
      <returns>[Out] LanguageId/VendorId for the compiler that produced the code for this symbol. If this is unknown (ex: no symbols information for this block), both values will be Guid.Empty. Otherwise, both values should be non-zero.</returns>
      <param name="InspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetCurrentStatementRange">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetDisassemblyLabel(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <summary>Returns the name of the symbol as it will appear in the disassembly window. For Microsoft C++ code, this is based on the public symbol name. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] The label to use for this instruction.</returns>
      <param name="InspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetGPUInstructionMetadataCallback(Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>This method returns address information to the GPU debug monitor.</summary>
      <returns>[Out,Optional] The address type information.</returns>
      <param name="InstructionAddress">[In,Optional] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="NextInstruction">[In] The next instruction address which is used to determine inline function call.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetNoSourceRanges">
      <summary>Queries the symbol provider to determine the ranges of instructions which do not correspond to any user source statements and are used by the base debug monitor to always step through during stepping.</summary>
      <returns>[Out] Array of no source ranges to always step through. This array will be empty if there are no no-source ranges for the given instruction.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetSourcePosition(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionAsyncResult})">
      <summary>Returns the source file position (ex: example.cs, line 12) of this instruction symbol. If this instruction symbol is not associated with a source file, null is returned (S_FALSE return code in native). This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="Flags">[In] Flags which affect the behavior of 'GetSourcePosition'.</param>
      <param name="InspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetSourcePosition(Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Boolean@)">
      <summary>Returns the source file position (ex: example.cs, line 12) of this instruction symbol. If this instruction symbol is not associated with a source file, null is returned (S_FALSE return code in native). Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out,Optional] Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</returns>
      <param name="Flags">[In] Flags which affect the behavior of 'GetSourcePosition'.</param>
      <param name="InspectionSession">[In,Optional] A reference object describing the current inspection session.</param>
      <param name="StartOfLine">[Out] True if this address is the first address in the line's range. False otherwise.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetSourcePositionCallback(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetSourcePositionCallbackAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetSourcePositionCallback(Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,System.Boolean@)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetSteppingRanges(Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary,System.Boolean)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetUserCodeSourcePositionCallback(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetUserCodeSourcePositionCallbackAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.GetUserCodeSourcePositionCallback(Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession)">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.HasLineInfo">
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.HasLineInfo(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmHasLineInfoAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.IsHiddenCode(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Evaluation.DkmInspectionSession,Microsoft.VisualStudio.Debugger.DkmInstructionAddress,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult})">
      <summary>Returns if this instruction symbol is in hidden code. For instance, in managed code, the line number 0xfeefee marks a source line as hidden. This method will append a new work item to the specified work list and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="InspectionSession">[In] DkmInspectionSession allows the various components that inspect data to store private data that is associated with a group of evaluations.</param>
      <param name="InstructionAddress">[In] Abstract representation of an executable code location (ex: EIP value). If resolved, an Instruction Address will be in a particular module instance. An Instruction Address is always in a particular Runtime Instance.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Module">
      <summary>The DkmModule class represents a code bundle (ex: dll or exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.RuntimeType">
      <summary>The Runtime Id identifies the execution environment for a particular block of code. Runtime Ids are used by the dispatcher to decide which monitor to dispatch to. Note that the ordering of the runtime ID GUIDs is somewhat significant as this dictates which runtime receives the first shot during arbitration. Thus, if one wants to declare a new runtime instance that is built on the CLR, the runtime id should be less than DkmRuntimeId.Clr.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.TagValue">
      <summary>DkmInstructionSymbol is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag">
      <summary>DkmInstructionSymbol is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag.NativeInstruction">
      <summary>The object is an instance of 'DkmNativeInstructionSymbol'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag.ClrInstruction">
      <summary>The object is an instance of 'DkmClrInstructionSymbol'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag.ScriptInstruction">
      <summary>The object is an instance of 'DkmScriptInstructionSymbol'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol.Tag.CustomInstruction">
      <summary>The object is an instance of 'DkmCustomInstructionSymbol'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult">
      <summary>Result of an asynchronous DkmInstructionSymbol.IsHiddenCode call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags,Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmInstructionSymbol.IsHiddenCode.</summary>
      <param name="NonUserCodeFlags">[In] Flags for DebuggerStepThrough DebuggerHidden, and DebuggerNonUserCode attributes set on method or class or marked hidden due to the 0xfeefee sequence point.</param>
      <param name="NextLine">[In,Optional] The symbol for the next non-hidden source line. This is null if the current line is not hidden.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmInstructionSymbol.IsHiddenCode.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult.NextLine">
      <summary>[Optional] The symbol for the next non-hidden source line. This is null if the current line is not hidden.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmIsHiddenCodeAsyncResult.NonUserCodeFlags">
      <summary>Flags for DebuggerStepThrough DebuggerHidden, and DebuggerNonUserCode attributes set on method or class or marked hidden due to the 0xfeefee sequence point.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Clr.DkmNonUserCodeFlags" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue">
      <summary>Value of a calculated MD5 hash. MD5 hashes are used for the document checksum feature, which is a non-security purpose. MD5 should no longer be used for any security related purpose.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Initialize a new DkmMD5HashValue value.</summary>
      <param name="Value0">[In] First 32-bits of the calculated hash.</param>
      <param name="Value1">[In] Second 32-bits of the calculated hash.</param>
      <param name="Value2">[In] Third 32-bits of the calculated hash.</param>
      <param name="Value3">[In] Forth 32-bits of the calculated hash.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.CompareTo(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.Equals(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue structure.</summary>
      <returns>'true' if the two elements are equal.</returns>
      <param name="other">Value to comare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_Equality(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_GreaterThan(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_Inequality(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_LessThan(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Compare two elements of the DkmMD5HashValue sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison</param>
      <param name="element1">Right side of the comparison</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.Value0">
      <summary>First 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.Value1">
      <summary>Second 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.Value2">
      <summary>Third 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue.Value3">
      <summary>Forth 32-bits of the calculated hash.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule">
      <summary>The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler thinks of all these as being identical, there will be only one module object.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.CompilerId">
      <summary>LanguageId/VendorId for the compiler which produced all of the code in this module. This is Guid.Empty/Guid.Empty if the module may contain a mixture of languages. This will almost always be Guid.Empty/Guid.Empty for PDB-based modules. It generally used by dynamic languages to avoid network round trips to discover the language of each symbol.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.Connection">
      <summary>[Optional] For modules where symbols are loaded remotely, the connection property is used to determine where the Connection originated from. Otherwise this will be NULL.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,System.String,Microsoft.VisualStudio.Debugger.Evaluation.DkmCompilerId,Microsoft.VisualStudio.Debugger.DefaultPort.DkmTransportConnection,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new DkmModule object, which represents the symbols for one or more loaded modules (module instances). These objects are created by symbol providers. After the DkmModule object is created, symbol providers should call DkmModuleInstance.SetModule to associate the DkmModuleInstance and DkmModule together. This method will send a ModuleCreate event.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Id">[In] Guid pair used to uniquely identify a particular DkmModule instance.</param>
      <param name="Name">[In] Name of the module.</param>
      <param name="CompilerId">[In] LanguageId/VendorId for the compiler which produced all of the code in this module. This is Guid.Empty/Guid.Empty if the module may contain a mixture of languages. This will almost always be Guid.Empty/Guid.Empty for PDB-based modules. It generally used by dynamic languages to avoid network round trips to discover the language of each symbol.</param>
      <param name="Connection">[In,Optional] For modules where symbols are loaded remotely, the connection property is used to determine where the Connection originated from. Otherwise this will be NULL.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmModule instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.FindDocuments(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmFindDocumentsAsyncResult})">
      <summary>Returns document objects from search parameters that are contained in the document query. If the symbol file does not contain a reference to this document the returned document object will be NULL (S_FALSE return code in native). The returned document objects must be explicitly closed by the caller when the caller has finished with the document. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="SourceFileId">[In] Identifies a source file and provides the information which a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always raise (including when the operation is canceled). This will never raise if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.FindDocuments(Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId)">
      <summary>Returns document objects from search parameters that are contained in the document query. If the symbol file does not contain a reference to this document the returned document object will be NULL (S_FALSE return code in native). The returned document objects must be explicitly closed by the caller when the caller has finished with the document. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] A collection of the documents that matched the query.</returns>
      <param name="SourceFileId">[In] Identifies a source file and provides the information which a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.FindModule(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Find a DkmModule object. If no object that has the given input key is present, FindModule will fail.</summary>
      <returns>[Out,Optional] Result of the search.</returns>
      <param name="Id">[In] Search key that is used to find the element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetAcceleratorTagTableSize(System.UInt32@)">
      <summary>Gets a C++ AMP address for a register. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Maximum tag value found in actual C++ AMP pointers plus one.</returns>
      <param name="SizeOfForwardedTags">[Out] Maximum tag value that may be subject to buffer forwarding plus one.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetCompilerOptions">
      <summary>This method returns compiler flags of the given GPU module.</summary>
      <returns>[Out,Optional] returns the compiler flags.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetEntryPointSymbols">
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmInstructionSymbol" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetFirstMethodInFirstDocument">
      <summary>Returns the first method in the first document. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetFunctionInfo(Microsoft.VisualStudio.Debugger.DkmWorkList,System.String,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetFunctionInfoAsyncResult})"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetFunctionInfo(System.String)"></member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetInstructionOffsetForRva(System.UInt32)">
      <summary>GetInstructionOffsetForRva is used by components to query symbol provider to perform instruction offset and RVA translation for DPC++. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The instruction offset from stub function.</returns>
      <param name="RVA">[In] The RVA in a module.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetMethodSymbolStoreData(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId)">
      <summary>Returns the scopes in a method. There will always be at least one scope. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</returns>
      <param name="MethodId">[In] DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetMethodSymbolStoreData(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataAsyncResult})">
      <summary>Returns the scopes in a method. There will always be at least one scope. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="MethodId">[In] DkmClrMethodId is a token/version pair which is used to uniquely identify the symbol store's understanding of a particular CLR method in a module.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always raise (including when the operation is canceled). This will never occur if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetMethodSymbolStoreDataPreRemap(Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,System.Int32@)">
      <summary>Returns the scopes in a method. There will always be at least one scope. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] DkmClrMethodScopeData[] describes a scope in a method. These are defined by using ISymUnmanagedWriter::OpenScope/CloseScope.</returns>
      <param name="MethodId">[In] Method Id PreRemap.</param>
      <param name="RemapToken">[Out] Method token after the Remap.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetMethodSymbolStoreDataPreRemap(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Clr.DkmClrMethodId,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetMethodSymbolStoreDataPreRemapAsyncResult})">
      <summary>Returns the scopes in a method. There will always be at least one scope. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="MethodId">[In] Method Id PreRemap.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always raise (including when the operation is canceled). This will never raise if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetModuleInstances">
      <summary>A DkmModule is the symbol handler's representation of a module, and is not bound to any process, connection or runtime instance. This method returns all the DkmModuleInstances which map to this DkmModule. A DkmModule can be bound to zero instances in the case that all of the modules are now unloaded. In this case, GetModuleInstances will return an empty array (S_FALSE return code in native).</summary>
      <returns>[Out] The Module Instance class represent a code bundle (ex: dll or exe) which is loaded into a particular process at a particular location. Module Instance objects are 1:1 with the execution environment's notion of a code bundle. For example, in native code, Module Instance objects are 1:1 with base address.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetModules">
      <summary>GetModules enumerates all the created DkmModule objects.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetPointerToHLSLRegister(System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Boolean@)">
      <summary>Gets a C++ AMP address for a register. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Address for register.</returns>
      <param name="RegisterType">[In] Type of HLSL register.</param>
      <param name="RegisterIndex">[In] Index of HLSL register.</param>
      <param name="FirstElement">[In] Index of first vector element.</param>
      <param name="VectorElements">[In] Number of vector elements.</param>
      <param name="ByteOffset">[In] Offset from start of register.</param>
      <param name="VectorElementSize">[In] Size of vector element.</param>
      <param name="Rva">[In] RVA to use for mapping register information and tag address.</param>
      <param name="StartLiveRange">[In] Start of live range for the symbol.</param>
      <param name="EndLiveRange">[In] End of live range for the symbol.</param>
      <param name="IsNewDynamicTag">[Out] Is the address newly generated by using dynamic tag.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetPublicSymbolByNameCallback(System.String)">
      <summary>Return the RVA for an S_PUBLIC32 for a particular name by string.</summary>
      <returns>[Out,Optional] The native instruction symbol for this public symbol.</returns>
      <param name="PublicName">[In] The name of the public symbol to look up.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetScriptDocuments">
      <summary>GetScriptDocuments enumerates the DkmScriptDocument elements of this DkmModule object.</summary>
      <returns>[Out] Array that contains the enumerated elements.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetSourceServerData(Microsoft.VisualStudio.Debugger.DkmModuleInstance)">
      <summary>Returns the contents of the source server stream data for a module if the stream exists. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] True if this address is the first address in the line's range. False otherwise.</returns>
      <param name="ModuleInstance">[In] The module instance for which symbol server data is being requested.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetSymbolFilePath">
      <summary>Returns the path of the symbol file which backs a DkmModule object. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] Full path of the symbol file (ex: c:\myproj\bin\debug\myproj.pdb).</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetSymbolInterface(System.Guid)">
      <summary>GetSymbolInterface is used to obtain a raw COM interface to a symbol store. This is useful to either callers that find the symbol abstraction presented by the debugger to be either too restrictive for their needs, or just not what you want because of the way in which their component is implemented. Location constraint: This method must be called from the same process where the symbol provider has opened the symbol file. For Native PDB files, this means that the API must be called from the IDE process. For Managed symbols, this API is implemented in the IDE process except for server-side compiled ASP.NET code, and dynamic languages (ex: IronPython).</summary>
      <returns>[Out] Returned symbol interface. This may be cast to the interface pointer corresponding to 'InterfaceID'.</returns>
      <param name="InterfaceID">[In] The GUID of the desired interface. Microsoft supports IID_IDiaSession for Native DkmModule's, and IID_ISymUnmanagedReader for Managed modules.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetTokenSymbolStoreAttribute(Microsoft.VisualStudio.Debugger.DkmWorkList,System.Int32,System.Boolean,System.String,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmGetTokenSymbolStoreAttributeAsyncResult})">
      <summary>Gets a custom attribute based on its name. Not to be confused with Metadata custom attributes, these attributes are held in the symbol store. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="ParentToken">[In] The token of the method where the symbol store attribute is stored.</param>
      <param name="IsPreRemap">[In] True if the specified token value is not a real method token but was internally computed by the compiler before the method was emitted using the CLR image creation APIs.</param>
      <param name="AttributeName">[In] The name of the attribute to find.</param>
      <param name="CompletionRoutine">Routine to call when the request is completed. If the request is successfully appended to the work list, this will always raise (including when the operation is canceled). This will never raise if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.GetTokenSymbolStoreAttribute(System.Int32,System.Boolean,System.String)">
      <summary>Gets a custom attribute based on its name. Not to be confused with Metadata custom attributes, these attributes are held in the symbol store. Location constraint: This API will fail when it is called from an IDE component to query information for server-side compiled ASP.NET code, or dynamically compiled code.</summary>
      <returns>[Out] The value of the requested symbol store attribute.</returns>
      <param name="ParentToken">[In] The token of the method where the symbol store attribute is stored.</param>
      <param name="IsPreRemap">[In] True if the specified token value is not a real method token but was internally computed by the compiler before the method was emitted using the CLR image creation APIs.</param>
      <param name="AttributeName">[In] The name of the attribute to find.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.Id">
      <summary>Guid pair used to uniquely identify a particular DkmModule instance.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.IsValidAcceleratorTag(System.UInt32,System.UInt32)">
      <summary>Verify if the accelerator pointer tag is valid. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] True if the given accelerator tag is valid at the given RVA. If RVA is zero, checks if the tag is valid anywhere including as a dynamically created tag.</returns>
      <param name="InputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="Rva">[In] RVA to use for filtering; ignored if zero.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.Name">
      <summary>Name of the module.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.SetPointerToHLSLRegister(System.UInt64,System.Int32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
      <summary>Sets a C++ AMP address for a register. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="Address">[In] Address for register.</param>
      <param name="RegisterType">[In] Type of HLSL register.</param>
      <param name="RegisterIndex">[In] Index of HLSL register.</param>
      <param name="FirstElement">[In] Index of first vector element.</param>
      <param name="VectorElements">[In] Number of vector elements.</param>
      <param name="ByteOffset">[In] Offset from start of register.</param>
      <param name="VectorElementSize">[In] Size of vector element.</param>
      <param name="StartLiveRange">[In] Start of live range for the symbol.</param>
      <param name="EndLiveRange">[In] End of live range for the symbol.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.TranslateAcceleratorTagByIP(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>Translate accelerator pointer tag into HLSL register attributes.</summary>
      <param name="InputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="InstructionPointer">[In] current instruction pointer used to obtain scope for pointer translation.</param>
      <param name="RegisterType">[Out] HLSL register type.</param>
      <param name="RegisterIndex">[Out] HLSL register index.</param>
      <param name="FirstElement">[Out] Index of first vector element.</param>
      <param name="VectorElements">[Out] Number of vector elements.</param>
      <param name="ByteOffset">[Out] Offset in bytes.</param>
      <param name="VectorElementSize">[Out] Size of each vector element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.TranslateAcceleratorTagByRva(System.UInt32,System.UInt32,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
      <summary>Translate accelerator pointer tag into HLSL register attributes using relative virtual address. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="InputTag">[In] Accelerator pointer tag found in symbols.</param>
      <param name="Rva">[In] RVA to use for filtering; ignored if zero.</param>
      <param name="RegisterType">[Out] HLSL register type.</param>
      <param name="RegisterIndex">[Out] HLSL register index.</param>
      <param name="FirstElement">[Out] Index of first vector element.</param>
      <param name="VectorElements">[Out] Number of vector elements.</param>
      <param name="ByteOffset">[Out] Offset in bytes.</param>
      <param name="VectorElementSize">[Out] Size of each vector element.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModule.UndecorateName(System.String,System.UInt32)">
      <summary>Undecorates a symbol name. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The undecorated name.</returns>
      <param name="DecoratedName">[In] The name to be undecorated.</param>
      <param name="Options">[In] Options to change the undecorated name. These are specific to the implementation being used. For Microsoft PDB, pass one or more of the values described in the documentation for DbgHelp.dll UnDecorateSymbolName or one of these three extended options: UNDNAME2_STRIP_ILT 0x10000 - to remove the leading ILT from Incremental Linking Thunks UNDNAME2_STRIP_CONST 0x20000 - to remove leading "const" from the front of the string UNDNAME2_STRINGS 0x30000 - to use pooled strings by name.</param>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId">
      <summary>GUID pair used to uniquely identify a particular DkmModule instance.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.#ctor(System.Guid,System.Guid)">
      <summary>Initializes a new DkmModuleId value.</summary>
      <param name="Mvid">[In] Module version Identifier from the symbol file. This uniquely identifies the symbol file. For C++ or .NET Framework binaries, this is a unique value that is embedded in an .exe/.dll by linkers/compilers when the .dll/.exe is built. A new value is generated every time the .dll/.exe is compiled.</param>
      <param name="SymbolProvider">[In] Identifies the symbol provider (and therefore symbol format) used to examine these symbols.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.CompareTo(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.Equals(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>True if the two elements are equal.</returns>
      <param name="other">Value to compare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.Mvid">
      <summary>Module version Identifier from the symbol file. This uniquely identifies the symbol file. For C++ or .NET Framework binaries, this is a unique value that is embedded in an .exe/.dll by linkers/compilers when the .dll/.exe is built. A new value is generated every time the .dll/.exe is compiled.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_Equality(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_GreaterThan(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_Inequality(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_LessThan(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId,Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId)">
      <summary>Compares two elements of the DkmModuleId structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmModuleId.SymbolProvider">
      <summary>Identifies the symbol provider (and therefore symbol format) used to examine these symbols.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmPdbFileId">
      <summary>Contains the information which is in the 'RSDS' section of the module's debug directory. The Mvid part of this information is in the Mvid immutable.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmPdbFileId.Age">
      <summary>Age of the PDB. This is a timestamp value which is embedded in an exe/dll by linkers/compilers when the dll/exe is built.</summary>
      <returns>Returns <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmPdbFileId.Create(System.Guid,System.Guid,System.UInt32,System.String)">
      <summary>Create a new DkmPdbFileId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SymbolProviderId">[In] TODO.</param>
      <param name="Mvid">[In] Module Version Identifier from the loaded module. This is a unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value is generated every time that the dll/exe is compiled.</param>
      <param name="Age">[In] Age of the PDB. This is a timestamp value which is embedded in an exe/dll by linkers/compilers when the dll/exe is built.</param>
      <param name="PdbName">[In] The name of the PDB file that contains the debug information. This value is often a file path (ex: c:\myproject\bin\debug\myproject.pdb), but in some build environments it may be shortened to just a file name (ex: kernel32.pdb).</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmPdbFileId.Mvid">
      <summary>Module Version Identifier from the loaded module. This is a unique value which is embedded in an exe/dll by linkers/compilers when the dll/exe is built. A new value is generated every time that the dll/exe is compiled.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmPdbFileId.PdbName">
      <summary>The name of the PDB file that contains the debug information. This value is often a file path (ex: c:\myproject\bin\debug\myproject.pdb), but in some build environments it may be shortened to just a file name (ex: kernel32.pdb).</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument">
      <summary>Object which represents the result of a source file query against a symbol file (PDB). The resolved document object might encapsulate multiple document records with the symbol file. For example, in C++ compilation, every time that a header file is included there is another reference in the PDB. However, there is only one DkmResolvedDocument object for the header file. Derived classes: DkmResolvedMappedDocument</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.Close">
      <summary>Closes the resolved document object. This method must be invoked when the component which requested the resolved document has finished with the object. DkmResolvedDocument objects are automatically closed when their associated DkmModule object is closed.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength,Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning,System.Boolean,Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a new resolved document object. Resolved document objects are created by a symbol provider. They are a data container so that a symbol provider may back the resolved document with their own internal state.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different app domains) but the symbol handler thinks of all of these as being identical, there will be only one module object.</param>
      <param name="DocumentName">[In] Name of the source file. This is generally a full path, but in some scenarios it make be a partial path or just a name with extension (ex: example.cpp). In the case of a dynamic document (ex: running script from internet explorer) 'Path' could be a URL instead of a local file path.</param>
      <param name="ScriptDocument">[In,Optional] Script document which this resolved document represents. This should be null for non script-based symbol providers.</param>
      <param name="MatchStrength">[In] Indicates how strong of a match there was between the DkmDocumentQuery and the resulting DkmResolvedDocument.</param>
      <param name="Warning">[In] Warning that occurred during the match. Depending on context, these may have to be surfaced to the user.</param>
      <param name="TextRequested">[In] If true, return the source text.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmResolvedDocument instance. Pass 'null' in the case that the caller does not have to add a data item.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.DocumentName">
      <summary>Name of the source file. This is generally a full path, but in some scenarios it make be a partial path or just a name with extension (ex: example.cpp). In the case of a dynamic document (ex: running script from internet explorer) 'Path' could be a URL instead of a local file path.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.FindSymbols(Microsoft.VisualStudio.Debugger.DkmWorkList,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.String,Microsoft.VisualStudio.Debugger.DkmCompletionRoutine{Microsoft.VisualStudio.Debugger.Symbols.DkmFindSymbolsAsyncResult})">
      <summary>Finds the symbols in the document which best match the input text span. For IL-based languages, the symbol handler always returns the DkmInstructionSymbol for sequence points. It will prefer sequence points which exactly match the text span followed by the sequence point or points which is left-most and which is inside the input span. For languages which emit a native PDB, TODO. This method will append a new work item to the specified work list, and return as soon as the work item has been appended. The actual processing of the work item is asynchronous. The caller will be notified that the request is complete through the completion routine. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <param name="WorkList">WorkList to append the new work item to.</param>
      <param name="TextSpan">[In] The text range (lines/column) to search for.</param>
      <param name="Text">[In,Optional] The text to search for. When available, this will be provided if ResolvedDocument.TextRequested is set.</param>
      <param name="CompletionRoutine">Routine to fire when the request is completed. If the request is successfully appended to the work list, this will always fire (including when the operation is canceled). This will never fire if appending the work item fails.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.FindSymbols(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,System.String,Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition[]@)">
      <summary>Finds the symbols in the document which best match the input text span. For IL-based languages, the symbol handler always returns the DkmInstructionSymbol for sequence points. It will prefer sequence points which exactly match the text span followed by the sequence point or points which is left-most and which is inside the input span. For languages which emit a native PDB, TODO. Location constraint: API must be called from an IDE component (component level &gt; 100,000).</summary>
      <returns>[Out] The found instruction symbols which are in the specified text span.</returns>
      <param name="TextSpan">[In] The text range (lines/column) to search for.</param>
      <param name="Text">[In,Optional] The text to search for. When available, this will be provided if ResolvedDocument.TextRequested is set.</param>
      <param name="SymbolLocation">[Out] The source location of each returned instruction symbol. The length of this array should be the same of the returned instruction symbol array.</param>
      <exception cref="T:Microsoft.VisualStudio.Debugger.DkmException">E_TEXT_SPAN_NOT_LOADED indicates that TextSpan is not currently loaded in the specified script document.-or-E_SCRIPT_SPAN_MAPPING_FAILED indicates that TextSpan could not be mapped to a location in the specified script document.-or-E_SCRIPT_FILE_DIFFERENT_CONTENT indicates that the content in the script file loaded by the target process does not match the provided Text.</exception>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.MatchStrength">
      <summary>Indicates how strong of a match there was between the DkmDocumentQuery and the resulting DkmResolvedDocument.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.Module">
      <summary>The DkmModule class represents a code bundle (ex: dll or exe) which is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different app domains) but the symbol handler thinks of all of these as being identical, there will be only one module object.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmModule" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.ScriptDocument">
      <summary>[Optional] Script document which this resolved document represents. This should be null for non script-based symbol providers.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.System#IDisposable#Dispose"></member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.TextRequested">
      <summary>If true, return the source text.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.UniqueId">
      <summary>Guid which uniquely identifies this object.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocument.Warning">
      <summary>Warning that occurred during the match. Depending on context, these may have to be surfaced to the user.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning">
      <summary>Warning that occurred during the match. Depending on context, these might have to be surfaced to the user.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning.None">
      <summary>No warning occurred during the match.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning.ChecksumMismatch">
      <summary>Both the symbol file and input request contained a source file checksum. However, the checksum values did not match each other.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning.MultipleChecksums">
      <summary>Both the symbol file and input request contained a source file checksum, and the symbol file contained a match to this checksum value. However, the symbol file also contained information about an identically named document that has a different checksum value. This can occur in partial rebuild scenarios and might cause strange behavior.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedMappedDocument">
      <summary>Resolved document object that is created from a successful call to DkmModule.FindMappedDocuments or DkmScriptDocument.TryMappedResolve. This contains the information to map requests in server-side documents into requests on the client-side document.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedMappedDocument.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmModule,System.String,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmDocumentMatchStrength,Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedDocumentWarning,System.Boolean,System.Collections.ObjectModel.ReadOnlyCollection{Microsoft.VisualStudio.Debugger.Script.DkmScriptBlockMappingInfo},Microsoft.VisualStudio.Debugger.DkmDataItem)">
      <summary>Creates a resolved mapped document object. This API is typically called by the script local agent.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="Module">[In] The DkmModule class represents a code bundle (ex: .dll or .exe) that is or previously was loaded into one or more processes. The DkmModule class is the central object to the symbol APIs, and is 1:1 with the symbol handler's notation of what is loaded. If a code bundle loads into three different processes (or the same process but with three different base addresses or three different application domains) but the symbol handler considers all of these to be identical, there will be only one module object.</param>
      <param name="DocumentName">[In] Name of the source file. This is generally a full path, but in some scenarios it might be a partial path or just a name with an extension (ex: example.cpp). In the case of a dynamic document (ex: running script from Internet Explorer) 'Path' could be a URL instead of a local file path.</param>
      <param name="ScriptDocument">[In,Optional] Script document that this resolved document represents. This should be null for non-script-based symbol providers.</param>
      <param name="MatchStrength">[In] Indicates how strong a match there was between the DkmDocumentQuery and the resulting DkmResolvedDocument.</param>
      <param name="Warning">[In] Warning that occurred during the match. Depending on context, these might have to be surfaced to the user.</param>
      <param name="TextRequested">[In] If true, return the source text.</param>
      <param name="ScriptBlocks">[In,Optional] Collection of script blocks in the project item document.</param>
      <param name="DataItem">[In,Optional] Data object to add to the new DkmResolvedMappedDocument instance.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmResolvedMappedDocument.ScriptBlocks">
      <summary>[Optional] Collection of script blocks in the project item document.</summary>
      <returns>Returns <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmRVASizePair">
      <summary>An RVA and size pair representing a symbol returned from DkmModule GetFunctionInfo.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmRVASizePair.#ctor(System.UInt32,System.UInt32)">
      <summary>Initialize a new DkmRVASizePair value.</summary>
      <param name="RVA">[In] The relative virtual address of a symbol.</param>
      <param name="Size">[In] The size of a symbol.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmRVASizePair.RVA">
      <summary>The relative virtual address of a symbol.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmRVASizePair.Size">
      <summary>The size of a symbol.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue">
      <summary>Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document checksum feature, which is a non-security purpose. SHA-1 should no longer be used for any security-related purpose.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Initializes a new DkmSHA1HashValue value.</summary>
      <param name="Value0">[In] First 32-bits of the calculated hash.</param>
      <param name="Value1">[In] Second 32-bits of the calculated hash.</param>
      <param name="Value2">[In] Third 32-bits of the calculated hash.</param>
      <param name="Value3">[In] Fourth 32-bits of the calculated hash.</param>
      <param name="Value4">[In] Fifth 32-bits of the calculated hash.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.CompareTo(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Equals(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>'true' if the two elements are equal.</returns>
      <param name="other">Value to compare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_Equality(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_GreaterThan(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_Inequality(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_LessThan(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue,Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Compares two elements of the DkmSHA1HashValue structure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Value0">
      <summary>First 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Value1">
      <summary>Second 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Value2">
      <summary>Third 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Value3">
      <summary>Fourth 32-bits of the calculated hash.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue.Value4">
      <summary>Fifth 32-bits of the calculated hash.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId">
      <summary>Identifies a source file and provides the information that a symbol handler could use to search a symbol file (PDB) for information about this source file.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.Create(System.String,Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument,Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5Hash,Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1Hash)">
      <summary>Creates a new DkmSourceFileId object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="DocumentName">[In] Name of the source file. This is generally a full path, but in some scenarios it might be a partial path or just a name with extension (ex: example.cpp). In the case of a dynamic document (ex: running script from Internet Explorer) 'Path' could be a URL instead of a local file path.</param>
      <param name="ScriptDocument">[In,Optional] Script document object that this DkmSourceFileId wraps. For requests to find document requests, this can be non-null when the text position to search for is from the dynamic view of a document. For address-&gt;text position requests, this will be non-null when the address is in a script document.</param>
      <param name="MD5Hash">[In,Optional] MD5 hash value for this document.</param>
      <param name="SHA1Hash">[In,Optional] SHA-1 hash value for this document.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.DocumentName">
      <summary>Name of the source file. This is generally a full path, but in some scenarios it might be a partial path or just a name with an extension (ex: example.cpp). In the case of a dynamic document (ex: running script from Internet Explorer) 'Path' could be a URL instead of a local file path.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5HashPart">
      <summary>[Optional] MD5 hash value for this document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5Hash" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.ScriptDocument">
      <summary>[Optional] Script document object that this DkmSourceFileId wraps. For requests to find document requests, this can be non-null when the text position to search for is from the dynamic view of a document. For address-&gt;text position requests, this will be non-null when the address is in a script document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Script.DkmScriptDocument" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1HashPart">
      <summary>[Optional] SHA-1 hash value for this document.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1Hash" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5Hash">
      <summary>MD5 hash value for this document.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5Hash.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmMD5HashValue)">
      <summary>Initialize a new MD5Hash value.</summary>
      <param name="Value">[In] Value of a calculated MD5 hash. MD5 hashes are used for the document checksum feature, which is a non-security purpose. MD5 should no longer be used for any security related purpose.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.MD5Hash.Value">
      <summary>Value of a calculated MD5 hash. MD5 hashes are used for the document checksum feature, which is a non-security purpose. MD5 should no longer be used for any security related purpose.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1Hash">
      <summary>SHA-1 hash value for this document.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1Hash.#ctor(Microsoft.VisualStudio.Debugger.Symbols.DkmSHA1HashValue)">
      <summary>Initialize a new SHA1Hash value.</summary>
      <param name="Value">[In] Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document checksum feature, which is a non-security purpose. SHA-1 should no longer be used for any security related purpose.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId.SHA1Hash.Value">
      <summary>Value of a calculated SHA-1 hash. SHA-1 hashes are used for the document checksum feature, which is a non-security purpose. SHA-1 should no longer be used for any security related purpose.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition">
      <summary>Source code position that corresponds to a code element. This could represent a location that has been extracted from a symbol (PDB) file, or it could be the location of a breakpoint in the IDE.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition.Create(Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Creates a new DkmSourcePosition object instance.</summary>
      <returns>[Out] Result of this method call.</returns>
      <param name="SourceFileId">[In] Identifies a source file and provides the information that a symbol handler could use to search a symbol file (PDB) for information about this source file.</param>
      <param name="TextSpan">[In] The start/end line/column ranges for a contiguous span of text.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition.DocumentName">
      <summary>Name of the source file. This is generally a full path, but in some scenarios it may be a partial path or just a name with an extension (ex: example.cpp). In the case of a dynamic document (ex: running script from Internet Explorer) 'Path' could be a URL instead of a local file path.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition.SourceFileId">
      <summary>Identifies a source file and provides the information that a symbol handler could use to search a symbol file (PDB) for information about this source file.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourceFileId" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePosition.TextSpan">
      <summary>The start/end line/column ranges for a contiguous span of text.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags">
      <summary>Flags which affect the behavior of 'GetSourcePosition'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags.None">
      <summary>Instructs the symbol provider to use the default behavior of GetSourcePosition.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSourcePositionFlags.ExtendedSourceRange">
      <summary>Instructs the symbol provider to extend the source range to include surrounding source code and also to the source statement which corresponds to the instruction symbol. This option is used in the disassembly window.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange">
      <summary>A offset/size pair which is returned from the symbol provider to a debug monitor to indicate a range of instructions which the debugger should not stop at.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange.#ctor(System.UInt32,System.UInt32,System.UInt32)">
      <summary>Initialize a new DkmSteppingRange value.</summary>
      <param name="StartOffset">[In] The start of a stepping range. The meaning is dependant on the underlying runtime being stepped. For MSIL, this IL offset is relative to the start of the method. For native code, this is an RVA.</param>
      <param name="Length">[In] The length of a stepping range. The meaning is dependant on the underlying runtime being stepped. For both native code and MSIL, this is a byte count of the number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate that the range should extend to the end of the method.</param>
      <param name="LineNumber">[In] The source line number of the stepping range. The meaning is dependant on the underlying runtime being stepped. For both native code and MSIL, this is the source line number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate that the range should extend to the end of the method.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange.Length">
      <summary>The length of a stepping range. The meaning is dependant on the underlying runtime being stepped. For both native code and MSIL, this is a byte count of the number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate that the range should extend to the end of the method.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange.LineNumber">
      <summary>The source line number of the stepping range. The meaning is dependant on the underlying runtime being stepped. For both native code and MSIL, this is the source line number of instructions in the range. For MSIL, UInt32.MaxValue is used to indicate that the range should extend to the end of the method.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRange.StartOffset">
      <summary>The start of a stepping range. The meaning is dependant on the underlying runtime being stepped. For MSIL, this IL offset is relative to the start of the method. For native code, this is an RVA.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary">
      <summary>Indicates to the symbol provider the type of instructions to include in the 'no-step' regions.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary.FunctionStart">
      <summary>Step should complete at the first non-hidden instruction in the method. This value is used when stepping into a new function.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary.NextStatement">
      <summary>Step should complete on the next statement.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary.NextLine">
      <summary>Step should complete on the next line.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSteppingRangeBoundary.InlineFunctionOut">
      <summary>Step should complete at the first instruction after the inline method. This value is used when stepping out an inline function.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId">
      <summary>Contains information that is required to locate symbols for this module. On Win32, this information is contained in the IMAGE_DEBUG_DIRECTORY. Derived classes: DkmCustomSymbolFileId, DkmDynamicSymbolFileId, DkmPdbFileId</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.SymbolProviderId">
      <summary>TODO.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.TagValue">
      <summary>DkmSymbolFileId is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.Tag" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.Tag">
      <summary>DkmSymbolFileId is an abstract base class. This enum indicates which derived class this object is an instance of.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.Tag.PdbFileId">
      <summary>Object is an instance of 'DkmPdbFileId'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.Tag.DynamicSymbolFileId">
      <summary>Object is an instance of 'DkmDynamicSymbolFileId'.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolFileId.Tag.CustomSymbolFileId">
      <summary>Object is an instance of 'DkmCustomSymbolFileId'.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId">
      <summary>TODO.</summary>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.ActiveScript">
      <summary>Provides symbol resolution for Microsoft ActiveScript based dynamic code.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.ClrPDB">
      <summary>Reads symbol information from PDB files to decode .NET Framework (CLR) binaries.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.ClrRemoteSymbolStore">
      <summary>Provides symbol resolution from Metadata and a remote symbol store for the .NET Framework (CLR) binaries. This is used for dynamically compiled managed code. It is also used for ASP.NET scenario where code is compiled on server side.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.DpcppPDB">
      <summary>Reads symbol information from PDB files to decode DPC++ binaries.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.HlslPDB">
      <summary>Reads symbol information from PDB in D3D blob to decode HLSL binaries.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.Symbols.DkmSymbolProviderId.NativePDB">
      <summary>Reads symbol information from PDB/DBG files to decode native binaries.</summary>
      <returns>Returns <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan">
      <summary>The start/end line/column ranges for a contiguous span of text.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>Initializes a new DkmTextSpan value.</summary>
      <param name="StartLine">[In] 1-based integer for the starting source line.</param>
      <param name="EndLine">[In] 1-based integer for the ending source column.</param>
      <param name="StartColumn">[In] 1-based integer for the starting source column. If column information is missing (ex: language service does not support it), this value should be set to 0.</param>
      <param name="EndColumn">[In] 1-based integer for the ending source column. If column information is missing (ex: language service does not support it), this value should be set to 0.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.CompareTo(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.EndColumn">
      <summary>1-based integer for the ending source column. If column information is missing (ex: language service does not support it), this value should be set to 0.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.EndLine">
      <summary>1-based integer for the ending source column.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.Equals(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan structure.</summary>
      <returns>True if the two elements are equal.</returns>
      <param name="other">Value to compare against this instance.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.GetHashCode">
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_Equality(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_GreaterThan(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_GreaterThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_Inequality(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_LessThan(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.op_LessThanOrEqual(Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan,Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan)">
      <summary>Compares two elements of the DkmTextSpan sructure.</summary>
      <returns>Returns <see cref="T:System.Boolean" />.</returns>
      <param name="element0">Left side of the comparison.</param>
      <param name="element1">Right side of the comparison.</param>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.StartColumn">
      <summary>1-based integer for the starting source column. If column information is missing (ex: language service does not support it), this value should be set to 0.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.Symbols.DkmTextSpan.StartLine">
      <summary>1-based integer for the starting source line.</summary>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult">
      <summary>Result of an asynchronous DkmThread.GetManagedThreadProperties call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult.#ctor(System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmThread.GetManagedThreadProperties.</summary>
      <param name="ManagedThreadId">[In] The managed thread id of the thread.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmThread.GetManagedThreadProperties.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetManagedThreadPropertiesAsyncResult.ManagedThreadId">
      <summary>The managed thread id of the thread.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstance.GetThreadDisplayProperties call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.#ctor(System.String,System.Int32,System.Int32)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeInstance.GetThreadDisplayProperties.</summary>
      <param name="DisplayName">[In,Optional] The Thread Display Name.</param>
      <param name="DisplayNamePriority">[In,Optional] The Thread Name Priority: Values are from DISPLAY_NAME_PRI as defined in MSDBG100.</param>
      <param name="ThreadCategory">[In,Optional] Values are from THREADCATEGORY as defined in EnvDTE90.dll/.tlb.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstance.GetThreadDisplayProperties.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.DisplayName">
      <summary>[Optional] The Thread Display Name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.DisplayNamePriority">
      <summary>[Optional] The Thread Name Priority: Values are from DISPLAY_NAME_PRI as defined in MSDBG100.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadDisplayPropertiesAsyncResult.ThreadCategory">
      <summary>[Optional] Values are from THREADCATEGORY as defined in EnvDTE90.dll/.tlb.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult">
      <summary>Result of an asynchronous DkmRuntimeInstance.GetThreadName call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult.#ctor(System.String)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmRuntimeInstance.GetThreadName.</summary>
      <param name="Name">[In,Optional] The Thread Name.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmRuntimeInstance.GetThreadName.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetThreadNameAsyncResult.Name">
      <summary>[Optional] The Thread Name.</summary>
      <returns>Returns <see cref="T:System.String" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult">
      <summary>Result of an asynchronous DkmThread.GetVolatileFlags call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult.#ctor(Microsoft.VisualStudio.Debugger.ThreadProperties.DkmVolatileThreadFlags)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmThread.GetVolatileFlags.</summary>
      <param name="Flags">[In] Volatile flags that apply to a thread. These values are expected to change over time and should not be cached by callers.</param>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmThread.GetVolatileFlags.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatileFlagsAsyncResult.Flags">
      <summary>Volatile flags that apply to a thread. These values are expected to change over time and should not be cached by callers.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmVolatileThreadFlags" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult">
      <summary>Result of an asynchronous DkmThread.GetVolatileProperties call.</summary>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult.#ctor(System.Int32,System.UInt64)">
      <summary>Creates a new result structure to hold the output from a successful call to DkmThread.GetVolatileProperties.</summary>
      <param name="Priority">[In] The priority of the thread. The values returned correspond to the values defined for kernel32!GetThreadPriority.</param>
      <param name="AffinityMask">[In] The affinity mask of the thread. The values returned correspond to the values defined for kernel32!SetThreadAffinityMask.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult.AffinityMask">
      <summary>The affinity mask of the thread. The values returned correspond to the values defined for kernel32!SetThreadAffinityMask.</summary>
      <returns>Returns <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult.CreateErrorResult(System.Exception)">
      <summary>Creates a new result structure to hold the error from a failed call to DkmThread.GetVolatileProperties.</summary>
      <returns>Returns <see cref="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult" />.</returns>
      <param name="exception">[In] exception object that contains the error.</param>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult.ErrorCode">
      <summary>HRESULT code returned from the caller. This will be DkmExceptionCode.COR_E_OPERATIONCANCELED (0x8013153B) if the operation was canceled before processing was completed.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="P:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmGetVolatilePropertiesAsyncResult.Priority">
      <summary>The priority of the thread. The values returned correspond to the values defined for kernel32!GetThreadPriority.</summary>
      <returns>Returns <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="T:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmVolatileThreadFlags">
      <summary>Volatile flags that apply to a thread. These values are expected to change over time and should not be cached by callers.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmVolatileThreadFlags.None">
      <summary>No flags are set.</summary>
    </member>
    <member name="F:Microsoft.VisualStudio.Debugger.ThreadProperties.DkmVolatileThreadFlags.UserModeScheduled">
      <summary>The thread is a user-mode scheduled helper or scheduler thread.</summary>
    </member>
  </members>
</doc>