<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.VisualStudio.Threading</name>
    </assembly>
    <members>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent">
            <summary>
            An asynchronous implementation of an AutoResetEvent.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.signalAwaiters">
            <summary>
            A queue of folks awaiting signals.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.allowInliningAwaiters">
            <summary>
            Whether to complete the task synchronously in the <see cref="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set"/> method,
            as opposed to asynchronously.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.signaled">
            <summary>
            A value indicating whether this event is already in a signaled state.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent"/> class
            that does not inline awaiters.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent"/> class.
            </summary>
            <param name="allowInliningAwaiters">
            A value indicating whether to complete the task synchronously in the <see cref="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set"/> method,
            as opposed to asynchronously. <c>false</c> better simulates the behavior of the
            <see cref="T:System.Threading.AutoResetEvent"/> class, but <c>true</c> can result in slightly better performance.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.WaitAsync">
            <summary>
            Returns an awaitable that may be used to asynchronously acquire the next signal.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncAutoResetEvent.Set">
            <summary>
            Sets the signal if it has not already been set, allowing one awaiter to handle the signal if one is already waiting.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncBarrier">
            <summary>
            An asynchronous barrier that blocks the signaler until all other participants have signaled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncBarrier.participantCount">
            <summary>
            The number of participants being synchronized.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncBarrier.remainingParticipants">
            <summary>
            The number of participants that have not yet signaled the barrier.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncBarrier.waiters">
            <summary>
            The set of participants who have reached the barrier, with their awaiters that can resume those participants.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncBarrier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncBarrier"/> class.
            </summary>
            <param name="participants">The number of participants.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncBarrier.SignalAndWait">
            <summary>
            Signals that a participant has completed work, and returns an awaitable
            that completes when all other participants have also completed work.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncCountdownEvent">
            <summary>
            An asynchronous style countdown event.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.manualEvent">
            <summary>
            The manual reset event we use to signal all awaiters.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.remainingCount">
            <summary>
            The remaining number of signals required before we can unblock waiters.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncCountdownEvent"/> class.
            </summary>
            <param name="initialCount">The number of signals required to unblock awaiters.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.WaitAsync">
            <summary>
            Returns an awaitable that executes the continuation when the countdown reaches zero.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.SignalAsync">
            <summary>
            Decrements the counter by one.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncCountdownEvent.SignalAndWaitAsync">
            <summary>
            Decrements the counter by one and returns an awaitable that executes the continuation when the countdown reaches zero.
            </summary>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncEventHandler">
            <summary>
            An asynchronous event handler.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="args">Event arguments.</param>
            <returns>A task whose completion signals handling is finished.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncEventHandler`1">
            <summary>
            An asynchronous event handler.
            </summary>
            <typeparam name="T">The type of <see cref="T:System.EventArgs"/></typeparam>
            <param name="sender">The sender of the event.</param>
            <param name="args">Event arguments.</param>
            <returns>A task whose completion signals handling is finished.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLazy`1">
            <summary>
            A thread-safe, lazily and asynchronously evaluated value factory.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.syncObject">
            <summary>
            The object to lock to provide thread-safety.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.identity">
            <summary>
            The unique instance identifier.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.valueFactory">
            <summary>
            The function to invoke to produce the task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.jobFactory">
            <summary>
            The async pump to Join on calls to <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync"/>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.value">
            <summary>
            The result of the value factory.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLazy`1.joinableTask">
            <summary>
            A joinable task whose result is the value to be cached.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}},Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncLazy`1"/> class.
            </summary>
            <param name="valueFactory">The async function that produces the value.  To be invoked at most once.</param>
            <param name="joinableTaskFactory">The factory to use when invoking the value factory in <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync"/> to avoid deadlocks when the main thread is required by the value factory.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync">
            <summary>
            Gets the task that produces or has produced the value.
            </summary>
            <returns>A task whose result is the lazily constructed value.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the value factory calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.GetValueAsync"/> on this instance.
            </exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncLazy`1.ToString">
            <summary>
            Renders a string describing an uncreated value, or the string representation of the created value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLazy`1.IsValueCreated">
            <summary>
            Gets a value indicating whether the value factory has been invoked.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLocal`1">
            <summary>
            Stores reference types in the CallContext such that marshaling is safe.
            </summary>
            <typeparam name="T">The type of value to store.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLocal`1.valueTable">
            <summary>
            A weak reference table that associates simple objects with some specific type that cannot be marshaled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLocal`1.reverseLookupTable">
            <summary>
            A table that is used to look up a previously stored simple object to represent a given value.
            </summary>
            <remarks>
            This is just an optimization. We could totally remove this field and all use of it and the tests still pass,
            amazingly enough.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncLocal`1.callContextKey">
            <summary>
            A unique GUID that prevents this instance from conflicting with other instances.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncLocal`1.Value">
            <summary>
            Gets or sets the value to associate with the current CallContext.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncLocal`1.IdentityNode">
            <summary>
            A simple marshalable object that can retain identity across app domain transitions.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncQueue`1">
            <summary>
            A thread-safe, asynchronously dequeuable queue.
            </summary>
            <typeparam name="T">The type of values kept by the queue.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.syncObject">
            <summary>
            The object to lock when reading/writing the internal data structures.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.dequeuingTasks">
            <summary>
            The tasks wanting to dequeue elements from the stack, grouped by their cancellation tokens. Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.completedSource">
            <summary>
            The source of the task returned by <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion"/>. Lazily constructed.
            </summary>
            <remarks>
            Volatile to allow the check-lock-check pattern in <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion"/> to be reliable,
            in the event that within the lock, one thread initializes the value and assigns the field
            and the weak memory model allows the assignment prior to the initialization. Another thread
            outside the lock might observe the non-null field and start accessing the Task property
            before it is actually initialized. Volatile prevents CPU reordering of commands around
            the assignment (or read) of this field.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.queueElements">
            <summary>
            The internal queue of elements. Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.completeSignaled">
            <summary>
            A value indicating whether <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete"/> has been called.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.onCompletedInvoked">
            <summary>
            A flag indicating whether the <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnCompleted"/> has been invoked.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncQueue`1"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete">
            <summary>
            Signals that no further elements will be enqueued.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Enqueue(`0)">
            <summary>
            Adds an element to the tail of the queue.
            </summary>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryEnqueue(`0)">
            <summary>
            Adds an element to the tail of the queue if it has not yet completed.
            </summary>
            <param name="value">The value to add.</param>
            <returns><c>true</c> if the value was added to the queue; <c>false</c> if the queue is already completed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryPeek(`0@)">
            <summary>
            Gets the value at the head of the queue without removing it from the queue, if it is non-empty.
            </summary>
            <param name="value">Receives the value at the head of the queue; or the default value for the element type if the queue is empty.</param>
            <returns><c>true</c> if the queue was non-empty; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Peek">
            <summary>
            Gets the value at the head of the queue without removing it from the queue.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the queue is empty.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a task whose result is the element at the head of the queue.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation signals lost interest in the item.
            Cancelling this token does *not* guarantee that the task will be canceled
            before it is assigned a resulting element from the head of the queue.
            It is the responsibility of the caller to ensure after cancellation that 
            either the task is canceled, or it has a result which the caller is responsible
            for then handling.
            </param>
            <returns>A task whose result is the head element.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available,
            otherwise returns without an element.
            </summary>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.ToArray">
            <summary>
            Returns a copy of this queue as an array.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeue(System.Predicate{`0},`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available
            that satisfies the specified check;
            otherwise returns without an element.
            </summary>
            <param name="valueCheck">The test on the head element that must succeed to dequeue.</param>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnEnqueued(`0,System.Boolean)">
            <summary>
            Invoked when a value is enqueued.
            </summary>
            <param name="value">The enqueued value.</param>
            <param name="alreadyDispatched">
            <c>true</c> if the item will skip the queue because a dequeuer was already waiting for an item;
            <c>false</c> if the item was actually added to the queue.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnDequeued(`0)">
            <summary>
            Invoked when a value is dequeued.
            </summary>
            <param name="value">The dequeued value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.OnCompleted">
            <summary>
            Invoked when the queue is completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.TryDequeueInternal(System.Predicate{`0},`0@)">
            <summary>
            Immediately dequeues the element from the head of the queue if one is available,
            otherwise returns without an element.
            </summary>
            <param name="valueCheck">The test on the head element that must succeed to dequeue.</param>
            <param name="value">Receives the element from the head of the queue; or <c>default(T)</c> if the queue is empty.</param>
            <returns><c>true</c> if an element was dequeued; <c>false</c> if the queue was empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancelDequeuers(System.Object)">
            <summary>
            Cancels all outstanding dequeue tasks for the specified CancellationToken.
            </summary>
            <param name="state">A <see cref="T:System.Tuple`2"/> instance.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CompleteIfNecessary(System.Boolean)">
            <summary>
            Transitions this queue to a completed state if signaled and the queue is empty.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.IsEmpty">
            <summary>
            Gets a value indicating whether the queue is currently empty.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Count">
            <summary>
            Gets the number of elements currently in the queue.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.IsCompleted">
            <summary>
            Gets a value indicating whether the queue has completed.
            </summary>
            <remarks>
            This is arguably redundant with <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion"/>.IsCompleted, but this property
            won't cause the lazy instantiation of the Task that <see cref="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion"/> may if there
            is no other reason for the Task to exist.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.Completion">
            <summary>
            Gets a task that transitions to a completed state when <see cref="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.Complete"/> is called.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.SyncRoot">
            <summary>
            Gets the synchronization object used by this queue.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.InitialCapacity">
            <summary>
            Gets the initial capacity for the queue.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers">
            <summary>
            Tracks cancellation registration and a list of dequeuers
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.owningQueue">
            <summary>
            The queue that owns this instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.cancellationRegistration">
            <summary>
            Gets the cancellation registration.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.completionSources">
            <summary>
            Gets the list of dequeuers.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.#ctor(Microsoft.VisualStudio.Threading.AsyncQueue{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers"/> struct.
            </summary>
            <param name="owningQueue">The queue that created this instance.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.Dispose">
            <summary>
            Disposes of the cancellation registration.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.GetEnumerator">
            <summary>
            Enumerates all the dequeurs in this instance.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.SetCancellationRegistration(System.Threading.CancellationTokenRegistration)">
            <summary>
            Sets the cancellation token registration associated with this instance.
            </summary>
            <param name="cancellationRegistration">The cancellation registration to dispose of when this value is disposed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.AddCompletionSource(System.Threading.Tasks.TaskCompletionSource{`0})">
            <summary>
            Adds a dequeuer to this instance.
            </summary>
            <param name="dequeuer"></param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.PopDequeuer">
            <summary>
            Pops off one dequeuer from this instance.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncQueue`1.CancellableDequeuers.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock">
            <summary>
            A non-blocking lock that allows concurrent access, exclusive access, or concurrent with upgradeability to exclusive access.
            </summary>
            <remarks>
            We have to use a custom awaitable rather than simply returning Task{LockReleaser} because 
            we have to set CallContext data in the context of the person receiving the lock,
            which requires that we get to execute code at the start of the continuation (whether we yield or not).
            </remarks>
            <devnotes>
            Considering this class to be a state machine, the states are:
            <![CDATA[
               ------------- 
               |           | <-----> READERS
               |    IDLE   | <-----> UPGRADEABLE READER + READERS -----> UPGRADED WRITER --\
               |  NO LOCKS |                             ^                                 |
               |           |                             |--- RE-ENTER CONCURRENCY PREP <--/
               |           | <-----> WRITER
               ------------- 
            ]]>
            </devnotes>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.IHangReportContributor">
            <summary>
            Provides a facility to produce reports that may be useful when analyzing hangs.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IHangReportContributor.GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DgmlNamespace">
            <summary>
            The namespace that all DGML nodes appear in.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Microsoft#VisualStudio#Threading#IHangReportContributor#GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution. Null values should be ignored.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CreateAwaiterNode(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Appends details of a given collection of awaiters to the hang report.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.syncObject">
            <summary>
            The object to acquire a Monitor-style lock on for all field access on this instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.nonConcurrentSyncContext">
            <summary>
            The synchronization context applied to folks who hold upgradeable read and write locks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.topAwaiter">
            <summary>
            A CallContext-local reference to the Awaiter that is on the top of the stack (most recently acquired).
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedReadLocks">
            <summary>
            The set of read locks that are issued and active.
            </summary>
            <remarks>
            Many readers are allowed concurrently.  Also, readers may re-enter read locks (recursively)
            each of which gets an element in this set.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedUpgradeableReadLocks">
            <summary>
            The set of upgradeable read locks that are issued and active.
            </summary>
            <remarks>
            Although only one upgradeable read lock can be held at a time, this set may have more
            than one element because that one lock holder may enter the lock it already possesses 
            multiple times.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedWriteLocks">
            <summary>
            The set of write locks that are issued and active.
            </summary>
            <remarks>
            Although only one write lock can be held at a time, this set may have more
            than one element because that one lock holder may enter the lock it already possesses 
            multiple times.
            Although this lock is mutually exclusive, there *may* be elements in the
            <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.issuedUpgradeableReadLocks"/> set if the write lock was upgraded from a reader.
            Also note that some elements in this may themselves be upgradeable readers if they have
            the <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite"/> flag.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingReaders">
            <summary>
            A queue of readers waiting to obtain the concurrent read lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingUpgradeableReaders">
            <summary>
            A queue of upgradeable readers waiting to obtain a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.waitingWriters">
            <summary>
            A queue of writers waiting to obtain an exclusive lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.completionSource">
            <summary>
            The source of the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion"/> task, which transitions to completed after
            the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete"/> method is called and all issued locks have been released.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.beforeWriteReleasedCallbacks">
            <summary>
            The queue of callbacks to invoke when the currently held write lock is totally released.
            </summary>
            <remarks>
            If the write lock is released to an upgradeable read lock, these callbacks are fired synchronously
            with respect to the writer who is releasing the lock.  Otherwise, the callbacks are invoked
            asynchronously with respect to the releasing thread.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.captureDiagnostics">
            <summary>
            A value indicating whether extra resources should be spent to collect diagnostic information
            that may be useful in deadlock investigations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.reenterConcurrencyPrepRunning">
            <summary>
            A flag indicating whether we're currently running code to prepare for re-entering concurrency mode
            after releasing an exclusive lock. The Awaiter being released is the non-null value.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.completeInvoked">
            <summary>
            A flag indicating that the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete"/> method has been called, indicating that no
            new top-level lock requests should be serviced.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock"/> class.
            </summary>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.UpgradeableReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains an upgradeable read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.UpgradeableReadLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.WriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.WriteLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HideLocks">
            <summary>
            Prevents use or visibility of the caller's lock(s) until the returned value is disposed.
            </summary>
            <returns>The value to dispose to restore lock visibility.</returns>
            <remarks>
            This can be used by a write lock holder that is about to fork execution to avoid
            two threads simultaneously believing they hold the exclusive write lock.
            The lock should be hidden just before kicking off the work and can be restored immediately
            after kicking off the work.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete">
            <summary>
            Causes new top-level lock requests to be rejected and the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion"/> task to transition
            to a completed state after any issued locks have been released.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeWriteLockReleased(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Registers a callback to be invoked when the write lock held by the caller is 
            about to be ultimately released (outermost write lock).
            </summary>
            <param name="action">
            The asynchronous delegate to invoke.
            Access to the write lock is provided throughout the asynchronous invocation.
            </param>
            <remarks>
            This supports some scenarios VC++ has where change event handlers need to inspect changes,
            or follow up with other changes to respond to earlier changes, at the conclusion of the lock.
            This method is safe to call from within a previously registered callback, in which case the
            registered callback will run when previously registered callbacks have completed execution.
            If the write lock is released to an upgradeable read lock, these callbacks are fired synchronously
            with respect to the writer who is releasing the lock.  Otherwise, the callbacks are invoked
            asynchronously with respect to the releasing thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)">
            <summary>
            Checks whether the aggregated flags from all locks in the lock stack satisfy the specified flag(s).
            </summary>
            <param name="flags">The flag(s) that must be specified for a <c>true</c> result.</param>
            <param name="handle">The head of the lock stack to consider.</param>
            <returns><c>true</c> if all the specified flags are found somewhere in the lock stack; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetAggregateLockFlags">
            <summary>
            Returns the aggregate of the lock flags for all nested locks.
            </summary>
            <remarks>
            This is not redundant with <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)"/> because that returns fast
            once the presence of certain flag(s) is determined, whereas this will aggregate all flags,
            some of which may be defined by derived types.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeLockReleasedAsync(System.Boolean,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle)">
            <summary>
            Fired when any lock is being released.
            </summary>
            <param name="exclusiveLockRelease"><c>true</c> if the last write lock that the caller holds is being released; <c>false</c> otherwise.</param>
            <param name="releasingLock">The lock being released.</param>
            <returns>A task whose completion signals the conclusion of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnBeforeExclusiveLockReleasedAsync">
            <summary>
            Fired when the last write lock is about to be released.
            </summary>
            <returns>A task whose completion signals the conclusion of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ThrowIfStaOrUnsupportedSyncContext">
            <summary>
            Throws an exception if called on an STA thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockSupportingContext(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether the caller's thread apartment model and SynchronizationContext
            is compatible with a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CompleteIfAppropriate">
            <summary>
            Transitions the <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion"/> task to a completed state
            if appropriate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AggregateLockStackKinds(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Detects which lock types the given lock holder has (including all nested locks).
            </summary>
            <param name="awaiter">The most nested lock to be considered.</param>
            <param name="read">Receives a value indicating whether a read lock is held.</param>
            <param name="upgradeableRead">Receives a value indicating whether an upgradeable read lock is held.</param>
            <param name="write">Receives a value indicating whether a write lock is held.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AllHeldLocksAreByThisStack(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether all issued locks are merely the top-level lock or nesting locks of the specified lock.
            </summary>
            <param name="awaiter">The most nested lock.</param>
            <returns><c>true</c> if all issued locks are the specified lock or nesting locks of it.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockStackContains(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Gets a value indicating whether the specified lock is, or is a nested lock of, a given type.
            </summary>
            <param name="kind">The kind of lock being queried for.</param>
            <param name="awaiter">The (possibly nested) lock.</param>
            <returns><c>true</c> if the lock holder (also) holds the specified kind of lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsStickyWriteUpgradedLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified lock is an upgradeable read lock, with a <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite"/> flag,
            which has actually be upgraded.
            </summary>
            <param name="awaiter">The lock to test.</param>
            <returns><c>true</c> if the test succeeds; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockHeld(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Checks whether the caller's held locks (or the specified lock stack) includes an active lock of the specified type.
            Always <c>false</c> when called on an STA thread.
            </summary>
            <param name="kind">The type of lock to check for.</param>
            <param name="awaiter">The most nested lock of the caller, or null to look up the caller's lock in the CallContext.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
            <param name="allowNonLockSupportingContext"><c>true</c> to return true when a lock is held but unusable because of the context of the caller.</param>
            <returns><c>true</c> if the caller holds active locks of the given type; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsLockActive(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Checks whether a given lock is active. 
            Always <c>false</c> when called on an STA thread.
            </summary>
            <param name="awaiter">The lock to check.</param>
            <param name="considerStaActive">if <c>false</c> the return value will always be <c>false</c> if called on an STA thread.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
            <returns><c>true</c> if the lock is currently issued and the caller is not on an STA thread.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CheckSynchronizationContextAppropriateForLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified awaiter's lock type has an associated SynchronizationContext if one is applicable.
            </summary>
            <param name="awaiter">The awaiter whose lock should be considered.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryIssueLock(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean)">
            <summary>
            Immediately issues a lock to the specified awaiter if it is available.
            </summary>
            <param name="awaiter">The awaiter to issue a lock to.</param>
            <param name="previouslyQueued">
            A value indicating whether this lock was previously queued.  <c>false</c> if this is a new just received request.
            The value is used to determine whether to reject it if <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete"/> has already been called and this
            is a new top-level request.
            </param>
            <returns>A value indicating whether the lock was issued.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.FindRootUpgradeableReadWithStickyWrite(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Finds the upgradeable reader with <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite"/> flag that is nearest
            to the top-level lock request held by the given lock holder.
            </summary>
            <param name="headAwaiter"></param>
            <returns>The least nested upgradeable reader lock with sticky write flag; or <c>null</c> if none was found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetActiveLockSet(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)">
            <summary>
            Gets the set of locks of a given kind.
            </summary>
            <param name="kind">The kind of lock.</param>
            <returns>A set of locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetLockQueue(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind)">
            <summary>
            Gets the queue for a lock with a given type.
            </summary>
            <param name="kind">The kind of lock.</param>
            <returns>A queue.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.GetFirstActiveSelfOrAncestor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Walks the nested lock stack until it finds an active one.
            </summary>
            <param name="awaiter">The most nested lock to consider.  May be null.</param>
            <returns>The first active lock encountered, or <c>null</c> if none.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IssueAndExecute(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Issues a lock to the specified awaiter and executes its continuation.
            The awaiter should have already been dequeued.
            </summary>
            <param name="awaiter">The awaiter to issue a lock to and execute.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnExclusiveLockReleasedAsync">
            <summary>
            Invoked after an exclusive lock is released but before anyone has a chance to enter the lock.
            </summary>
            <remarks>
            This method is called while holding a private lock in order to block future lock consumers till this method is finished.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnCriticalFailure(System.Exception)">
            <summary>
            Invoked when the lock detects an internal error or illegal usage pattern that
            indicates a serious flaw that should be immediately reported to the application
            and/or bring down the process to avoid hangs or data corruption.
            </summary>
            <param name="ex">The exception that captures the details of the failure.</param>
            <returns>An exception that may be returned by some implementations of tis method for he caller to rethrow.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnCriticalFailure(System.String)">
            <summary>
            Invoked when the lock detects an internal error or illegal usage pattern that
            indicates a serious flaw that should be immediately reported to the application
            and/or bring down the process to avoid hangs or data corruption.
            </summary>
            <param name="message">The message to use for the exception.</param>
            <returns>An exception that may be returned by some implementations of tis method for he caller to rethrow.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ReleaseAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean)">
            <summary>
            Releases the lock held by the specified awaiter.
            </summary>
            <param name="awaiter">The awaiter holding an active lock.</param>
            <param name="lockConsumerCanceled">A value indicating whether the lock consumer ended up not executing any work.</param>
            <returns>
            A task that should complete before the releasing thread accesses any resource protected by
            a lock wrapping the lock being released.
            The task will always be complete if <paramref name="lockConsumerCanceled"/> is <c>true</c>.
            This method guarantees that the lock is effectively released from the caller, and the <paramref name="awaiter"/>
            can be safely recycled, before the synchronous portion of this method completes.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.DowngradeLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean,System.Threading.Tasks.Task)">
            <summary>
            Schedules work on a background thread that will prepare protected resource(s) for concurrent access.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HasAnyNestedLocks(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Checks whether the specified lock has any active nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.HasAnyNestedLocks(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter})">
            <summary>
            Checks whether the specified lock has any active nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.OnReleaseReenterConcurrencyComplete(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean,System.Boolean)">
            <summary>
            Called at the conclusion of releasing an exclusive lock to complete the transition.
            </summary>
            <param name="awaiter">The awaiter being released.</param>
            <param name="upgradedStickyWrite">A flag indicating whether the lock being released was an upgraded read lock with the sticky write flag set.</param>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeLockConsumer(System.Boolean)">
            <summary>
            Issues locks to one or more queued lock requests and executes their continuations
            based on lock availability and policy-based prioritization (writer-friendly, etc.)
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns><c>true</c> if any locks were issued; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.InvokeBeforeWriteLockReleaseHandlersAsync">
            <summary>
            Invokes the final write lock release callbacks, if appropriate.
            </summary>
            <returns>A task representing the work of sequentially invoking the callbacks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryDequeueBeforeWriteReleasedCallback(System.Func{System.Threading.Tasks.Task}@)">
            <summary>
            Dequeues a single write lock release callback if available.
            </summary>
            <param name="callback">Receives the callback to invoke, if any.</param>
            <returns>A value indicating whether a callback was available to invoke.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ApplyLockToCallContext(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Stores the specified lock in the CallContext dictionary.
            </summary>
            <param name="topAwaiter"></param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeAllReadersIfAppropriate(System.Boolean)">
            <summary>
            Issues locks to all queued reader lock requests if there are no issued write locks.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether any readers were issued locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeOneUpgradeableReaderIfAppropriate(System.Boolean)">
            <summary>
            Issues a lock to the next queued upgradeable reader, if no upgradeable read or write locks are currently issued.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether any upgradeable readers were issued locks.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeOneWriterIfAppropriate(System.Boolean)">
            <summary>
            Issues a lock to the next queued writer, if no other locks are currently issued 
            or the last contending read lock was removed allowing a waiting upgradeable reader to upgrade.
            </summary>
            <param name="searchAllWaiters"><c>true</c> to scan the entire queue for pending lock requests that might qualify; used when qualifying locks were delayed for some reason besides lock contention.</param>
            <returns>A value indicating whether a writer was issued a lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.TryInvokeAnyWaitersInQueue(System.Collections.Generic.Queue{Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter},System.Boolean)">
            <summary>
            Scans a lock awaiter queue for any that can be issued locks now.
            </summary>
            <param name="waiters">The queue to scan.</param>
            <param name="breakOnFirstIssue"><c>true</c> to break out immediately after issuing the first lock.</param>
            <returns><c>true</c> if any lock was issued; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.PendAwaiter(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Issues a lock to a lock waiter and execute its code if the lock is immediately available, otherwise
            queues the lock request.
            </summary>
            <param name="awaiter">The lock request.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.ExecuteOrHandleCancellation(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,System.Boolean)">
            <summary>
            Executes the lock receiver or releases the lock because the request for it was canceled before it was issued.
            </summary>
            <param name="awaiter">The awaiter.</param>
            <param name="stillInQueue">A value indicating whether the specified <paramref name="awaiter"/> is expected to still be in the queue (and should be removed).</param>
            <returns>A value indicating whether a continuation delegate was actually invoked.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsAnyLockHeld">
            <summary>
            Gets a value indicating whether any kind of lock is held by the caller and can
            be immediately used given the caller's context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsAnyPassiveLockHeld">
            <summary>
            Gets a value indicating whether any kind of lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsReadLockHeld">
            <summary>
            Gets a value indicating whether the caller holds a read lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveReadLockHeld">
            <summary>
            Gets a value indicating whether a read lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsUpgradeableReadLockHeld">
            <summary>
            Gets a value indicating whether the caller holds an upgradeable read lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveUpgradeableReadLockHeld">
            <summary>
            Gets a value indicating whether an upgradeable read lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsWriteLockHeld">
            <summary>
            Gets a value indicating whether the caller holds a write lock.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsPassiveWriteLockHeld">
            <summary>
            Gets a value indicating whether a write lock is held by the caller without regard
            to the lock compatibility of the caller's context.
            </summary>
            <remarks>
            This property returns <c>false</c> if any other lock type is held, unless
            within that alternate lock type this lock is also nested.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Completion">
            <summary>
            Gets a task whose completion signals that this lock will no longer issue locks.
            </summary>
            <remarks>
            This task only transitions to a complete state after a call to <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Complete"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.SyncObject">
            <summary>
            Gets the object used to synchronize access to this instance's fields.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.AmbientLock">
            <summary>
            Gets the lock held by the caller's execution context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.CaptureDiagnostics">
            <summary>
            Gets or sets a value indicating whether additional resources should be spent to collect
            information that would be useful in diagnosing deadlocks, etc.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.IsUnsupportedSynchronizationContext">
            <summary>
            Gets a value indicating whether the current SynchronizationContext is one that is not supported
            by this lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags">
            <summary>
            Flags that modify default lock behavior.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.None">
            <summary>
            The default behavior applies.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags.StickyWrite">
            <summary>
            Causes an upgradeable reader to remain in an upgraded-write state once upgraded,
            even after the nested write lock has been released.
            </summary>
            <remarks>
            This is useful when you have a batch of possible write operations to apply, which
            may or may not actually apply in the end, but if any of them change anything,
            all of their changes should be seen atomically (within a single write lock).
            This approach is preferable to simply acquiring a write lock around the batch of
            potential changes because it doesn't defeat concurrent readers until it knows there
            is a change to actually make.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind">
            <summary>
            An enumeration of the kinds of locks supported by this class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Read">
            <summary>
            A lock that supports concurrently executing threads that hold this same lock type.
            Holders of this lock may not obtain a <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Write"/> lock without first
            releasing all their <see cref="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Read"/> locks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.UpgradeableRead">
            <summary>
            A lock that may run concurrently with standard readers, but is exclusive of any other
            upgradeable readers.  Holders of this lock are allowed to obtain a write lock while
            holding this lock to guarantee continuity of state between what they read and what they write.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind.Write">
            <summary>
            A mutually exclusive lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable">
            <summary>
            An awaitable that is returned from asynchronous lock requests.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.awaiter">
            <summary>
            The awaiter to return from the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.GetAwaiter"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable"/> struct.
            </summary>
            <param name="lck">The lock class that created this instance.</param>
            <param name="kind">The type of lock being requested.</param>
            <param name="options">Any flags applied to the lock request.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="checkSyncContextCompatibility"><c>true</c> to throw an exception if the caller has an exclusive lock but not an associated SynchronizationContext.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable.GetAwaiter">
            <summary>
            Gets the awaiter value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter">
            <summary>
            Manages asynchronous access to a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.cancellationResponseAction">
            <summary>
            A singleton delegate for use in cancellation token registration to avoid memory allocations for delegates each time.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.lck">
            <summary>
            The instance of the lock class to which this awaiter is affiliated.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.kind">
            <summary>
            The type of lock requested.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.nestingLock">
            <summary>
            The "parent" lock (i.e. the lock within which this lock is nested) if any.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.cancellationToken">
            <summary>
            The cancellation token that would terminate waiting for a lock that is not yet available.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.cancellationRegistration">
            <summary>
            The cancellation token event that should be disposed of to free memory when we no longer need to receive cancellation notifications.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.options">
            <summary>
            The flags applied to this lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.fault">
            <summary>
            Any exception to throw back to the lock requestor.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.continuation">
            <summary>
            The continuation to execute when the lock is available.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.releaseAsyncTask">
            <summary>
            The task from a prior call to <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.ReleaseAsync(System.Boolean)"/>, if any.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.requestingStackTrace">
            <summary>
            The stacktrace of the caller originally requesting the lock.
            </summary>
            <remarks>
            This field is initialized only when <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock"/> is constructed with
            the captureDiagnostics parameter set to <c>true</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.data">
            <summary>
            An arbitrary object that may be set by a derived type of the containing lock class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockKind,Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter"/> class.
            </summary>
            <param name="lck">The lock class creating this instance.</param>
            <param name="kind">The type of lock being requested.</param>
            <param name="options">The flags to apply to the lock.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.OnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.GetResult">
            <summary>
            Applies the issued lock to the caller and returns the value used to release the lock.
            </summary>
            <returns>The value to dispose of to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.ReleaseAsync(System.Boolean)">
            <summary>
            Releases the lock and recycles this instance.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.TryScheduleContinuationExecution">
            <summary>
            Executes the code that requires the lock.
            </summary>
            <returns><c>true</c> if the continuation was (asynchronously) invoked; <c>false</c> if there was no continuation available to invoke.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.SetFault(System.Exception)">
            <summary>
            Specifies the exception to throw from <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.GetResult"/>
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.CancellationResponder(System.Object)">
            <summary>
            Responds to lock request cancellation.
            </summary>
            <param name="state">The <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter"/> instance being canceled.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the lock has been issued.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.OwningLock">
            <summary>
            Gets the lock instance that owns this awaiter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.RequestingStackTrace">
            <summary>
            Gets the stack trace of the requestor of this lock.
            </summary>
            <remarks>
            Used for diagnostic purposes only.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.NestingLock">
            <summary>
            Gets the lock that the caller held before requesting this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Data">
            <summary>
            Gets or sets an arbitrary object that may be set by a derived type of the containing lock class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.CancellationToken">
            <summary>
            Gets the cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Kind">
            <summary>
            Gets the kind of lock being requested.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.Options">
            <summary>
            The flags applied to this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter.LockIssued">
            <summary>
            Gets a value indicating whether the lock is active.
            </summary>
            <value><c>true</c> iff the lock has bee issued, has not yet been released, and the caller is on an MTA thread.</value>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.threadHoldingSemaphore">
            <summary>
            The thread that has entered the semaphore.
            </summary>
            <remarks>
            No reason to lock around access to this field because it is only ever set to
            or compared against the current thread, so the activity of other threads is irrelevant.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.PostHelper(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Executes the specified delegate.
            </summary>
            <remarks>
            We use async void instead of async Task because the caller will never
            use the result, and this way the compiler doesn't have to create the Task object.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.NonConcurrentSynchronizationContext.IsSemaphoreOccupied">
            <summary>
            Gets a value indicating whether the semaphore is currently occupied.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser">
            <summary>
            A value whose disposal releases a held lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.awaiter">
            <summary>
            The awaiter who manages the lifetime of a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser"/> struct.
            </summary>
            <param name="awaiter">The awaiter.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser.ReleaseAsync">
            <summary>
            Asynchronously releases the lock.  Dispose should still be called after this.
            </summary>
            <returns>
            A task that should complete before the releasing thread accesses any resource protected by
            a lock wrapping the lock being released.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression">
            <summary>
            A value whose disposal restores visibility of any locks held by the caller.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.lck">
            <summary>
            The locking class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.awaiter">
            <summary>
            The awaiter most recently acquired by the caller before hiding locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression"/> struct.
            </summary>
            <param name="lck">The lock class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Suppression.Dispose">
            <summary>
            Restores visibility of hidden locks.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle">
            <summary>
            A "public" representation of a specific lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.awaiter">
            <summary>
            The awaiter this lock handle wraps.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle"/> struct.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsValid">
            <summary>
            Gets a value indicating whether this handle is to a lock which was actually acquired.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsActive">
            <summary>
            Gets a value indicating whether this lock is still active.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsReadLock">
            <summary>
            Gets a value indicating whether this lock represents a read lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsUpgradeableReadLock">
            <summary>
            Gets a value indicating whether this lock represents an upgradeable read lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.IsWriteLock">
            <summary>
            Gets a value indicating whether this lock represents a write lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasReadLock">
            <summary>
            Gets a value indicating whether this lock is an active read lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasUpgradeableReadLock">
            <summary>
            Gets a value indicating whether this lock is an active upgradeable read lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.HasWriteLock">
            <summary>
            Gets a value indicating whether this lock is an active write lock or is nested by one.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Flags">
            <summary>
            Gets the flags that were passed into this lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Data">
            <summary>
            Gets or sets some object associated to this specific lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.NestingLock">
            <summary>
            Gets the lock within which this lock was acquired.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.LockHandle.Awaiter">
            <summary>
            Gets the wrapped awaiter.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncSemaphore">
            <summary>
            An asynchronous <see cref="T:System.Threading.SemaphoreSlim"/> like class with more convenient release syntax.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.semaphore">
            <summary>
            The semaphore used to keep concurrent access to this lock to just 1.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.uncontestedReleaser">
            <summary>
            A task to return for any uncontested request for the lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.canceledReleaser">
            <summary>
            A task that is cancelled.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore"/> class.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted concurrently.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="timeout">A timeout for waiting for the lock.</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.EnterAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="timeout">A timeout for waiting for the lock (in milliseconds).</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the lock.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.LockWaitingHelper(System.Threading.Tasks.Task)">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="waitTask">A task that represents a request for the semaphore.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.LockWaitingHelper(System.Threading.Tasks.Task{System.Boolean})">
            <summary>
            Requests access to the lock.
            </summary>
            <param name="waitTask">A task that represents a request for the semaphore.</param>
            <returns>A task whose result is a releaser that should be disposed to release the lock.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser">
            <summary>
            A value whose disposal triggers the release of a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.toRelease">
            <summary>
            The lock instance to release.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.#ctor(Microsoft.VisualStudio.Threading.AsyncSemaphore)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser"/> struct.
            </summary>
            <param name="toRelease">The lock instance to release on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncSemaphore.Releaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncManualResetEvent">
            <summary>
            A flavor of <see cref="T:System.Threading.ManualResetEvent"/> that can be asynchronously awaited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.allowInliningAwaiters">
            <summary>
            Whether to complete the task synchronously in the <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync"/> method,
            as opposed to asynchronously.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.taskCompletionSource">
            <summary>
            The task to return from <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync"/>
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncManualResetEvent"/> class.
            </summary>
            <param name="initialState">A value indicating whether the event should be initially signaled.</param>
            <param name="allowInliningAwaiters">
            A value indicating whether to allow <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync"/> callers' continuations to execute
            on the thread that calls <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync"/> before the call returns.
            <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync"/> callers should not hold private locks if this value is <c>true</c> to avoid deadlocks.
            When <c>false</c>, the task returned from <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync"/> may not have fully transitioned to
            its completed state by the time <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync"/> returns to its caller.
            </param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync">
            <summary>
            Returns a task that will be completed when this event is set.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.SetAsync">
            <summary>
            Sets this event to unblock callers of <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync"/>.
            </summary>
            <remarks>
            This method may return before the signal set has propagated (so <see cref="P:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.IsSet"/> may return <c>false</c> for a bit more if called immediately).
            The returned task completes when the signal has definitely been set.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.Reset">
            <summary>
            Resets this event to a state that will block callers of <see cref="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.WaitAsync"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.PulseAllAsync">
            <summary>
            Sets and immediately resets this event, allowing all current waiters to unblock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.GetAwaiter">
            <summary>
            Gets an awaiter that completes when this event is signaled.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncManualResetEvent.IsSet">
            <summary>
            Gets a value indicating whether the event is currently in a signaled state.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2">
            <summary>
            A non-blocking lock that allows concurrent access, exclusive access, or concurrent with upgradeability to exclusive access,
            making special allowances for resources that must be prepared for concurrent or exclusive access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.helper">
            <summary>
            A private nested class we use to isolate some of the behavior.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.#ctor">
            <summary>
            Initializes a new instance of the AsyncReaderWriterResourceLock class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the AsyncReaderWriterResourceLock class.
            </summary>
            <param name="captureDiagnostics">
            <c>true</c> to spend additional resources capturing diagnostic details that can be used
            to analyze deadlocks or other issues.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.UpgradeableReadLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.UpgradeableReadLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains an upgradeable read lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.WriteLockAsync(System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.  
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.WriteLockAsync(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Obtains a write lock, asynchronously awaiting for the lock if it is not immediately available.
            </summary>
            <param name="options">Modifications to normal lock behavior.</param>
            <param name="cancellationToken">
            A token whose cancellation indicates lost interest in obtaining the lock.
            A canceled token does not release a lock that has already been issued.  But if the lock isn't immediately available,
            a canceled token will cause the code that is waiting for the lock to resume with an <see cref="T:System.OperationCanceledException"/>.
            </param>
            <returns>An awaitable object whose result is the lock releaser.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Retrieves the resource with the specified moniker.
            </summary>
            <param name="resourceMoniker">The identifier for the desired resource.</param>
            <param name="cancellationToken">A token whose cancellation indicates lost interest in obtaining the resource.</param>
            <returns>A task whose result is the desired resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetResourceAsAccessed(`1)">
            <summary>
            Marks a resource as having been retrieved under a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetResourceAsAccessed(System.Func{`1,System.Object,System.Boolean},System.Object)">
            <summary>
            Marks any loaded resources as having been retrieved under a lock if they
            satisfy some predicate.
            </summary>
            <param name="resourceCheck">A function that returns <c>true</c> if the provided resource should be considered retrieved.</param>
            <param name="state">The state object to pass as a second parameter to <paramref name="resourceCheck"/></param>
            <returns><c>true</c> if the delegate returned <c>true</c> on any of the invocations.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.SetAllResourcesToUnknownState">
            <summary>
            Sets all the resources to be considered in an unknown state. 
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.GetAggregateLockFlags">
            <summary>
            Returns the aggregate of the lock flags for all nested locks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)">
            <summary>
            Prepares a resource for concurrent access.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in the resource.</param>
            <returns>A task whose completion signals the resource has been prepared.</returns>
            <remarks>
            This is invoked on a resource when it is initially requested for concurrent access,
            for both transitions from no access and exclusive access.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)">
            <summary>
            Prepares a resource for access by one thread.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="lockFlags">The aggregate of all flags from the active and nesting locks.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in the resource.</param>
            <returns>A task whose completion signals the resource has been prepared.</returns>
            <remarks>
            This is invoked on a resource when it is initially access for exclusive access,
            but only when transitioning from no access -- it is not invoked when transitioning
            from concurrent access to exclusive access.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.OnExclusiveLockReleasedAsync">
            <summary>
            Invoked after an exclusive lock is released but before anyone has a chance to enter the lock.
            </summary>
            <remarks>
            This method is called while holding a private lock in order to block future lock consumers till this method is finished.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags">
            <summary>
            Flags that modify default lock behavior.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.None">
            <summary>
            The default behavior applies.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.StickyWrite">
            <summary>
            Causes an upgradeable reader to remain in an upgraded-write state once upgraded,
            even after the nested write lock has been released.
            </summary>
            <remarks>
            This is useful when you have a batch of possible write operations to apply, which
            may or may not actually apply in the end, but if any of them change anything,
            all of their changes should be seen atomically (within a single write lock).
            This approach is preferable to simply acquiring a write lock around the batch of
            potential changes because it doesn't defeat concurrent readers until it knows there
            is a change to actually make.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.LockFlags.SkipInitialPreparation">
            <summary>
            Skips a step to make sure that the resource is initially prepared when retrieved using GetResourceAsync.
            </summary>
            <remarks>
            This flag is dormant for non-write locks.  But if present on an upgradeable read lock,
            this flag will activate for a nested write lock.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper">
            <summary>
            A helper class to isolate some specific functionality in this outer class.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.service">
            <summary>
            The owning lock instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceConcurrentDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceExclusiveDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceConcurrentContinuationDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForConcurrentAccessAsync(`1,System.Threading.CancellationToken)"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.prepareResourceExclusiveContinuationDelegate">
            <summary>
            A reusable delegate that invokes the <see cref="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.PrepareResourceForExclusiveAccessAsync(`1,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.LockFlags,System.Threading.CancellationToken)"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.resourcesAcquiredWithinUpgradeableRead">
            <summary>
            A collection of all the resources requested within the outermost upgradeable read lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.resourcesAcquiredWithinWriteLock">
            <summary>
            A collection of all the resources requested within the outermost write lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.resourcePreparationTasks">
            <summary>
            A map of resources to the tasks that most recently began evaluating them.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper"/> class.
            </summary>
            <param name="service">The owning lock instance.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetResourceAsAccessed(`1)">
            <summary>
            Marks a resource as having been retrieved under a lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetResourceAsAccessed(System.Func{`1,System.Object,System.Boolean},System.Object)">
            <summary>
            Marks any loaded resources as having been retrieved under a lock if they
            satisfy some predicate.
            </summary>
            <param name="resourceCheck">A function that returns <c>true</c> if the provided resource should be considered retrieved.</param>
            <param name="state">The state object to pass as a second parameter to <paramref name="resourceCheck"/></param>
            <returns><c>true</c> if the delegate returned <c>true</c> on any of the invocations.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.OnExclusiveLockReleasedAsync">
            <summary>
            Ensures that all resources are marked as unprepared so at next request they are prepared again.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.OnUpgradeableReadLockReleased">
            <summary>
            Invoked when a top-level upgradeable read lock is released, leaving no remaining (write) lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Retrieves the resource with the specified moniker.
            </summary>
            <param name="resourceMoniker">The identifier for the desired resource.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in this resource.</param>
            <returns>A task whose result is the desired resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetAllResourcesToUnknownState">
            <summary>
            Sets all the resources to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetUnknownResourceState(`1)">
            <summary>
            Sets the specified resource to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.SetUnknownResourceState(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Sets the specified resources to be considered in an unknown state. Any subsequent access (exclusive or concurrent) will prepare the resource.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.PrepareResourceAsync(`1,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Prepares the specified resource for access by a lock holder.
            </summary>
            <param name="resource">The resource to prepare.</param>
            <param name="cancellationToken">The token whose cancellation signals lost interest in this resource.</param>
            <param name="forcePrepareConcurrent">Force preparation of the resource for concurrent access, even if an exclusive lock is currently held.</param>
            <returns>A task that is completed when preparation has completed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.AcquirePreexistingLockOrThrow">
            <summary>
            Reserves a read lock from a previously held lock.
            </summary>
            <returns>The releaser for the read lock.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown if no lock is held by the caller.</exception>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity">
            <summary>
            Tracks a task that prepares a resource for either concurrent or exclusive use.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.#ctor(System.Threading.Tasks.Task,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper.ResourceState)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity"/> class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.PreparationTask">
            <summary>
            Gets the task that is preparing the resource.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.State">
            <summary>
            Gets the state the resource will be in when <see cref="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourcePreparationTaskAndValidity.PreparationTask"/> has completed.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState">
            <summary>
            Describes the states a resource can be in.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Unknown">
            <summary>
            The resource is neither prepared for concurrent nor exclusive access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Concurrent">
            <summary>
            The resource is prepared for concurrent access.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.Helper.ResourceState.Exclusive">
            <summary>
            The resource is prepared for exclusive access.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable">
            <summary>
            An awaitable that is returned from asynchronous lock requests.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.awaitable">
            <summary>
            The underlying lock awaitable.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaitable,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable"/> struct.
            </summary>
            <param name="awaitable">The underlying lock awaitable.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter">
            <summary>
            Manages asynchronous access to a lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.awaiter">
            <summary>
            The underlying lock awaiter.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Awaiter,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter"/> struct.
            </summary>
            <param name="awaiter">The underlying lock awaiter.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.OnCompleted(System.Action)">
            <summary>
            Sets the delegate to execute when the lock is available.
            </summary>
            <param name="continuation">The delegate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.GetResult">
            <summary>
            Applies the issued lock to the caller and returns the value used to release the lock.
            </summary>
            <returns>The value to dispose of to release the lock.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the lock has been issued.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser">
            <summary>
            A value whose disposal releases a held lock.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.releaser">
            <summary>
            The underlying lock releaser.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.helper">
            <summary>
            The helper class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.#ctor(Microsoft.VisualStudio.Threading.AsyncReaderWriterLock.Releaser,Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock{`0,`1}.Helper)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser"/> struct.
            </summary>
            <param name="releaser">The underlying lock releaser.</param>
            <param name="helper">The helper class.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.GetResourceAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Gets the lock protected resource.
            </summary>
            <param name="resourceMoniker">The identifier for the protected resource.</param>
            <param name="cancellationToken">A token whose cancellation signals lost interest in the protected resource.</param>
            <returns>A task whose result is the resource.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.Dispose">
            <summary>
            Releases the lock.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.ReleaseAsync">
            <summary>
            Asynchronously releases the lock.  Dispose should still be called after this.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AsyncReaderWriterResourceLock`2.ResourceReleaser.LockReleaser">
            <summary>
            Gets the underlying lock releaser.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions">
            <summary>
            Extension methods and awaitables for .NET 4.5.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.GetAwaiter(System.Threading.Tasks.TaskScheduler)">
            <summary>
            Gets an awaiter that schedules continuations on the specified scheduler.
            </summary>
            <param name="scheduler">The task scheduler used to execute continuations.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.SwitchTo(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
            <param name="scheduler">The task scheduler used to execute continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable">
            <summary>
            An awaitable that executes continuations on the specified task scheduler.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.taskScheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.alwaysYield">
            <summary>
            A value indicating whether the awaitable will always call the caller to yield.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.#ctor(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable"/> struct.
            </summary>
            <param name="taskScheduler">The task scheduler used to execute continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaitable.GetAwaiter">
            <summary>
            Gets an awaitable that schedules continuations on the specified scheduler.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter">
            <summary>
            An awaiter returned from <see cref="M:Microsoft.VisualStudio.Threading.AwaitExtensions.GetAwaiter(System.Threading.Tasks.TaskScheduler)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.scheduler">
            <summary>
            The scheduler for continuations.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.alwaysYield">
            <summary>
            A value indicating whether <see cref="P:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.IsCompleted"/>
            should always return false.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.#ctor(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter"/> class.
            </summary>
            <param name="scheduler">The scheduler for continuations.</param>
            <param name="alwaysYield">A value indicating whether the caller should yield even if
            already executing on the desired task scheduler.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation to execute using the specified task scheduler.
            </summary>
            <param name="action">The delegate to invoke.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.AwaitExtensions.TaskSchedulerAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether no yield is necessary.
            </summary>
            <value><c>true</c> if the caller is already running on that TaskScheduler.</value>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory">
            <summary>
            A JoinableTaskFactory base class for derived types that delegate some of their work to an existing instance.
            </summary>
            <remarks>
            All virtual methods default to calling into the inner <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> for its behavior,
            rather than the default behavior of the base class.
            This is useful because a derived-type cannot call protected methods on another instance of that type.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory">
            <summary>
            A factory for starting asynchronous tasks that can mitigate deadlocks
            when the tasks require the Main thread of an application and the Main
            thread may itself be blocking on the completion of a task.
            </summary>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.owner">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> that owns this instance.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.jobCollection">
            <summary>
            The collection to add all created tasks to. May be <c>null</c>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.hangDetectionTimeout">
            <summary>
            Backing field for the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.HangDetectionTimeout"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> class.
            </summary>
            <param name="owner">The context for the tasks created by this factory.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> class
            that adds all generated jobs to the specified collection.
            </summary>
            <param name="collection">The collection that all tasks created by this factory will belong to till they complete.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> class.
            </summary>
            <param name="owner">The context for the tasks created by this factory.</param>
            <param name="collection">The collection that all tasks created by this factory will belong to till they complete. May be null.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Threading.CancellationToken)">
            <summary>
            Gets an awaitable whose continuations execute on the synchronization context that this instance was initialized with,
            in such a way as to mitigate both deadlocks and reentrancy.
            </summary>
            <param name="cancellationToken">
            A token whose cancellation will immediately schedule the continuation
            on a threadpool thread.
            </param>
            <returns>An awaitable.</returns>
            <remarks>
            <example>
            <code>
            private async Task SomeOperationAsync() {
                // on the caller's thread.
                await DoAsync();
                
                // Now switch to a threadpool thread explicitly.
                await TaskScheduler.Default;
                
                // Now switch to the Main thread to talk to some STA object.
                await this.JobContext.SwitchToMainThreadAsync();
                STAService.DoSomething();
            }
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Boolean)">
            <summary>
            Posts a continuation to the main thread, always causing the caller to yield if specified.
            </summary>
            <param name="alwaysYield">if set to <c>true</c>, the awaitable will always cause the caller to yield, even if already on the main thread.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RequestSwitchToMainThread(System.Action)">
            <summary>
            Responds to calls to <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)"/>
            by scheduling a continuation to execute on the Main thread.
            </summary>
            <param name="callback">The callback to invoke.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.PostToUnderlyingSynchronizationContext(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Posts a message to the specified underlying SynchronizationContext for processing when the main thread
            is freely available.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <param name="state">State to pass to the callback.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.OnTransitioningToMainThread(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task has requested a transition to the main thread.
            </summary>
            <param name="joinableTask">The task requesting the transition to the main thread.</param>
            <remarks>
            This event may be raised on any thread, including the main thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.OnTransitionedToMainThread(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Raised whenever a joinable task has completed a transition to the main thread.
            </summary>
            <param name="joinableTask">The task whose request to transition to the main thread has completed.</param>
            <param name="canceled">A value indicating whether the transition was cancelled before it was fulfilled.</param>
            <remarks>
            This event is usually raised on the main thread, but can be on another thread when <paramref name="canceled"/> is <c>true</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.PostToUnderlyingSynchronizationContextOrThreadPool(Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector)">
            <summary>
            Posts a callback to the main thread via the underlying dispatcher,
            or to the threadpool when no dispatcher exists on the main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.WaitSynchronously(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            If running on the main thread, any applicable message pump is suppressed
            while the thread sleeps.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.WaitSynchronouslyCore(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>Runs the specified asynchronous method.</summary>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <remarks>
            <example>
            <code>
            // On threadpool or Main thread, this method will block
            // the calling thread until all async operations in the
            // delegate complete.
            this.JobContext.RunSynchronously(async delegate {
                // still on the threadpool or Main thread as before.
                await OperationAsync();
                // still on the threadpool or Main thread as before.
                await Task.Run(async delegate {
                     // Now we're on a threadpool thread.
                     await Task.Yield();
                     // still on a threadpool thread.
                });
                // Now back on the Main thread (or threadpool thread if that's where we started).
            });
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Runs the specified asynchronous method.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The asynchronous method to execute.</param>
            <returns></returns>
            <remarks>
            See the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})"/> overload documentation
            for an example.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Wraps the invocation of an async method such that it may
            execute asynchronously, but may potentially be
            synchronously completed (waited on) in the future.
            </summary>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <returns>An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.</returns>
            <remarks>Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/>.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Wraps the invocation of an async method such that it may
            execute asynchronously, but may potentially be
            synchronously completed (waited on) in the future.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <param name="asyncMethod">The method that, when executed, will begin the async operation.</param>
            <returns>
            An object that tracks the completion of the async operation, and allows for later synchronous blocking of the main thread for completion if necessary.
            </returns>
            <remarks>
            Exceptions thrown by the delegate are captured by the returned <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Add(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Adds the specified joinable task to the applicable collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.VerifyNoNonConcurrentSyncContext">
            <summary>
            Throws an exception if an active AsyncReaderWriterLock
            upgradeable read or write lock is held by the caller.
            </summary>
            <remarks>
            This is important to call from the Run and Run{T} methods because
            if they are called from within an ARWL upgradeable read or write lock,
            then Run will synchronously block while inside the semaphore held
            by the ARWL that prevents concurrency. If the delegate within Run
            yields and then tries to reacquire the ARWL lock, it will be unable
            to re-enter the semaphore, leading to a deadlock.
            Instead, callers who hold UR/W locks should never call Run, or should
            switch to the STA thread first in order to exit the semaphore before
            calling the Run method.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Context">
            <summary>
            Gets the joinable task context to which this factory belongs.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.ApplicableJobSyncContext">
            <summary>
            Gets the synchronization context to apply before executing work associated with this factory.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Collection">
            <summary>
            Gets the collection to which created tasks belong until they complete. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.HangDetectionTimeout">
            <summary>
            Gets or sets the timeout after which no activity while synchronously blocking
            suggests a hang has occurred.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.UnderlyingSynchronizationContext">
            <summary>
            Gets the underlying <see cref="T:System.Threading.SynchronizationContext"/> that controls the main thread in the host.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable">
            <summary>
            An awaitable struct that facilitates an asynchronous transition to the Main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable"/> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter">
            <summary>
            An awaiter struct that facilitates an asynchronous transition to the Main thread.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter"/> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a continuation for execution on the Main thread.
            </summary>
            <param name="continuation">The action to invoke when the operation completes.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.GetResult">
            <summary>
            Called on the Main thread to prepare it to execute the continuation.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.MainThreadAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the caller is already on the Main thread.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework">
            <summary>
            A value to construct with a C# using block in all the Run method overloads
            to setup and teardown the boilerplate stuff.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework"/> struct
            and sets up the synchronization contexts for the
            <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})"/> family of methods.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.RunFramework.Dispose">
            <summary>
            Reverts the execution context to its previous state before this struct was created.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector">
            <summary>
            A delegate wrapper that ensures the delegate is only invoked at most once.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.ExecuteOnce">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.ExecuteOnceWaitCallback">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.job">
            <summary>
            The job that created this wrapper.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.invokeDelegate">
            <summary>
            The delegate to invoke.  <c>null</c> if it has already been invoked.
            </summary>
            <value>May be of type <see cref="T:System.Action"/> or <see cref="T:System.Threading.SendOrPostCallback"/>.</value>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.state">
            <summary>
            The value to pass to the delegate if it is a <see cref="T:System.Threading.SendOrPostCallback"/>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.executingCallbacks">
            <summary>
            Stores execution callbacks for <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.AddExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.#ctor(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.AddExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)">
            <summary>
            Registers for a callback when this instance is executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.RemoveExecutingCallback(Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue)">
            <summary>
            Unregisters a callback for when this instance is executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.WalkReturnCallstack">
            <summary>
            Walk the continuation objects inside "async state machines" to generate the return callstack.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.Create(Microsoft.VisualStudio.Threading.JoinableTask,System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/> class.
            </summary>
            <param name="job">The joinable task responsible for this work.</param>
            <param name="action">The delegate being wrapped.</param>
            <returns>An instance of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.Create(Microsoft.VisualStudio.Threading.JoinableTask,System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/> class
            that describes the specified callback.
            </summary>
            <param name="job">The joinable task responsible for this work.</param>
            <param name="callback">The callback to invoke.</param>
            <param name="state">The state object to pass to the callback.</param>
            <returns>An instance of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.TryExecute">
            <summary>
            Executes the delegate if it has not already executed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.OnExecuting">
            <summary>
            Invokes <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue.OnExecuting(System.Object,System.EventArgs)"/> handler.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.GetDelegateLabel(System.Delegate)">
            <summary>
            A helper method to get the label of the given delegate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.FindAsyncStateMachine(System.Delegate)">
            <summary>
            A helper method to find the async state machine from the given delegate.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.GetFieldValue(System.Object,System.String)">
            <summary>
            A helper method to get field's value given the object and the field name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.GetStateMachineFieldValueOnSuffix(System.Runtime.CompilerServices.IAsyncStateMachine,System.String)">
            <summary>
            The field names of "async state machine" are not fixed; the workaround is to find the field based on the suffix.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.FindContinuationDelegates(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>
            This is the core to find the continuation delegate(s) inside the given async state machine.
            The chain of objects is like this: async state machine -> async method builder -> task -> continuation object -> action.
            </summary>
            <remarks>
            There are 3 types of "async method builder": AsyncVoidMethodBuilder, AsyncTaskMethodBuilder, AsyncTaskMethodBuilder&lt;T&gt;.
            We don't cover AsyncVoidMethodBuilder as it is used rarely and it can't be awaited either;
            AsyncTaskMethodBuilder is a wrapper on top of AsyncTaskMethodBuilder&lt;VoidTaskResult&gt;.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.HasBeenExecuted">
            <summary>
            Gets a value indicating whether this instance has already executed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector.DelegateLabel">
            <summary>
            Gets a string that describes the delegate that this instance invokes.
            FOR DIAGNOSTIC PURPOSES ONLY.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.innerFactory">
            <summary>
            The inner factory that will create the tasks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes an instance of the <see cref="T:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory"/> class.
            </summary>
            <param name="innerFactory">The inner factory that will create the tasks.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.WaitSynchronously(System.Threading.Tasks.Task)">
            <summary>
            Synchronously blocks the calling thread for the completion of the specified task.
            </summary>
            <param name="task">The task whose completion is being waited on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.PostToUnderlyingSynchronizationContext(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Posts a message to the specified underlying SynchronizationContext for processing when the main thread
            is freely available.
            </summary>
            <param name="callback">The callback to invoke.</param>
            <param name="state">State to pass to the callback.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.OnTransitioningToMainThread(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task has requested a transition to the main thread.
            </summary>
            <param name="joinableTask">The task requesting the transition to the main thread.</param>
            <remarks>
            This event may be raised on any thread, including the main thread.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.DelegatingJoinableTaskFactory.OnTransitionedToMainThread(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Raised whenever a joinable task has completed a transition to the main thread.
            </summary>
            <param name="joinableTask">The task whose request to transition to the main thread has completed.</param>
            <param name="canceled">A value indicating whether the transition was cancelled before it was fulfilled.</param>
            <remarks>
            This event is usually raised on the main thread, but can be on another thread when <paramref name="canceled"/> is <c>true</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.Dgml.Namespace">
            <summary>
            The namespace that all DGML nodes appear in.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.Dgml.WithCategories(System.Xml.Linq.XElement,System.String[])">
            <summary>
            Adds categories to a DGML node or link.
            </summary>
            <param name="element">The node or link to add categories to.</param>
            <param name="categories">The categories to add.</param>
            <returns>The same node that was passed in. To enable "fluent" syntax.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.EmptyStruct">
            <summary>
            An empty struct.
            </summary>
            <remarks>
            This can save 4 bytes over System.Object when a type argument is required for a generic type, but entirely unused.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EmptyStruct.Instance">
            <summary>
            Gets an instance of the empty struct.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1">
            <summary>
            Enumerates either a single element or a list of elements.
            </summary>
            <typeparam name="T">The type of element to enumerate.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.value">
            <summary>
            The single element to enumerate, when applicable.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.enumerator">
            <summary>
            The enumerator of the list.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.justOne">
            <summary>
            A value indicating whether a single element or a list of them is being enumerated.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.position">
            <summary>
            The position around the lone element being enumerated, when applicable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1"/> struct.
            </summary>
            <param name="value">The single value to enumerate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1"/> struct.
            </summary>
            <param name="values">The list of values to enumerate.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.Dispose">
            <summary>
            Disposes this enumerator.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.MoveNext">
            <summary>
            Advances enumeration to the next element.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.System#Collections#IEnumerator#Reset">
            <summary>
            Resets this enumerator.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.Current">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.EnumerateOneOrMany`1.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current value.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.HangReportContribution">
            <summary>
            A contribution to an aggregate hang report.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.HangReportContribution.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.HangReportContribution"/> class.
            </summary>
            <param name="content">The content for the hang report.</param>
            <param name="contentType">The MIME type of the attached content.</param>
            <param name="contentName">The suggested filename of the content when it is attached in a report.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.HangReportContribution.#ctor(System.String,System.String,System.String,Microsoft.VisualStudio.Threading.HangReportContribution[])">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.HangReportContribution"/> class.
            </summary>
            <param name="content">The content for the hang report.</param>
            <param name="contentType">The MIME type of the attached content.</param>
            <param name="contentName">The suggested filename of the content when it is attached in a report.</param>
            <param name="nestedReports">Nested reports.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.Content">
            <summary>
            Gets the content of the hang report.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.ContentType">
            <summary>
            Gets the MIME type for the content.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.ContentName">
            <summary>
            Gets the suggested filename for the content.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.HangReportContribution.NestedReports">
            <summary>
            Gets the nested hang reports, if any.
            </summary>
            <value>A read only collection, or <c>null</c>.</value>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.IAsyncDisposable">
            <summary>
            Defines an asynchronous method to release allocated resources.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.IAsyncDisposable.DisposeAsync">
            <summary>
            Performs application-defined tasks associated with freeing,
            releasing, or resetting unmanaged resources asynchronously.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.InternalUtilities">
            <summary>
            Internal helper/extension methods for this assembly's own use.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.InternalUtilities.RemoveMidQueue``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Removes an element from the middle of a queue without disrupting the other elements.
            </summary>
            <typeparam name="T">The element to remove.</typeparam>
            <param name="queue">The queue to modify.</param>
            <param name="valueToRemove">The value to remove.</param>
            <remarks>
            If a value appears multiple times in the queue, only its first entry is removed.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask">
            <summary>
            Tracks asynchronous operations and provides the ability to Join those operations to avoid
            deadlocks while synchronously blocking the Main thread for the operation's completion.
            </summary>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.owner">
            <summary>
            The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> that began the async operation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.collectionMembership">
            <summary>
            The collections that this job is a member of.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.childOrJoinedJobs">
            <summary>
            A map of jobs that we should be willing to dequeue from when we control the UI thread, and a ref count. Lazily constructed.
            </summary>
            <remarks>
            When the value in an entry is decremented to 0, the entry is removed from the map.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.dequeuerResetState">
            <summary>
            An event that is signaled <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.childOrJoinedJobs"/> has changed, or queues are lazily constructed. Lazily constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.mainThreadQueue">
            <summary>The queue of work items. Lazily constructed.</summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.initialDelegate">
            <summary>
            Store the task's initial delegate so we could show its full name in hang report.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Boolean,System.Delegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/> class.
            </summary>
            <param name="owner">The instance that began the async operation.</param>
            <param name="synchronouslyBlocking">A value indicating whether the launching thread will synchronously block for this job's completion.</param>
            <param name="initialDelegate">The entry method's info for diagnostics.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.Join(System.Threading.CancellationToken)">
            <summary>
            Synchronously blocks the calling thread until the operation has completed.
            If the caller is on the Main thread (or is executing within a JoinableTask that has access to the main thread)
            the caller's access to the Main thread propagates to this JoinableTask so that it may also access the main thread.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinAsync(System.Threading.CancellationToken)">
            <summary>
            Shares any access to the main thread the caller may have 
            Joins any main thread affinity of the caller with the asynchronous operation to avoid deadlocks
            in the event that the main thread ultimately synchronously blocks waiting for the operation to complete.
            </summary>
            <param name="cancellationToken">
            A cancellation token that will revert the Join and cause the returned task to complete
            before the async operation has completed.
            </param>
            <returns>A task that completes after the asynchronous operation completes and the join is reverted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.GetAwaiter">
            <summary>
            Gets an awaiter that is equivalent to calling <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinAsync(System.Threading.CancellationToken)"/>.
            </summary>
            <returns>A task whose result is the result of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.Complete">
            <summary>
            Fires when the underlying Task is completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.AddSelfAndDescendentOrJoinedJobs(System.Collections.Generic.HashSet{Microsoft.VisualStudio.Threading.JoinableTask})">
            <summary>
            Recursively adds this joinable and all its dependencies to the specified set, that are not yet completed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread">
            <summary>Runs a loop to process all queued work items, returning only when the task is completed.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.AddStateFlags(Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags)">
            <summary>
            Adds the specified flags to the <see cref="F:Microsoft.VisualStudio.Threading.JoinableTask.state"/> field.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.AddDependency(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Adds an <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> instance as one that is relevant to the async operation.
            </summary>
            <param name="joinChild">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/> to join as a child.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.IsCompleted">
            <summary>
            Gets a flag indicating whether the async operation represented by this instance has completed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.Task">
            <summary>
            Gets the asynchronous task that completes when the async operation completes.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.State">
            <summary>
            Gets the flags set on this task.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.EntryMethodInfo">
            <summary>
            Gets the entry method's info so we could show its full name in hang report.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.HasNonEmptyQueue">
            <summary>
            Gets a value indicating whether this task has a non-empty queue.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ChildOrJoinedJobs">
            <summary>
            Gets a snapshot of all joined tasks.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.MainThreadQueueContents">
            <summary>
            Gets a snapshot of all work queued to the main thread.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ThreadPoolQueueContents">
            <summary>
            Gets a snapshot of all work queued to synchronously blocking threadpool thread.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ContainingCollections">
            <summary>
            Gets the collections this task belongs to.
            FOR DIAGNOSTICS COLLECTION ONLY.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.IsCompleteRequested">
            <summary>
            Gets or sets a value indicating whether this task has had its Complete() method called..
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext">
            <summary>
            A synchronization context that forwards posted messages to the ambient job.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.jobFactory">
            <summary>
            The owning job factory.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.mainThreadAffinitized">
            <summary>
            A flag indicating whether messages posted to this instance should execute
            on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.job">
            <summary>
            The owning job. May be null from the beginning, or cleared after task completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext"/> class
            that is affinitized to the main thread.
            </summary>
            <param name="owner">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> that created this instance.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.#ctor(Microsoft.VisualStudio.Threading.JoinableTask,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext"/> class.
            </summary>
            <param name="joinableTask">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/> that owns this instance.</param>
            <param name="mainThreadAffinitized">A value indicating whether messages posted to this instance should execute on the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Forwards the specified message to the job this instance belongs to if applicable; otherwise to the factory.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Forwards a message to the ambient job and blocks on its execution.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.OnCompleted">
            <summary>
            Called by the joinable task when it has completed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskSynchronizationContext.MainThreadAffinitized">
            <summary>
            Gets a value indicating whether messages posted to this instance should execute
            on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.None">
            <summary>
            No other flags defined.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.StartedSynchronously">
            <summary>
            This task was originally started as a synchronously executing one.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.StartedOnMainThread">
            <summary>
            This task was originally started on the main thread.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompleteRequested">
            <summary>
            This task has had its Complete method called, but has lingering continuations to execute.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompleteFinalized">
            <summary>
            This task has completed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.CompletingSynchronously">
            <summary>
            This exact task has been passed to the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread"/> method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTask.JoinableTaskFlags.SynchronouslyBlockingMainThread">
            <summary>
            This exact task has been passed to the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask.CompleteOnCurrentThread"/> method
            on the main thread.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue">
            <summary>
            A thread-safe queue of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SingleExecuteProtector"/> elements
            that self-scavenges elements that are executed by other means.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask.ExecutionQueue.EnqueuedNotify">
            <summary>
            Gets a task that completes when the queue is non-empty or completed.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext">
            <summary>
            A common context within which joinable tasks may be created and interact to avoid deadlocks.
            </summary>
            <devremarks>
            Lots of documentation and FAQ on Joinable Tasks is available on OneNote: <![CDATA[
            http://devdiv/sites/vspe/prjbld/_layouts/OneNote.aspx?id=%2fsites%2fvspe%2fprjbld%2fOneNote%2fTeamInfo&wd=target%28VS%20Threading.one%7c46FEAAD0-0131-45EE-8C52-C9893F1FD331%2fThreading%20Rules%7cD0EEFAB9-99C0-4B8F-AA5F-4287DD69A38F%2f%29
            ]]>
            </devremarks>
            <remarks>
            There are three rules that should be strictly followed when using or interacting
            with JoinableTasks:
             1. If a method has certain thread apartment requirements (STA or MTA) it must either:
                  a) Have an asynchronous signature, and asynchronously marshal to the appropriate 
                     thread if it isn't originally invoked on a compatible thread. 
                     The recommended way to switch to the main thread is:
                     <code>
                     await JoinableTaskFactory.SwitchToMainThreadAsync();
                     </code>
                  b) Have a synchronous signature, and throw an exception when called on the wrong thread.
                In particular, no method is allowed to synchronously marshal work to another thread
                (blocking while that work is done). Synchronous blocks in general are to be avoided
                whenever possible.
             2. When an implementation of an already-shipped public API must call asynchronous code
                and block for its completion, it must do so by following this simple pattern:
                <code>
                JoinableTaskFactory.Run(async delegate {
                    await SomeOperationAsync(...);
                });
                </code>
             3. If ever awaiting work that was started earlier, that work must be Joined.
                For example, one service kicks off some asynchronous work that may later become
                synchronously blocking:
                <code>
                JoinableTask longRunningAsyncWork = JoinableTaskFactory.RunAsync(async delegate {
                    await SomeOperationAsync(...);
                });
                </code>
                Then later that async work becomes blocking:
                <code>
                longRunningAsyncWork.Join();
                </code>
                or perhaps:
                <code>
                await longRunningAsyncWork;
                </code>
                Note however that this extra step is not necessary when awaiting is done
                immediately after kicking off an asynchronous operation.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.Microsoft#VisualStudio#Threading#IHangReportContributor#GetHangReport">
            <summary>
            Contributes data for a hang report.
            </summary>
            <returns>The hang report contribution.</returns>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.syncContextLock">
            <summary>
            A "global" lock that allows the graph of interconnected sync context and JoinableSet instances
            communicate in a thread-safe way without fear of deadlocks due to each taking their own private
            lock and then calling others, thus leading to deadlocks from lock ordering issues.
            </summary>
            <remarks>
            Yes, global locks should be avoided wherever possible. However even MEF from the .NET Framework
            uses a global lock around critical composition operations because containers can be interconnected
            in arbitrary ways. The code in this file has a very similar problem, so we use the same solution.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.joinableOperation">
            <summary>
            An AsyncLocal value that carries the joinable instance associated with an async operation.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.pendingTasks">
            <summary>
            The set of tasks that have started but have not yet completed.
            </summary>
            <remarks>
            All access to this collection should be guarded by locking this collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.hangNotifications">
            <summary>
            A set of receivers of hang notifications.
            </summary>
            <remarks>
            All access to this collection should be guarded by locking this collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.nonJoinableFactory">
            <summary>
            A single joinable task factory that itself cannot be joined.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.#ctor(System.Threading.Thread,System.Threading.SynchronizationContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> class.
            </summary>
            <param name="mainThread">The thread to switch to in <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.SwitchToMainThreadAsync(System.Threading.CancellationToken)"/>.</param>
            <param name="synchronizationContext">The synchronization context to use to switch to the main thread.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.SuppressRelevance">
            <summary>
            Conceals any JoinableTask the caller is associated with until the returned value is disposed.
            </summary>
            <returns>A value to dispose of to restore visibility into the caller's associated JoinableTask, if any.</returns>
            <remarks>
            <para>In some cases asynchronous work may be spun off inside a delegate supplied to Run,
            so that the work does not have privileges to re-enter the Main thread until the
            <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})"/> call has returned and the UI thread is idle.
            To prevent the asynchronous work from automatically being allowed to re-enter the Main thread,
            wrap the code that calls the asynchronous task in a <c>using</c> block with a call to this method 
            as the expression.</para>
            <example>
            <code>
            this.JoinableTaskContext.RunSynchronously(async delegate {
                using(this.JoinableTaskContext.SuppressRelevance()) {
                    var asyncOperation = Task.Run(async delegate {
                        // Some background work.
                        await this.JoinableTaskContext.SwitchToMainThreadAsync();
                        // Some Main thread work, that cannot begin until the outer RunSynchronously call has returned.
                    });
                }
                
                // Because the asyncOperation is not related to this Main thread work (it was suppressed),
                // the following await *would* deadlock if it were uncommented.
                ////await asyncOperation;
            });
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsMainThreadBlocked">
            <summary>
            Gets a value indicating whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateFactory(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Creates a joinable task factory that automatically adds all created tasks
            to a collection that can be jointly joined.
            </summary>
            <param name="collection">The collection that all tasks should be added to.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateCollection">
            <summary>
            Creates a collection for in-flight joinable tasks.
            </summary>
            <returns>A new joinable task collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnHangDetected(System.TimeSpan,System.Int32,System.Guid)">
            <summary>
            Invoked when a hang is suspected to have occurred involving the main thread.
            </summary>
            <param name="hangDuration">The duration of the current hang.</param>
            <param name="notificationCount">The number of times this hang has been reported, including this one.</param>
            <param name="hangId">A random GUID that uniquely identifies this particular hang.</param>
            <remarks>
            A single hang occurrence may invoke this method multiple times, with increasing
            values in the <paramref name="hangDuration"/> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.CreateDefaultFactory">
            <summary>
            Creates a factory without a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection"/>.
            </summary>
            <remarks>
            Used for initializing the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.Factory"/> property.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnJoinableTaskStarted(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task starts.
            </summary>
            <param name="task">The task that has started.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.OnJoinableTaskCompleted(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Raised when a joinable task completes.
            </summary>
            <param name="task">The completing task.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RegisterHangNotifications(Microsoft.VisualStudio.Threading.JoinableTaskContextNode)">
            <summary>
            Registers a node for notification when a hang is detected.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.Factory">
            <summary>
            Gets the factory which creates joinable tasks
            that do not belong to a joinable task collection.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.MainThread">
            <summary>
            Gets the main thread that can be shared by tasks created by this context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.IsWithinJoinableTask">
            <summary>
            Gets a value indicating whether the caller is currently running within the context of a joinable task.
            </summary>
            <remarks>
            Use of this property is generally discouraged, as any operation that becomes a no-op when no
            ambient JoinableTask is present is very cheap. For clients that have complex algorithms that are
            only relevant if an ambient joinable task is present, this property may serve to skip that for
            performance reasons.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.UnderlyingSynchronizationContext">
            <summary>
            Gets the underlying <see cref="T:System.Threading.SynchronizationContext"/> that controls the main thread in the host.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.SyncContextLock">
            <summary>
            Gets the context-wide synchronization lock.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContext.AmbientTask">
            <summary>
            Gets the caller's ambient joinable task.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration">
            <summary>
            A value whose disposal cancels hang registration.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.node">
            <summary>
            The node to receive notifications. May be <c>null</c> if <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.Dispose"/> has already been called.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContextNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.HangNotificationRegistration.Dispose">
            <summary>
            Removes the node from hang notifications.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance">
            <summary>
            A structure that clears CallContext and SynchronizationContext async/thread statics and
            restores those values when this structure is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance"/> struct.
            </summary>
            <param name="pump">The instance that created this value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContext.RevertRelevance.Dispose">
            <summary>
            Reverts the async local and thread static values to their original values.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection">
            <summary>
            A joinable collection of jobs.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.joinables">
            <summary>
            The set of jobs that belong to this collection -- that is, the set of jobs that are implicitly Joined
            when folks Join this collection.
            The value is the number of times the joinable was added to this collection (and not yet removed)
            if this collection is ref counted; otherwise the value is always 1.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.joiners">
            <summary>
            The set of jobs that have Joined this collection -- that is, the set of jobs that are interested
            in the completion of any and all jobs that belong to this collection.
            The value is the number of times a particular job has Joined this collection.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.refCountAddedJobs">
            <summary>
            A value indicating whether jobs are only removed when completed or removed as many times as they were added.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskCollection.emptyEvent">
            <summary>
            An event that is set when the collection is empty. (lazily initialized)
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection"/> class.
            </summary>
            <param name="context">The <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> instance to which this collection applies.</param>
            <param name="refCountAddedJobs">
            <c>true</c> if JoinableTask instances added to the collection multiple times should remain in the collection until they are
            either removed the same number of times or until they are completed;
            <c>false</c> causes the first Remove call for a JoinableTask to remove it from this collection regardless
            how many times it had been added.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Add(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Adds the specified job to this collection.
            </summary>
            <param name="job">The job to add to the collection.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Remove(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Removes the specified job from this collection,
            or decrements the ref count if this collection tracks that.
            </summary>
            <param name="job">The job to remove.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join">
            <summary>
            Shares access to the main thread that the caller's JoinableTask may have (if any) with all
            JoinableTask instances in this collection until the returned value is disposed.
            </summary>
            <returns>A value to dispose of to revert the join.</returns>
            <remarks>
            Calling this method when the caller is not executing within a JoinableTask safely no-ops.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinTillEmptyAsync">
            <summary>
            Joins the caller's context to this collection till the collection is empty.
            </summary>
            <returns>A task that completes when this collection is empty.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Contains(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Checks whether the specified job is a member of this collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Disjoin(Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Breaks a join formed between the specified job and this collection.
            </summary>
            <param name="job">The job that had previously joined this collection, and that now intends to revert it.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.GetEnumerator">
            <summary>
            Enumerates the tasks in this collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the tasks in this collection.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Context">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> to which this collection belongs.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease">
            <summary>
            A value whose disposal cancels a <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join"/> operation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease.#ctor(Microsoft.VisualStudio.Threading.JoinableTask,Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease"/> class.
            </summary>
            <param name="joined">The Main thread controlling SingleThreadSynchronizationContext to use to accelerate execution of Main thread bound work.</param>
            <param name="joiner">The instance that created this value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskCollection,Microsoft.VisualStudio.Threading.JoinableTask)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease"/> class.
            </summary>
            <param name="jobCollection">The collection of jobs that has been joined.</param>
            <param name="joiner">The instance that created this value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.JoinRelease.Dispose">
            <summary>
            Cancels the <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskCollection.Join"/> operation.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode">
            <summary>
            A customizable source of <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskFactory"/> instances.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.context">
            <summary>
            The inner JoinableTaskContext.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.nonJoinableFactory">
            <summary>
            A single joinable task factory that itself cannot be joined.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContextNode"/> class.
            </summary>
            <param name="context">The inner JoinableTaskContext.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateFactory(Microsoft.VisualStudio.Threading.JoinableTaskCollection)">
            <summary>
            Creates a joinable task factory that automatically adds all created tasks
            to a collection that can be jointly joined.
            </summary>
            <param name="collection">The collection that all tasks should be added to.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateCollection">
            <summary>
            Creates a collection for in-flight joinable tasks.
            </summary>
            <returns>A new joinable task collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.SuppressRelevance">
            <summary>
            Conceals any JoinableTask the caller is associated with until the returned value is disposed.
            </summary>
            <returns>A value to dispose of to restore visibility into the caller's associated JoinableTask, if any.</returns>
            <remarks>
            <para>In some cases asynchronous work may be spun off inside a delegate supplied to Run,
            so that the work does not have privileges to re-enter the Main thread until the
            <see cref="M:Microsoft.VisualStudio.Threading.JoinableTaskFactory.Run(System.Func{System.Threading.Tasks.Task})"/> call has returned and the UI thread is idle.
            To prevent the asynchronous work from automatically being allowed to re-enter the Main thread,
            wrap the code that calls the asynchronous task in a <c>using</c> block with a call to this method 
            as the expression.</para>
            <example>
            <code>
            this.JoinableTaskContext.RunSynchronously(async delegate {
                using(this.JoinableTaskContext.SuppressRelevance()) {
                    var asyncOperation = Task.Run(async delegate {
                        // Some background work.
                        await this.JoinableTaskContext.SwitchToMainThreadAsync();
                        // Some Main thread work, that cannot begin until the outer RunSynchronously call has returned.
                    });
                }
                
                // Because the asyncOperation is not related to this Main thread work (it was suppressed),
                // the following await *would* deadlock if it were uncommented.
                ////await asyncOperation;
            });
            </code>
            </example>
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.IsMainThreadBlocked">
            <summary>
            Gets a value indicating whether the main thread is blocked for the caller's completion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.OnHangDetected(System.TimeSpan,System.Int32,System.Guid)">
            <summary>
            Invoked when a hang is suspected to have occurred involving the main thread.
            </summary>
            <param name="hangDuration">The duration of the current hang.</param>
            <param name="notificationCount">The number of times this hang has been reported, including this one.</param>
            <param name="hangId">A random GUID that uniquely identifies this particular hang.</param>
            <remarks>
            A single hang occurrence may invoke this method multiple times, with increasing
            values in the <paramref name="hangDuration"/> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.CreateDefaultFactory">
            <summary>
            Creates a factory without a <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskCollection"/>.
            </summary>
            <remarks>
            Used for initializing the <see cref="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Factory"/> property.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.RegisterOnHangDetected">
            <summary>
            Registers with the inner <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/> to receive hang notifications.
            </summary>
            <returns>A value to dispose of to cancel hang notifications.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Factory">
            <summary>
            Gets the factory which creates joinable tasks
            that do not belong to a joinable task collection.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.MainThread">
            <summary>
            Gets the main thread that can be shared by tasks created by this context.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTaskContextNode.Context">
            <summary>
            Gets the inner wrapped context.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.JoinableTask`1">
            <summary>
            Tracks asynchronous operations and provides the ability to Join those operations to avoid
            deadlocks while synchronously blocking the Main thread for the operation's completion.
            </summary>
            <typeparam name="T">The type of value returned by the asynchronous operation.</typeparam>
            <remarks>
            For more complete comments please see the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTaskContext"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.#ctor(Microsoft.VisualStudio.Threading.JoinableTaskFactory,System.Boolean,System.Delegate)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.JoinableTask"/> class.
            </summary>
            <param name="owner">The instance that began the async operation.</param>
            <param name="synchronouslyBlocking">A value indicating whether the launching thread will synchronously block for this job's completion.</param>
            <param name="initialDelegate">The entry method's info for diagnostics.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.JoinAsync(System.Threading.CancellationToken)">
            <summary>
            Joins any main thread affinity of the caller with the asynchronous operation to avoid deadlocks
            in the event that the main thread ultimately synchronously blocks waiting for the operation to complete.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
            <returns>A task that completes after the asynchronous operation completes and the join is reverted, with the result of the operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.Join(System.Threading.CancellationToken)">
            <summary>
            Synchronously blocks the calling thread until the operation has completed.
            If the calling thread is the Main thread, deadlocks are mitigated.
            </summary>
            <param name="cancellationToken">A cancellation token that will exit this method before the task is completed.</param>
            <returns>The result of the asynchronous operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.JoinableTask`1.GetAwaiter">
            <summary>
            Gets an awaiter that is equivalent to calling <see cref="M:Microsoft.VisualStudio.Threading.JoinableTask`1.JoinAsync(System.Threading.CancellationToken)"/>.
            </summary>
            <returns>A task whose result is the result of the asynchronous operation.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.JoinableTask`1.Task">
            <summary>
            Gets the asynchronous task that completes when the async operation completes.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ListOfOftenOne`1">
            <summary>
            A thread-safe collection optimized for very small number of non-null elements.
            </summary>
            <typeparam name="T">The type of elements to be stored.</typeparam>
            <remarks>
            The collection is alloc-free for storage, retrieval and enumeration of collection sizes of 0 or 1.
            Beyond that causes one allocation for an immutable array that contains the entire collection.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.value">
            <summary>
            The single value or array of values stored by this collection. Null if empty.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for a current snapshot of the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Add(`0)">
            <summary>
            Adds an element to the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Remove(`0)">
            <summary>
            Removes an element from the collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.EnumerateAndClear">
            <summary>
            Atomically clears the collection's contents and returns an enumerator over the prior contents.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Combine(System.Object,`0)">
            <summary>
            Combines the previous contents of the collection with one additional value.
            </summary>
            <param name="baseValue">The collection's prior contents.</param>
            <param name="value">The value to add to the collection.</param>
            <returns>The new value to store as the collection.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ListOfOftenOne`1.Remove(System.Object,`0)">
            <summary>
            Removes a value from contents of the collection.
            </summary>
            <param name="baseValue">The collection's prior contents.</param>
            <param name="value">The value to remove from the collection.</param>
            <returns>The new value to store as the collection.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.NativeMethods">
            <summary>
            P/Invoke methods
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NativeMethods.WaitForMultipleObjects(System.UInt32,System.IntPtr[],System.Boolean,System.UInt32)">
            <summary>
            Really truly non pumping wait.
            Raw IntPtrs have to be used, because the marshaller does not support arrays of SafeHandle, only
            single SafeHandles.
            </summary>
            <param name="handleCount">The number of handles in the <paramref name="waitHandles"/> array.</param>
            <param name="waitHandles">The handles to wait for.</param>
            <param name="waitAll">A flag indicating whether all handles must be signaled before returning.</param>
            <param name="millisecondsTimeout">A timeout that will cause this method to return.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext">
            <summary>
            A SynchronizationContext whose synchronously blocking Wait method does not allow 
            any reentrancy via the message pump.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.DefaultInstance">
            <summary>
            A shared singleton.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.Wait(System.IntPtr[],System.Boolean,System.Int32)">
            <summary>
            Synchronously blocks without a message pump.
            </summary>
            <param name="waitHandles">An array of type <see cref="T:System.IntPtr" /> that contains the native operating system handles.</param>
            <param name="waitAll">true to wait for all handles; false to wait for any handle.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
            <returns>
            The array index of the object that satisfied the wait.
            </returns>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.NoMessagePumpSyncContext.Default">
            <summary>
            Gets a shared instance of this class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1">
            <summary>
            An incremental progress reporting mechanism that also allows
            asynchronous awaiting for all reports to be processed.
            </summary>
            <typeparam name="T">The type of message sent in progress updates.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.syncObject">
            <summary>
            The synchronization object.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.handler">
            <summary>
            The handler to invoke for each progress update.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.outstandingTasks">
            <summary>
            The set of progress reports that have started (but may not have finished yet).
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.taskFactory">
            <summary>
            The factory to use for spawning reports.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1"/> class.
            </summary>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.#ctor(System.Func{`0,System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1"/> class.
            </summary>
            <param name="handler">The async handler.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.System#IProgress{T}#Report(`0)">
            <summary>
            Receives a progress update.
            </summary>
            <param name="value">The value representing the updated progress.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ProgressWithCompletion`1.WaitAsync">
            <summary>
            Returns a task that completes when all reported progress has executed.
            </summary>
            <returns>A task that completes when all progress is complete.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.RollingLog`1">
            <summary>
            A thread-safe, enqueue-only queue that automatically discards older items.
            Used to help in bug investigations to find out what has happened recently.
            </summary>
            <typeparam name="T">The type of elements stored in the queue.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RollingLog`1.queue">
            <summary>
            The underlying queue.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.RollingLog`1.capacity">
            <summary>
            The maximum length of the queue.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.RollingLog`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.RollingLog`1"/> class.
            </summary>
            <param name="capacity">The maximum capacity of the queue, beyond which the oldest elements are dropped.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.RollingLog`1.Enqueue(`0)">
            <summary>
            Adds an item to the head of the queue.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.RollingLog`1.GetEnumerator">
            <summary>
            Enumerates the queue.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.RollingLog`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerates the queue.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.SpecializedSyncContext">
            <summary>
            A structure that applies and reverts changes to the <see cref="T:System.Threading.SynchronizationContext"/>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.initialized">
            <summary>
            A flag indicating whether the non-default constructor was invoked.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.prior">
            <summary>
            The SynchronizationContext to restore when <see cref="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Dispose"/> is invoked.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.appliedContext">
            <summary>
            The SynchronizationContext applied when this struct was constructed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.SpecializedSyncContext.checkForChangesOnRevert">
            <summary>
            A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.#ctor(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.SpecializedSyncContext"/> struct.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Apply(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Applies the specified <see cref="T:System.Threading.SynchronizationContext"/> to the caller's context.
            </summary>
            <param name="syncContext">The synchronization context to apply.</param>
            <param name="checkForChangesOnRevert">A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.SpecializedSyncContext.Dispose">
            <summary>
            Reverts the SynchronizationContext to its previous instance.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.CannotUpgradeNonUpgradeableLock">
            <summary>
              Looks up a localized string similar to A non-upgradeable read lock is held by the caller and cannot be upgraded..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.InvalidLock">
            <summary>
              Looks up a localized string similar to This operation can only be executed against a valid lock..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LazyValueFaulted">
            <summary>
              Looks up a localized string similar to Lazily created value faulted during construction..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LazyValueNotCreated">
            <summary>
              Looks up a localized string similar to Lazily created value not yet constructed..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.LockCompletionAlreadyRequested">
            <summary>
              Looks up a localized string similar to This lock has already been marked for completion.  No new top-level locks can be serviced..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.NotAllowedUnderURorWLock">
            <summary>
              Looks up a localized string similar to This operation is not allowed while holding an active upgradeable read or write lock from an AsyncReaderWriterLock..
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.Strings.ValueFactoryReentrancy">
            <summary>
              Looks up a localized string similar to The value factory has called for the value on the same instance..
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions">
            <summary>
            Extensions to the Task Parallel Library.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.CompletedTask">
            <summary>
            A singleton completed task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.CanceledTask">
            <summary>
            A task that is already canceled.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.TrueTask">
            <summary>
            A completed task with a <c>true</c> result.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.FalseTask">
            <summary>
            A completed task with a <c>false</c> result.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.WaitWithoutInlining(System.Threading.Tasks.Task)">
            <summary>
            Wait on a task without possibly inlining it to the current thread.
            </summary>
            <param name="task">The task to wait on.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyResultTo``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies one task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="task">The task whose completion should be applied to another.</param>
            <param name="tcs">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyResultTo``1(System.Threading.Tasks.Task,System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies one task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="task">The task whose completion should be applied to another.</param>
            <param name="tcs">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AttachToParent``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Creates a task that is attached to the parent task, but produces the same result as an existing task.
            </summary>
            <typeparam name="T">The type of value produced by the task.</typeparam>
            <param name="task">The task to wrap with an AttachedToParent task.</param>
            <returns>A task that is attached to parent.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Creates a task that is attached to the parent task, but produces the same result as an existing task.
            </summary>
            <param name="task">The task to wrap with an AttachedToParent task.</param>
            <returns>A task that is attached to parent.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.AppendAction(System.Threading.Tasks.Task,System.Action,System.Threading.Tasks.TaskContinuationOptions,System.Threading.CancellationToken)">
            <summary>
            Schedules some action for execution at the conclusion of a task, regardless of the task's outcome.
            </summary>
            <param name="task">The task that should complete before the posted <paramref name="action"/> is invoked.</param>
            <param name="action">The action to execute after <paramref name="task"/> has completed.</param>
            <param name="options">The task continuation options to apply.</param>
            <param name="cancellation">The cancellation token that signals the continuation should not execute (if it has not already begun).</param>
            <returns>
            The task that will execute the action.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletion``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Gets a task that will eventually produce the result of another task, when that task finishes.
            If that task is instead canceled, its successor will be followed for its result, iteratively.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="taskToFollow">The task whose result should be returned by the following task.</param>
            <param name="ultimateCancellation">A token whose cancellation signals that the following task should be cancelled.</param>
            <param name="taskThatFollows">The TaskCompletionSource whose task is to follow.  Leave at <c>null</c> for a new task to be created.</param>
            <returns>The following task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowAwaitable(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Returns an awaitable for the specified task that will never throw, even if the source task
            faults or is canceled.
            </summary>
            <param name="task">The task whose completion should signal the completion of the returned awaitable.</param>
            <param name="captureContext">if set to <c>true</c> the continuation will be scheduled on the caller's context; <c>false</c> to always execute the continuation on the threadpool.</param>
            <returns>An awaitable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.Forget(System.Threading.Tasks.Task)">
            <summary>
            Consumes a task and doesn't do anything with it.  Useful for fire-and-forget calls to async methods within async methods.
            </summary>
            <param name="task">The task whose result is to be ignored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.InvokeAsync(Microsoft.VisualStudio.Threading.AsyncEventHandler,System.Object,System.EventArgs)">
            <summary>
            Invokes asynchronous event handlers, returning a task that completes when all event handlers have been invoked.
            Each handler is fully executed (including continuations) before the next handler in the list is invoked.
            </summary>
            <param name="handlers">The event handlers.  May be <c>null</c></param>
            <param name="sender">The event source.</param>
            <param name="args">The event argument.</param>
            <returns>The task that completes when all handlers have completed.</returns>
            <exception cref="T:System.AggregateException">Thrown if any handlers fail. It contains a collection of all failures.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.InvokeAsync``1(Microsoft.VisualStudio.Threading.AsyncEventHandler{``0},System.Object,``0)">
            <summary>
            Invokes asynchronous event handlers, returning a task that completes when all event handlers have been invoked.
            Each handler is fully executed (including continuations) before the next handler in the list is invoked.
            </summary>
            <typeparam name="TEventArgs">The type of argument passed to each handler.</typeparam>
            <param name="handlers">The event handlers.  May be <c>null</c></param>
            <param name="sender">The event source.</param>
            <param name="args">The event argument.</param>
            <returns>The task that completes when all handlers have completed.  The task is faulted if any handlers throw an exception.</returns>
            <exception cref="T:System.AggregateException">Thrown if any handlers fail. It contains a collection of all failures.</exception>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ToApm``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Converts a TPL task to the APM Begin-End pattern.
            </summary>
            <typeparam name="TResult">The result value to be returned from the End method.</typeparam>
            <param name="task">The task that came from the async method.</param>
            <param name="callback">The optional callback to invoke when the task is completed.</param>
            <param name="state">The state object provided by the caller of the Begin method.</param>
            <returns>A task (that implements <see cref="T:System.IAsyncResult"/> that should be returned from the Begin method.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ToApm(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Converts a TPL task to the APM Begin-End pattern.
            </summary>
            <param name="task">The task that came from the async method.</param>
            <param name="callback">The optional callback to invoke when the task is completed.</param>
            <param name="state">The state object provided by the caller of the Begin method.</param>
            <returns>A task (that implements <see cref="T:System.IAsyncResult"/> that should be returned from the Begin method.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.CreateCanceledTask">
            <summary>
            Creates a canceled task.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyCompletedTaskResultTo``1(System.Threading.Tasks.Task{``0},System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            Applies a completed task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="completedTask">The task whose completion should be applied to another.</param>
            <param name="taskCompletionSource">The task that should receive the completion status.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.ApplyCompletedTaskResultTo``1(System.Threading.Tasks.Task,System.Threading.Tasks.TaskCompletionSource{``0},``0)">
            <summary>
            Applies a completed task's results to another.
            </summary>
            <typeparam name="T">The type of value returned by a task.</typeparam>
            <param name="completedTask">The task whose completion should be applied to another.</param>
            <param name="taskCompletionSource">The task that should receive the completion status.</param>
            <param name="valueOnRanToCompletion">The value to set on the completion source when the source task runs to completion.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletionHelper``1(Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource{Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState{``0},``0},System.Threading.Tasks.Task{``0})">
            <summary>
            Gets a task that will eventually produce the result of another task, when that task finishes.
            If that task is instead canceled, its successor will be followed for its result, iteratively.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="tcs">The TaskCompletionSource whose task is to follow.</param>
            <param name="currentTask">The current task.</param>
            <returns>
            The following task.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2">
            <summary>
            A task completion source that contains additional state.
            </summary>
            <typeparam name="TState">The type of the state.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.#ctor(`0,System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2"/> class.
            </summary>
            <param name="sourceState">The state to store in the <see cref="P:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.SourceState"/> property.</param>
            <param name="taskState">State of the task.</param>
            <param name="options">The options.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.TaskCompletionSource`2.SourceState">
            <summary>
            Gets or sets the state passed into the constructor.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable">
            <summary>
            An awaitable that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.task">
            <summary>
            The task.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">Whether the continuation should be scheduled on the current sync context.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaitable.GetAwaiter">
            <summary>
            Gets the awaiter.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter">
            <summary>
            An awaiter that wraps a task and never throws an exception when waited on.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.task">
            <summary>
            The task
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.captureContext">
            <summary>
            A value indicating whether the continuation should be scheduled on the current sync context.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.#ctor(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter"/> struct.
            </summary>
            <param name="task">The task.</param>
            <param name="captureContext">if set to <c>true</c> [capture context].</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.OnCompleted(System.Action)">
            <summary>
            Schedules a delegate for execution at the conclusion of a task's execution.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.GetResult">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.NoThrowTaskAwaiter.IsCompleted">
            <summary>
            Gets a value indicating whether the task has completed.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1">
            <summary>
            A state bag for the <see cref="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskToCompletion``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskCompletionSource{``0})"/> method.
            </summary>
            <typeparam name="T">The type of value ultimately returned.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.getTaskToFollow">
            <summary>
            The delegate that returns the task to follow.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.#ctor(System.Func{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1"/> struct.
            </summary>
            <param name="getTaskToFollow">The get task to follow.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.UltimateCancellation">
            <summary>
            Gets the ultimate cancellation token.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.RegisteredCallback">
            <summary>
            Gets or sets the cancellation token registration to dispose of when the task completes normally.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.TplExtensions.FollowCancelableTaskState`1.CurrentTask">
            <summary>
            Gets the current task to follow.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingTools">
            <summary>
            Utility methods for working across threads.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.ApplyChangeOptimistically``1(``0@,System.Func{``0,``0})">
            <summary>
            Optimistically performs some value transformation based on some field and tries to apply it back to the field,
            retrying as many times as necessary until no other thread is manipulating the same field.
            </summary>
            <typeparam name="T">The type of data.</typeparam>
            <param name="hotLocation">The field that may be manipulated by multiple threads.</param>
            <param name="applyChange">A function that receives the unchanged value and returns the changed value.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellation``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token, 
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellation(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token, 
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.Apply(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Applies the specified <see cref="T:System.Threading.SynchronizationContext"/> to the caller's context.
            </summary>
            <param name="syncContext">The synchronization context to apply.</param>
            <param name="checkForChangesOnRevert">A value indicating whether to check that the applied SyncContext is still the current one when the original is restored.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.CreateFaultedTask(System.Exception)">
            <summary>
            Creates a faulted task with the specified exception.
            </summary>
            <param name="exception">The exception to fault the task with.</param>
            <returns>The faulted task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellationSlow``1(System.Threading.Tasks.Task{``0},System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token, 
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <typeparam name="T">The type of value returned by the task.</typeparam>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.WithCancellationSlow(System.Threading.Tasks.Task,System.Threading.CancellationToken)">
            <summary>
            Wraps a task with one that will complete as cancelled based on a cancellation token, 
            allowing someone to await a task but be able to break out early by cancelling the token.
            </summary>
            <param name="task">The task to wrap.</param>
            <param name="cancellationToken">The token that can be canceled to break out of the await.</param>
            <returns>The wrapping task.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.ThreadingTools.SingletonTask`1">
            <summary>
            Wraps a Task{T} that has already been canceled.
            </summary>
            <typeparam name="T">The type of value that might have been returned by the task except for its cancellation.</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.ThreadingTools.SingletonTask`1.CanceledTask">
            <summary>
            A task that is already canceled.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.ThreadingTools.SingletonTask`1.CreateCanceledTask">
            <summary>
            Creates a canceled task.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2">
            <summary>
            Dictionary that does not prevent keys from being garbage collected.
            </summary>
            <typeparam name="TKey">Type of key, without the WeakReference wrapper.</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
            <remarks>
            See also Microsoft.Build.Collections.WeakDictionary.
            </remarks>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.dictionary">
            <summary>
            The dictionary used internally to store the keys and values.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.keyComparer">
            <summary>
            The key comparer to use for hashing and equality checks.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.capacity">
            <summary>
            The dictionary's initial capacity, and the capacity beyond which we will resist to grow
            by scavenging for collected keys first.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2"/> class.
            </summary>
            <param name="keyComparer">The key comparer to use. A <c>null</c> value indicates the default comparer will be used.</param>
            <param name="capacity">The initial capacity of the dictionary. Growth beyond this capacity will first induce a scavenge operation.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.ContainsKey(`0)">
            <summary>
            Whether there is a key present with the specified key
            </summary>
            <remarks>
            As usual, don't just call Contained as the wrapped value may be null.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get the value for the provided key.
            Returns true if the key is found, otherwise false.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Remove(`0)">
            <summary>
            Removes an entry with the specified key.
            Returns true if found, false otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Scavenge">
            <summary>
            Remove any entries from the dictionary that represent keys
            that have been garbage collected.
            </summary>
            <returns>The number of entries removed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Clear">
            <summary>
            Empty the collection
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.GetEnumerator">
            <summary>
            See IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{TKey@TValue}}#GetEnumerator">
            <summary>
            See IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            See IEnumerable
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Count">
            <summary>
            Count of entries.
            Some entries may represent keys or values that have already been garbage collected.
            To clean these out call <see cref="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Scavenge"/>.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.Item(`0)">
            <summary>
            Obtains the value for a given key.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1">
            <summary>
            Strongly typed wrapper around a weak reference that caches 
            the target's hash code so that it can be used in a hashtable.
            </summary>
            <typeparam name="T">Type of the target of the weak reference</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.hashcode">
            <summary>
            Cache the hashcode so that it is still available even if the target has been 
            collected. This allows this object to be still found in a table so it can be removed.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.weakReference">
            <summary>
            Backing weak reference
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.notSoWeakTarget">
            <summary>
            Some of the instances are around just to do existence checks, and don't want
            to allocate WeakReference objects as they are short-lived.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.#ctor(`2,System.Collections.Generic.IEqualityComparer{`2},System.Boolean)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.GetHashCode">
            <summary>
            Returns the hashcode of the wrapped target
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.Equals(System.Object)">
            <summary>
            Compares two structures.  
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.Target">
            <summary>
            Target wrapped by this weak reference.  Null if the target has already been garbage collected.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReference`1.IsAlive">
            <summary>
            Whether the target has not been garbage collected yet.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1">
            <summary>
            Equality comparer for weak references that actually compares the 
            targets of the weak references
            </summary>
            <typeparam name="T">Type of the targets of the weak references to be compared</typeparam>
        </member>
        <member name="F:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.underlyingComparer">
            <summary>
            Comparer to use if specified, otherwise null
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.#ctor(System.Collections.Generic.IEqualityComparer{`2})">
            <summary>
            Constructor to use an explicitly specified comparer.
            Comparer may be null, in which case the default comparer for the type
            will be used.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.GetHashCode(Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2})">
            <summary>
            Gets the hashcode
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.Threading.WeakKeyDictionary`2.WeakReferenceEqualityComparer`1.Equals(Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2},Microsoft.VisualStudio.Threading.WeakKeyDictionary{`0,`1}.WeakReference{`2})">
            <summary>
            Compares the weak references for equality
            </summary>
        </member>
    </members>
</doc>
